{"title":"ACM学习笔记day6(离散化)","uid":"1e7a8acd61656fdbe512e6f88b5aff86","slug":"ACM学习笔记day6","date":"2022-11-10T13:57:48.000Z","updated":"2023-04-08T10:49:10.497Z","comments":true,"path":"api/articles/ACM学习笔记day6.json","keywords":null,"cover":"/img/codeforces.jpg","content":"<p>其实这一节，应该是day5里面的，因为呃呃呃<br>我看到这一节acwing里面的视频长度比较长，所以我就分割出来<br>作为单独的一个blog来写了。<br>算法的思想比较重要。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"离散化\"><a href=\"#离散化\" class=\"headerlink\" title=\"离散化\"></a>离散化</h2><hr>\n<p>题目acwing<a href=\"https://www.acwing.com/activity/content/problem/content/836/\">区间和</a><br>说实话，离散化的概念不难理解<br>但是实际运用起来，发现诶，用不来了</p>\n<h2 id=\"首先，什么是离散化？\"><a href=\"#首先，什么是离散化？\" class=\"headerlink\" title=\"首先，什么是离散化？\"></a>首先，什么是离散化？</h2><p>离散化一般用于数据范围很大，但是里面有效数据却分布的十分零散的情况，我们把这些及其离散的数据存放到密集的另外一个数组里面去<br>这个过程就被称为离散化。<br>什么意思呢？<br>就像上面那题，数据范围在±10^9之间，但是他加c只执行顶多10^5次，可以看出，有很多的地方其实是根本没有数据的，也就是零<br>这题中我们就是将里面离散的数据存放到了a之中。<br>a数据里面的有效数据是十分密集的。<br>下面来具体理解一下这题的思路。<br><br><br><br><br>n和m分别是进行n次加值的操作，m是m次询问，问你区间和。<br>那么我们就设立一个alloperator数组，用来存放所有的被操作的index<br>其次使用a数组存放他加减的值<br>然后用add和query数组来暂时存放他的加值操作和询问操作。<br>下面结合代码讲解：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nconstexpr auto INF &#x3D; 2100000000;\nconstexpr auto INF64 &#x3D; 1e18;\nconst int N &#x3D; 300010;\ntypedef pair&lt;int, int&gt; PII;\nint n, m;\nint a[N],s[N];  &#x2F;&#x2F;a数组为存放数据的数字，s数组为a数组的前缀和数组\nvector&lt;int&gt; alloperator;  &#x2F;&#x2F;存放所有操作数的数组\nvector&lt;PII&gt; add, query;  &#x2F;&#x2F;暂时存放他add的操作，和询问的操作\n\nint find(int x) &#123;  &#x2F;&#x2F;查找函数，给你一个x，去查找离散化之后的对应的index应该是多少，return r+1，是为了让index从1开始，方便求前缀和和O（1）的输出\n    int l &#x3D; 0, r &#x3D; alloperator.size() - 1; &#x2F;&#x2F;二分法查找。也可以用lowerbound函数\n    while (l &lt; r) &#123;\n        int  mid &#x3D; (l + r) &#x2F; 2;\n        if (alloperator[mid] &gt;&#x3D; x) &#123;\n            r &#x3D; mid;\n        &#125;\n        else &#123;\n            l &#x3D; mid + 1;\n        &#125;\n    &#125;\n    return r + 1;\n&#125;\n\nint main()\n&#123;\n    cin &gt;&gt; n &gt;&gt; m;\n    for (int i &#x3D; 0; i &lt; n; i++) &#123;\n        int x, c;\n        cin &gt;&gt; x &gt;&gt; c;\n        add.push_back(&#123; x,c &#125;); &#x2F;&#x2F;暂存add操作\n        alloperator.push_back(x);  &#x2F;&#x2F;这里的alloperator是存放所有的操作数，最后去重就可以了\n     &#125;\n    for (int i &#x3D; 0; i &lt; m; i++) &#123;\n        int l, r;\n        cin &gt;&gt; l &gt;&gt; r;\n        query.push_back(&#123; l,r &#125;); &#x2F;&#x2F;暂存query操作\n        alloperator.push_back(l);\n        alloperator.push_back(r);\n    &#125;\n    sort(alloperator.begin(), alloperator.end());\n    alloperator.erase(unique(alloperator.begin(), alloperator.end()), alloperator.end());\n    &#x2F;&#x2F;关键的一步，给alloperator排序，然后去重，去重可以把不必要的数据去掉，反正都有\n    &#x2F;&#x2F;然后排序是为了方便二分查找。\n    &#x2F;&#x2F;其实这样操作过后呢，我们已经准备好了映射了，接下来就是每一个操作数对应一个a之中的映射值就可以了。\n    &#x2F;&#x2F;为什么查询操作里面的l和r也要放进来呢？因为会用到啊，没有加值就是零呗\n    for (int i &#x3D; 0; i &lt;n ; i++) &#123;\n        int x &#x3D; find(add[i].first); &#x2F;&#x2F;这里我们把add数组里面也就是我们之前存的操作，进行一遍\n        a[x] +&#x3D; add[i].second; &#x2F;&#x2F;将该加的值加上去，此时其实是已经有映射了，我们采用的映射就是一一映射过去的。\n    &#125;\n    for (int i &#x3D; 1; i &lt;&#x3D; alloperator.size(); i++) &#123;\n        s[i] &#x3D; s[i - 1] + a[i]; &#x2F;&#x2F;求a的前缀和，当然，这里要注意，i的次数得跟着alloperator的次数来\n                                &#x2F;&#x2F;因为我们d询问里面操作的位数都放在了这里面了已经\n        \n    &#125;\n    for (int i &#x3D; 0; i &lt; m; i++) &#123;\n        int l &#x3D; find(query[i].first), r &#x3D; find(query[i].second); &#x2F;&#x2F;进行询问操作，和前缀和里面一样，不过赘述\n        cout &lt;&lt; s[r] - s[l - 1] &lt;&lt; endl;\n    &#125;\n    return 0;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>总的来说，这东西感觉还是比较难理解的。<br>emm<br>搞了好几个小时<br>呃呃呃<br>那么<br>That’s all<br>bye~</p>\n","text":"其实这一节，应该是day5里面的，因为呃呃呃我看到这一节acwing里面的视频长度比较长，所以我就分割出来作为单独的一个blog来写了。算法的思想比较重要。 离散化 题目acwing区间和说实话，离散化的概念不难理解但是实际运用起来，发现诶，用不来了 首先，什么是离散化？离散化一...","link":"","photos":[],"count_time":{"symbolsCount":"3k","symbolsTime":"3 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":39,"path":"api/tags/ACM.json"},{"name":"学习","slug":"学习","count":43,"path":"api/tags/学习.json"},{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"数据结构","slug":"数据结构","count":23,"path":"api/tags/数据结构.json"},{"name":"算法","slug":"算法","count":20,"path":"api/tags/算法.json"},{"name":"离散化","slug":"离散化","count":1,"path":"api/tags/离散化.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%A6%BB%E6%95%A3%E5%8C%96\"><span class=\"toc-text\">离散化</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%A6%96%E5%85%88%EF%BC%8C%E4%BB%80%E4%B9%88%E6%98%AF%E7%A6%BB%E6%95%A3%E5%8C%96%EF%BC%9F\"><span class=\"toc-text\">首先，什么是离散化？</span></a></li></ol>","author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"tech otakus save the world","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}},"mapped":true,"prev_post":{"title":"ACM学习笔记day7(区间合并，静态单链表，静态双向链表)","uid":"6626baeb85b77ff2abeecddea4b9b43b","slug":"ACM学习笔记day7","date":"2022-11-12T15:20:17.000Z","updated":"2023-04-08T10:49:14.216Z","comments":true,"path":"api/articles/ACM学习笔记day7.json","keywords":null,"cover":"/img/codeforces.jpg","text":"emm今天搞了点区间合并和静态链表。感觉静态链表的写法还是比较繁琐的。逻辑上感觉有点绕可能是我写习惯动态链表的原因吧（ 区间合并题目来源Acwing链接题目不难，贪心就能做。当时不讲，直接做出来了。不多赘述。 #include&lt;bits&#x2F;stdc++.h&gt; ...","link":"","photos":[],"count_time":{"symbolsCount":"4.3k","symbolsTime":"4 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":39,"path":"api/tags/ACM.json"},{"name":"学习","slug":"学习","count":43,"path":"api/tags/学习.json"},{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"数据结构","slug":"数据结构","count":23,"path":"api/tags/数据结构.json"},{"name":"算法","slug":"算法","count":20,"path":"api/tags/算法.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"tech otakus save the world","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}},"next_post":{"title":"ACM学习笔记day5(双指针，位运算)","uid":"ceed889808223c52789eb0c0c60367bf","slug":"ACM学习笔记day5","date":"2022-11-10T09:25:34.000Z","updated":"2023-04-08T10:48:56.517Z","comments":true,"path":"api/articles/ACM学习笔记day5.json","keywords":null,"cover":"/img/codeforces.jpg","text":"今天学习了一下双指针算法，感觉还是挺难的。就是一个由单调性可以推出应该用双指针这个有点不是很能理解。QAQ还有个位运算。 求最长无重复数字的子串问题 采用双指针的算法的话，我们让i从头到尾遍历数组，对于每一个i，j表示当前子串的左边界。如果在j到i这块子串有相同的数字，则让j++...","link":"","photos":[],"count_time":{"symbolsCount":"1.5k","symbolsTime":"1 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":39,"path":"api/tags/ACM.json"},{"name":"学习","slug":"学习","count":43,"path":"api/tags/学习.json"},{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"数据结构","slug":"数据结构","count":23,"path":"api/tags/数据结构.json"},{"name":"算法","slug":"算法","count":20,"path":"api/tags/算法.json"},{"name":"双指针","slug":"双指针","count":1,"path":"api/tags/双指针.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"tech otakus save the world","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}}}