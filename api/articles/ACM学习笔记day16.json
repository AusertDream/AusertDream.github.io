{"title":"ACM学习笔记day16(朴素dijkstra求最短路径)","uid":"569c66ff03a6fea9d4ceedb2c072fa60","slug":"ACM学习笔记day16","date":"2022-12-03T13:32:15.000Z","updated":"2023-04-08T10:51:15.100Z","comments":true,"path":"api/articles/ACM学习笔记day16.json","keywords":null,"cover":"/img/codeforces.jpg","content":"<p>Hello，guys！<br>今天我们学习的内容是dijkstra算法求最短路径,<a href=\"https://www.acwing.com/problem/content/851/\">题目</a><br>emm，第一次学这个的话，感觉还是比较抽象的，不过想了一段时间，稍微整理了一下思路，感觉也还可以<br>应该（</p>\n<span id=\"more\"></span>\n\n<h2 id=\"朴素Dijkstra\"><a href=\"#朴素Dijkstra\" class=\"headerlink\" title=\"朴素Dijkstra\"></a>朴素Dijkstra</h2><p>为什么叫朴素dijkstra呢？<br>因为目前这个dijkstra算法的时间复杂度是O(n^2)的<br>有一个堆优化的算法是是O(mlogn)的<br>朴素dijkstra是相对于堆优化而言的<br>在朴素dijkstra中，我们要清楚两个概念<br>一个是dist数组的意思<br>dist[i]的意义是第i个节点到源点的距离<br>另外一个就是我们把图中的节点分成了两个部分<br>一个部分是最短路劲已经确定好了的节点<br>另外一部分就是没有确定的节点<br>我们用一个cnt数组，或者st数组来表示这个状态<br>值为true即为最短路径已经确定了<br>反之没有<br>朴素dijkstra的算法思想是：<br>我们首先初始化cnt数组中的所有值为0<br>表示没有确定最短路径<br>然后初始化dist数组除了第一个节点之外的所有节点的值为INF<br>第一个节点的值为零<br>表示一开始的时候，其他节点到源点的距离都是无穷。<br>然后我们进行n次迭代，n是一共的节点数<br>每一次迭代中，我们选取没有确定最短路径的节点中dist值最小的那个，取名叫t，或者第一次进行这个操作的的话就选择第一个节点<br>然后我们去用这个节点去更新所有节点的dist值，取小的那个<br>怎么更新呢？<br>比如用j去遍历所有节点，dist[j]就等于dist[t]+t节点到j节点的距离和原来的值的取小的那个<br>每一次迭代之后，dist的值都会多多少少变化的<br>为什么要进行n次迭代呢？<br>因为我们每一次的迭代都会确定一个节点的最短路径，n次下来，每个节点的最短路径都确定了<br>问题也就解决了<br>但是这里也可以只迭代n-1次，省略掉的一次是终点节点的迭代<br>为什么可以省略终点节点的迭代呢？<br>因为当迭代到n-1次的时候，此时终点的最短路径其实已经被n-1个节点确定好了<br>因为我们每确定一个没确定最短路径的节点，就更新一遍所有节点的dist值<br>其实如果迭代第n次的时候，做的都是无效操作，因为无论如何，dist+g的值都会比之前的最短路径要大的<br>取min值不会取到的<br>对了，acwing上这题，因为有重边，所有输入的时候，重边需要取min的那个<br>下面为代码：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nconst int N &#x3D; 510;\nconst int INF &#x3D; 0x3f3f3f3f; &#x2F;&#x2F;用这个值代表无穷\nint dist[N],g[N][N];\nint n,m;\nbool cnt[N]; &#x2F;&#x2F;状态数组，表示每个节点是否已经确定最短路径\n\nint dijkstra()&#123;\n    &#x2F;&#x2F;初始化dist值，每个都是INF\n    for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;\n        dist[i]&#x3D;INF;\n    &#125;\n    dist[1]&#x3D;0; &#x2F;&#x2F;将第一个节点初始化为INF\n    &#x2F;&#x2F;然后进行n次迭代，n-1也可以\n    for(int i&#x3D;0;i&lt;n;i++)&#123;\n        int t&#x3D;-1; &#x2F;&#x2F;t表示未被确定最短路径的到源点最近的点，t为-1即为不存在\n        for(int j&#x3D;1;j&lt;&#x3D;n;j++)&#123; &#x2F;&#x2F;去n个节点中去寻找我们所需要的点\n            if(!cnt[j]&amp;&amp;(t&#x3D;&#x3D;-1||dist[t]&gt;dist[j]))&#123; &#x2F;&#x2F;如果没有确定，并且他的dist值比dist[j]大，或者他是-1的话就直接选择t&#x3D;1，即第一个节点\n                t&#x3D;j; &#x2F;&#x2F;t赋值j\n            &#125;\n        &#125;\n        cnt[t]&#x3D;1;&#x2F;&#x2F;把此时的节点标记为确定了最短路径\n        &#x2F;&#x2F;n次循环，去更新n个节点的dist值\n        for(int j&#x3D;1;j&lt;&#x3D;n;j++)&#123;\n            dist[j]&#x3D;min(dist[j],dist[t]+g[t][j]);\n            &#x2F;&#x2F;到第j个节点有两种方式\n            &#x2F;&#x2F;一种是已经有的距离，即dist[j]\n            &#x2F;&#x2F;还有一种就是经过当前这个t节点的方式，即dist[t]+g[t][j]（这个表示t到j节点的距离）\n        &#125;\n    &#125;\n    &#x2F;&#x2F;如果他的值为INF，说明不存在，则返回-1\n    if(dist[n]&#x3D;&#x3D;INF)&#123;\n        return -1;\n    &#125;\n    else&#123;\n        return dist[n];\n    &#125;\n&#125;\n\nint main()&#123;\n    cin&gt;&gt;n&gt;&gt;m;\n    &#x2F;&#x2F;初始化领接矩阵每一个值为INF\n    for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;\n        for(int j&#x3D;1;j&lt;&#x3D;n;j++)&#123;\n            g[i][j]&#x3D;INF;\n        &#125;\n    &#125;\n    while(m--)&#123;\n        int x,y,z;\n        cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;\n        g[x][y]&#x3D;min(g[x][y],z); &#x2F;&#x2F;存储给入的值\n    &#125;\n    int res&#x3D;dijkstra();\n    cout&lt;&lt;res&lt;&lt;endl;\n    return 0;\n&#125;</code></pre>\n<p>OK,guys.<br>今天的内容就那么多啦<br>虽然就一个算法，但是理解这个东西还是花费了我不少时间<br>感觉到现在为止还是有点懵懵懂懂的<br>还是需要一点时间去理解的吧<br>Bye~</p>\n","text":"Hello，guys！今天我们学习的内容是dijkstra算法求最短路径,题目emm，第一次学这个的话，感觉还是比较抽象的，不过想了一段时间，稍微整理了一下思路，感觉也还可以应该（ 朴素Dijkstra为什么叫朴素dijkstra呢？因为目前这个dijkstra算法的时间复杂度是...","link":"","photos":[],"count_time":{"symbolsCount":"2.8k","symbolsTime":"3 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":39,"path":"api/tags/ACM.json"},{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"学习","slug":"学习","count":43,"path":"api/tags/学习.json"},{"name":"算法","slug":"算法","count":20,"path":"api/tags/算法.json"},{"name":"数据结构","slug":"数据结构","count":23,"path":"api/tags/数据结构.json"},{"name":"蒟蒻","slug":"蒟蒻","count":4,"path":"api/tags/蒟蒻.json"},{"name":"dijkstra","slug":"dijkstra","count":1,"path":"api/tags/dijkstra.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%9C%B4%E7%B4%A0Dijkstra\"><span class=\"toc-text\">朴素Dijkstra</span></a></li></ol>","author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"tech otakus save the world","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}},"mapped":true,"prev_post":{"title":"ACM学习笔记day17(floyd算法求多源最短路)","uid":"633b5f64cd1a9eff1c65ad66ca026b45","slug":"ACM学习笔记day17","date":"2022-12-09T14:20:36.000Z","updated":"2023-04-08T10:51:22.699Z","comments":true,"path":"api/articles/ACM学习笔记day17.json","keywords":null,"cover":"/img/codeforces.jpg","text":"额，距离上次写ACM笔记好像已经过了很久了其实这是有原因(借口)的，在被模电折磨捏~好了，不多bb了今天学习的内容是Floyd算法求多源最短路。这个算法写起来东西很少，同时也比较简单，从整体上去理解的话，感觉还是不难理解的运用的思想就是DP的思想 直接上代码吧，思想是dp的思想，...","link":"","photos":[],"count_time":{"symbolsCount":"1.9k","symbolsTime":"2 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":39,"path":"api/tags/ACM.json"},{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"学习","slug":"学习","count":43,"path":"api/tags/学习.json"},{"name":"算法","slug":"算法","count":20,"path":"api/tags/算法.json"},{"name":"数据结构","slug":"数据结构","count":23,"path":"api/tags/数据结构.json"},{"name":"Floyd","slug":"Floyd","count":1,"path":"api/tags/Floyd.json"},{"name":"图论","slug":"图论","count":3,"path":"api/tags/图论.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"tech otakus save the world","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}},"next_post":{"title":"ACM学习笔记day15(哈希，字符串的哈希)","uid":"5358138299a8ff147d7f561517fe5a1d","slug":"ACM学习笔记day15","date":"2022-12-02T12:15:59.000Z","updated":"2023-04-08T10:51:06.595Z","comments":true,"path":"api/articles/ACM学习笔记day15.json","keywords":null,"cover":"/img/codeforces.jpg","text":"hello guys！今天的学习内容是哈希表，也就是散列表对应acwing上的模拟散列表和字符串哈希 那么问题来了什么是哈希表呢？一句话来总结就是，不保序的离散化离散化其实是哈希化的一种特殊情况我们将数据范围很大的，较少的数字，映射到一个比较小的数组，这就是哈希，不过中间的那个映...","link":"","photos":[],"count_time":{"symbolsCount":"4.8k","symbolsTime":"4 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":39,"path":"api/tags/ACM.json"},{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"学习","slug":"学习","count":43,"path":"api/tags/学习.json"},{"name":"算法","slug":"算法","count":20,"path":"api/tags/算法.json"},{"name":"数据结构","slug":"数据结构","count":23,"path":"api/tags/数据结构.json"},{"name":"笔记","slug":"笔记","count":3,"path":"api/tags/笔记.json"},{"name":"哈希表","slug":"哈希表","count":1,"path":"api/tags/哈希表.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"tech otakus save the world","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}}}