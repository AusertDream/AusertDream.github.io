{"title":"ACM学习笔记day8(模拟栈，表达式求值，模拟队列，单调栈)","uid":"0bde88ed9132d2dd0ee34fc3f801dfcc","slug":"ACM学习笔记day8","date":"2022-11-15T13:52:59.000Z","updated":"2023-04-08T10:49:21.906Z","comments":true,"path":"api/articles/ACM学习笔记day8.json","keywords":null,"cover":"/img/codeforces.jpg","content":"<p>wdnmd,受不了了，一拳把地球打爆。今天的内容原本应该是11月13号的<br>因为当晚是有个讲座要听，没空写博客想着明天写，结果昨天忙的要死，今天还是忙的要死<br>今天晚上终于稍微有点空了，赶紧把博客给补了，顺便也隔了几天复习一下东西。<br>今天主要学的是 模拟栈，表达式求值，模拟队列和单调栈。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"模拟栈\"><a href=\"#模拟栈\" class=\"headerlink\" title=\"模拟栈\"></a>模拟栈</h2><hr>\n<p>顾名思义<br>用数组的方式去模拟栈这个数据结构<br>当然你也可以直接用STL里面的stack类<br>个人觉得还是用stack类舒服点（<br>可能是还没到时候吧。<br>angway，稍微说一下模拟的方式<br>老规矩，有一个idx指针，用来标志栈顶元素。<br>注意这里idx指向的意思和模拟链表不太一样。<br>然后随便写几个函数，用来表示pop和push，top就可以了。<br>这个不难。</p>\n<h2 id=\"表达式求值\"><a href=\"#表达式求值\" class=\"headerlink\" title=\"表达式求值\"></a>表达式求值</h2><hr>\n<p>这个东西，我写过数据结构实验<br>直接略过。</p>\n<h2 id=\"模拟队列\"><a href=\"#模拟队列\" class=\"headerlink\" title=\"模拟队列\"></a>模拟队列</h2><hr>\n<p>模拟的方式和模拟栈差不多，用到了两个指针<br>hh 和tt，hh初始化为0，tt初始化为-1<br>每push一个数据，tt++；<br>每pop一个数据，就hh–；<br>front函数就直接访问第一个数据也就是hh指向的数据<br>pop的时候别忘了，检查一下hh是不是&gt;&#x3D;tt的就可以了，不然弹出了个寂寞<br><a href=\"https://www.acwing.com/problem/content/831/\">acwing题目连接</a><br>这里我附上源码好了。<br>这是我的写法</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">#include &lt;iostream&gt;\n#include&lt;stack&gt;\n#include&lt;queue&gt;\n#include&lt;algorithm&gt;\n#include&lt;string&gt;\n#include&lt;iomanip&gt;\nusing namespace std;\n#include&lt;math.h&gt;\nconst int N &#x3D; 100010;\nint myQueue[N], hh, tt &#x3D; -1;\n\nvoid push(int x) &#123;\n\tmyQueue[++tt] &#x3D; x;\n&#125;\n\nvoid pop() &#123;\n\thh++;\n&#125;\n\nint front() &#123;\n\treturn myQueue[hh];\n&#125;\nbool empty() &#123;\n\treturn hh &gt; tt;\n&#125;\nint main() &#123;\n\tint m;\n\tcin &gt;&gt; m;\n\twhile (m--) &#123;\n\t\tstring op;\n\t\tcin &gt;&gt; op;\n\t\tif (op &#x3D;&#x3D; &quot;push&quot;) &#123;\n\t\t\tint x;\n\t\t\tcin &gt;&gt; x;\n\t\t\tpush(x);\n\t\t&#125;\n\t\telse if (op &#x3D;&#x3D; &quot;pop&quot;) &#123;\n\t\t\tpop();\n\t\t&#125;\n\t\telse if (op &#x3D;&#x3D; &quot;query&quot;) &#123;\n\t\t\tcout &lt;&lt; front() &lt;&lt; endl;\n\t\t&#125;\n\t\telse if (op &#x3D;&#x3D; &quot;empty&quot;) &#123;\n\t\t\tif (empty()) &#123;\n\t\t\t\tcout &lt;&lt; &quot;YES&quot; &lt;&lt; endl;\n\t\t\t&#125;\n\t\t\telse &#123;\n\t\t\t\tcout &lt;&lt; &quot;NO&quot; &lt;&lt; endl;\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n\treturn 0;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"单调栈\"><a href=\"#单调栈\" class=\"headerlink\" title=\"单调栈\"></a>单调栈</h2><hr>\n<p>单调栈<br>说实话我感觉不像是一个数据结构<br>不如说这是一种算法思想<br>题目来源：<a href=\"https://www.acwing.com/problem/content/832/\">acwing链接</a><br>什么是单调栈捏<br>就是这个栈里面的元素，从栈低到栈顶的元素是升序排列的e.g<br>-—————————-<br>| 1 2 3 4 5 6 7  8 9 10<br>-—————————-<br>这就是就是单调栈<br>然后我们来看这道题目<br>给你一个长度为n的整数序列<br>输出每个数左边的第一个比他小的数<br>让我们思考一下暴力做法<br>i从头遍历到尾<br>然后j从i遍历到头，找到第一个比第i个小的，就break结束<br>毫无疑问，暴力做法的时间复杂度很高。<br>数据量一大就会TLE了<br>那我们来思考一下，这个算法究竟哪里时间复杂度高了<br>我们发现对于第i个数，第i-1个数如果比第i-2个数小的话，那其实<br>我们在找i-1个数前面比他小的数，这个第i-2个数已经比i-1来的大了，所以在后面要选到i-2也不可能，要选也要选i-1<br>综上，我们采用一个单调栈<br>对于第一个数据，前面都不可能有满足条件的，自然输出-1<br>然后把他存入stack中，然后对于第二个，和栈顶元素比较，如果栈顶元素比较大或者相等的，直接弹出<br>直到栈顶元素比它小了，才停止<br>然后输出栈顶元素<br>如此往复的进行<br>这样，栈中形成的数据关系，其实是单调递增的。<br>这也就是为什么成为单调栈的原因</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">#include &lt;iostream&gt;\n#include&lt;stack&gt;\n#include&lt;queue&gt;\n#include&lt;algorithm&gt;\n#include&lt;string&gt;\n#include&lt;iomanip&gt;\nusing namespace std;\n#include&lt;math.h&gt;\nconst int N &#x3D; 100010;\ntypedef pair&lt;int, int&gt; PII;\ntypedef long long ll;\n\n\n\nint main() &#123;\n\tint n;\n\tcin &gt;&gt; n;\n\tvector&lt;int&gt; a(n);\n\tstack&lt;int&gt; work;\n\tfor (int i &#x3D; 0; i &lt; n; i++) &#123;\n\t\tcin &gt;&gt; a[i];\n\t&#125;\n\twork.push(a[0]);\n\tcout &lt;&lt; -1 &lt;&lt; &#39; &#39;;\n\tfor (int i &#x3D; 1; i &lt; n; i++) &#123;\n\t\twhile (!work.empty() &amp;&amp; work.top() &gt;&#x3D; a[i]) &#123;\n\t\t\twork.pop();\n\t\t&#125;\n\t\tif (work.empty()) &#123;\n\t\t\tcout &lt;&lt; -1 &lt;&lt; &#39; &#39;;\n\t\t\twork.push(a[i]);\n\t\t&#125;\n\t\telse &#123;\n\t\t\tcout &lt;&lt; work.top() &lt;&lt; &#39; &#39;;\n\t\t\twork.push(a[i]);\n\t\t&#125;\n\t&#125;\n\treturn 0;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>that’s all<br>bye~</p>\n","text":"wdnmd,受不了了，一拳把地球打爆。今天的内容原本应该是11月13号的因为当晚是有个讲座要听，没空写博客想着明天写，结果昨天忙的要死，今天还是忙的要死今天晚上终于稍微有点空了，赶紧把博客给补了，顺便也隔了几天复习一下东西。今天主要学的是 模拟栈，表达式求值，模拟队列和单调栈。 ...","link":"","photos":[],"count_time":{"symbolsCount":"2.9k","symbolsTime":"3 mins."},"categories":[{"name":"ACM","slug":"ACM","count":40,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":37,"path":"api/tags/ACM.json"},{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"学习","slug":"学习","count":41,"path":"api/tags/学习.json"},{"name":"算法","slug":"算法","count":20,"path":"api/tags/算法.json"},{"name":"数据结构","slug":"数据结构","count":21,"path":"api/tags/数据结构.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%A8%A1%E6%8B%9F%E6%A0%88\"><span class=\"toc-text\">模拟栈</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC\"><span class=\"toc-text\">表达式求值</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%A8%A1%E6%8B%9F%E9%98%9F%E5%88%97\"><span class=\"toc-text\">模拟队列</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8D%95%E8%B0%83%E6%A0%88\"><span class=\"toc-text\">单调栈</span></a></li></ol>","author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"喜欢前沿科技，想要见证人类科学的飞跃","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}},"mapped":true,"prev_post":{"title":"ACM学习笔记day9(滑动窗口，双端队列)","uid":"958adf9461e6c3975304da3314c38d67","slug":"ACM学习笔记day9","date":"2022-11-17T13:07:42.000Z","updated":"2023-04-08T10:49:25.073Z","comments":true,"path":"api/articles/ACM学习笔记day9.json","keywords":null,"cover":"/img/codeforces.jpg","text":"今天学习的时间比较短，哦，确实也挺短的不过当时比较困，理解起来也很慢，所以今天的内容只有一个是滑动窗口和双端队列！ 滑动窗口什么是滑动窗口！就是单调队列的一道经典例题链接这里因为要用到了单调队列。我acwing上打卡用的是数组模拟双端队列的。而目前上面的题解是使用STL里面的双端...","link":"","photos":[],"count_time":{"symbolsCount":"2.4k","symbolsTime":"2 mins."},"categories":[{"name":"ACM","slug":"ACM","count":40,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":37,"path":"api/tags/ACM.json"},{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"学习","slug":"学习","count":41,"path":"api/tags/学习.json"},{"name":"算法","slug":"算法","count":20,"path":"api/tags/算法.json"},{"name":"数据结构","slug":"数据结构","count":21,"path":"api/tags/数据结构.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"喜欢前沿科技，想要见证人类科学的飞跃","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}},"next_post":{"title":"ACM学习笔记day7(区间合并，静态单链表，静态双向链表)","uid":"6626baeb85b77ff2abeecddea4b9b43b","slug":"ACM学习笔记day7","date":"2022-11-12T15:20:17.000Z","updated":"2023-04-08T10:49:14.216Z","comments":true,"path":"api/articles/ACM学习笔记day7.json","keywords":null,"cover":"/img/codeforces.jpg","text":"emm今天搞了点区间合并和静态链表。感觉静态链表的写法还是比较繁琐的。逻辑上感觉有点绕可能是我写习惯动态链表的原因吧（ 区间合并题目来源Acwing链接题目不难，贪心就能做。当时不讲，直接做出来了。不多赘述。 #include&lt;bits&#x2F;stdc++.h&gt; ...","link":"","photos":[],"count_time":{"symbolsCount":"4.3k","symbolsTime":"4 mins."},"categories":[{"name":"ACM","slug":"ACM","count":40,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":37,"path":"api/tags/ACM.json"},{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"学习","slug":"学习","count":41,"path":"api/tags/学习.json"},{"name":"算法","slug":"算法","count":20,"path":"api/tags/算法.json"},{"name":"数据结构","slug":"数据结构","count":21,"path":"api/tags/数据结构.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"喜欢前沿科技，想要见证人类科学的飞跃","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}}}