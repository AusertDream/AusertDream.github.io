{"title":"ACM学习笔记day38","uid":"cd2ad181ea0005062586c35121613745","slug":"ACM学习笔记day38","date":"2023-03-25T12:51:23.000Z","updated":"2023-04-09T11:44:43.682Z","comments":true,"path":"api/articles/ACM学习笔记day38.json","keywords":null,"cover":"/img/codeforces.jpg","content":"","text":"","link":"","photos":[],"count_time":{"symbolsCount":0,"symbolsTime":"1 mins."},"categories":[{"name":"ACM","slug":"ACM","count":38,"path":"api/categories/ACM.json"}],"tags":[],"toc":"","author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"喜欢前沿科技，想要见证人类科学的飞跃","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}},"mapped":true,"prev_post":{"title":"ACM小本本","uid":"4a9ea142753f2671aa4c5ecbc1f2c491","slug":"ACM小本本","date":"2022-11-09T12:43:41.000Z","updated":"2023-04-08T10:49:39.395Z","comments":true,"path":"api/articles/ACM小本本.json","keywords":null,"cover":"/img/codeforces.jpg","text":"这里是记录ACM知识点中一些零碎的东西，或者一些小的注意点啥的 1.使用二分模板的时候，当修改left值的时候，注意要让mid&#x3D;left+right+1&gt;&gt;1，不然会出现mid&#x3D;left然后死循环的出现2.快排和归并的本质就是分治，快排是先处理数据...","link":"","photos":[],"count_time":{"symbolsCount":"1.9k","symbolsTime":"2 mins."},"categories":[{"name":"ACM","slug":"ACM","count":38,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":36,"path":"api/tags/ACM.json"},{"name":"学习","slug":"学习","count":41,"path":"api/tags/学习.json"},{"name":"笔记本","slug":"笔记本","count":1,"path":"api/tags/笔记本.json"},{"name":"零碎的","slug":"零碎的","count":1,"path":"api/tags/零碎的.json"},{"name":"知识点","slug":"知识点","count":1,"path":"api/tags/知识点.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"喜欢前沿科技，想要见证人类科学的飞跃","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}},"feature":true},"next_post":{"title":"ACM学习笔记day36(树和图的DFS和BFS)","uid":"1429a762104f1c731f39acc20f00d741","slug":"ACM学习笔记day36","date":"2023-03-25T12:50:55.000Z","updated":"2023-04-08T10:54:15.019Z","comments":true,"path":"api/articles/ACM学习笔记day36.json","keywords":null,"cover":"/img/codeforces.jpg","text":"水一篇blog（树和图的bfs和dfs。 树和图的存储方式采用领接表或者是领接矩阵都可以。dfs和bfs的思路是一样的。bfs套用bfs的模板就可以了，定义一个工作队列。将没有访问过的领接点放入队列中，然后处理即可dfs就遍历他的所有领接点，然后如果没访问过的话就dfs下去。然后...","link":"","photos":[],"count_time":{"symbolsCount":"1.9k","symbolsTime":"2 mins."},"categories":[{"name":"ACM","slug":"ACM","count":38,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":36,"path":"api/tags/ACM.json"},{"name":"学习","slug":"学习","count":41,"path":"api/tags/学习.json"},{"name":"图论","slug":"图论","count":3,"path":"api/tags/图论.json"},{"name":"dfs","slug":"dfs","count":4,"path":"api/tags/dfs.json"},{"name":"bfs","slug":"bfs","count":3,"path":"api/tags/bfs.json"},{"name":"树","slug":"树","count":1,"path":"api/tags/树.json"},{"name":"图","slug":"图","count":1,"path":"api/tags/图.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"喜欢前沿科技，想要见证人类科学的飞跃","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}}}