{"title":"ACM学习笔记day38(最小生成树,染色法判定二分图，匈牙利算法)","uid":"aade77e076015616546b7ec40503f52f","slug":"ACM学习笔记day38","date":"2023-03-25T12:51:23.000Z","updated":"2023-08-27T09:15:36.952Z","comments":true,"path":"api/articles/ACM学习笔记day38.json","keywords":null,"cover":"/img/codeforces.jpg","content":"<p>在总结了各种的最短路算法之后，我们终于也是迎来了，图论基础算法的最后一部分内容。<br>一个是最小生成树的求法。<br>一个是有关二分图的问题。</p>\n<span id=\"more\"></span>\n\n<p>关于这部分的内容，可以看下面这个大致的思维导图。</p>\n<p><img src=\"/../img/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E5%92%8C%E4%BA%8C%E5%88%86%E5%9B%BE.png\" alt=\"12312\"></p>\n<h1 id=\"最小生成树\"><a href=\"#最小生成树\" class=\"headerlink\" title=\"最小生成树\"></a>最小生成树</h1><p>对于基础的图论。<br>最小生成树一共有两种算法。<br>一种是prim算法，一种就是kruskal算法。</p>\n<h2 id=\"Prim算法\"><a href=\"#Prim算法\" class=\"headerlink\" title=\"Prim算法\"></a>Prim算法</h2><p>Prim算法的思想就是，我们随便的选择一个点，作为我们的起始节点<br>然后我们去选择一条最短的以这个节点为一头的边。作为最小生成树的一条边。<br>然后我们选了这个节点和之前的起始节点，这部分节点所组成的一个集合，我们给他一个名字，就叫做连通块。<br>接下来我们重复这个过程，我们再去寻找一个节点，使的他到我们目前连通块的距离最短，然后将这个节点加入到我们的连通块中去。<br>如此往复，进行n次循环。我们就结束了这样的一个过程。<br>其实我们可以发现，我们每一次的循环，都可以确定一个节点<br>那么n次循环之后，我们就可以确定n个节点，那么也就相当于<br>最小生成树要求的n个节点的要求已经满足了。<br>这里有一个问题，我们怎么才能知道节点到目前连通块的距离。<br>这个其实很简单，我们使用dist数组来记录就行了，只不过我们每次在选完点的时候，需要用这个点去更新一下其他点到该连通块的距离。</p>\n<p>其实稍微理一下prim算法的思路的话，我们会发现，他的算法步骤其实和dijkstra很像。<br>都是n次循环，然后找一个距离最近的，然后用我们选出来的这个点，去更新所有的距离。<br>当然，prim算法这里的，这个dist表示的含义是，该节点到目前的这个连通块的距离<br>所以我们到时候去更新dist值的时候，要注意是直接取min值，而不是累加上去，不是求最短路！！！</p>\n<p>对了，最小生成树是有可能不存在的，什么时候不存在呢？<br>就是原来的图他不是连通图的时候，这样，最小生成树就一定是不存在的，毕竟没办法最小生成树他的基本要求。</p>\n<p>在程序里面就体现为什么呢？<br>就是我们枚举所有到连通块距离最近的点，发现他的距离是无穷，也就是不可达，这个时候说明剩下来的点，都是不可达目前的这个节点的<br>也就说明，他不是连通图，是不存在最小生成树的。</p>\n<p><a href=\"https://www.acwing.com/problem/content/860/\">题目链接</a></p>\n<p>算法的时间复杂度为O(n^2)</p>\n<p>ac code:</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nconst int N &#x3D; 510;\nint a[N][N];\nint n,m;\nint dist[N];\nbool st[N];\nint res;\n\nbool prim()&#123;\n    memset(dist,0x3f3f3f3f,sizeof dist);\n  \n    dist[1]&#x3D;0;\n    for(int i&#x3D;0;i&lt;n;i++)&#123;\n        int t&#x3D;-1;\n        for(int j&#x3D;1;j&lt;&#x3D;n;j++)&#123;\n            if(!st[j]&amp;&amp;(t&#x3D;&#x3D;-1||dist[j]&lt;dist[t]))&#123;\n                t&#x3D;j;\n            &#125;\n        &#125;\n        if(i&amp;&amp;dist[t]&#x3D;&#x3D;0x3f3f3f3f) return false; &#x2F;&#x2F;如果此时dist[t]的值为无穷，并且已经选了一个节点的情况下，说明不是连通图。\n        st[t]&#x3D;true;\n        if(i) res+&#x3D;dist[t];\n        for(int j&#x3D;1;j&lt;&#x3D;n;j++)&#123;\n            if(!st[j])&#123;\n                dist[j]&#x3D;min(dist[j],a[t][j]);\n            &#125;\n        &#125;\n    &#125;  \n  \n    return true;\n&#125;\n\nint main()&#123;\n    cin&gt;&gt;n&gt;&gt;m;\n    memset(a,0x3f3f3f3f,sizeof a);\n    while(m--)&#123;\n        int x,y,z;\n        cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;\n        a[x][y]&#x3D;min(a[x][y],z);\n        a[y][x]&#x3D;min(a[y][x],z);\n    &#125;\n    if(prim())&#123;\n        cout&lt;&lt;res&lt;&lt;endl;\n    &#125;\n    else&#123;\n        cout&lt;&lt;&quot;impossible&quot;&lt;&lt;endl;\n    &#125;\n  \n    return 0;\n&#125;</code></pre>\n\n<p>看到这里，或许你应该会有一个问题，如果说我们采用这种方法来生成最小生成树的话，<br>会不会产生环？<br>首先，可以肯定是，思考到这个问题，肯定是好的、<br>那么，答案肯定是显然的，不会产生环。<br>比如说我们要选出来一个三个点的，三条边的环。<br>但是我们这个算法，选择的过程是这样的，我们先选择一个点，然后选择一个距离这个连通块最近的点<br>然后重复这个过程，也就是说，我们对于这个三个点，实际上我们只会选到两条边，显然，两条边无论如何都不能形成环。<br>那么对于其他的情况也是类似的。<br>选不到环的原因就是，在我们快要选到环的时候，那最后一条可以让连通块中形成环的那条边是绝对选不到的。<br>因为那条边的两个顶点，已经被加入到连通块中了。<br>而连通块中的点，是不是被二次选中的。<br>那么因此，我们这个算法在运行的过程中，也是不会形成环的。</p>\n<h2 id=\"kruskal算法\"><a href=\"#kruskal算法\" class=\"headerlink\" title=\"kruskal算法\"></a>kruskal算法</h2><p>kruskal算法的思想就比较简单了。<br>我们对于图中的每一条边，每次去选择没有选过的，同时权值是最小的边，但是要确保我们选出来的边不能形成环。<br>这就是Kruskal算法，思想很简单。<br>是线上需要用点之前的内容。<br>我们每次要选择权值最小的边，这个很简单，我们可以使用堆，来快速的得出，或者直接对边排序即可。<br>那么如何确保我们选出来的边没有形成环呢？<br>这个我们可以通过并查集来判断。<br>我们定义，p[i]数组，其中p的值代表和当前i节点在一个连通块中的节点。<br>也就是说，一个连通块中的节点，他们是在一个并查集里面的，也就是p数组的值是相同的。<br>我们发现，其实我们要判断一条边的加入会不会形成环，其实就是判断，这条边的两个端点是不是在一个连通块内。<br>如果在一个连通块内，那么很显然，加入这条边，就会形成环。<br>如果不在一个连通块内，那么加入这条边一定不会形成环。<br>这个两句话还是要好好理解一下的。<br>好，那么至此我们的问题其实已经解决了。<br>就是存储所有的边，然后，取最小的边，作为树的边，注意不要产生环就是了。</p>\n<p><a href=\"https://www.acwing.com/problem/content/861/\">题目链接</a></p>\n<p>这个算法的时间复杂度为O(mlogm)<br>主要还是因为快排导致速度变慢的。</p>\n<p>ac code:</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nconst int N &#x3D; 2e5+10,M&#x3D;1e5+10;\nstruct Edge&#123;\n    int u,v,w;\n&#125; Edges[N];\nint n,m;\nint res;\nint p[M];\n\nbool cmp(Edge a,Edge b)&#123;\n    return a.w&lt;b.w;\n&#125;\n\nint find(int x)&#123;\n    if(p[x]!&#x3D;x)&#123;\n        int t&#x3D; find(p[x]);\n        p[x]&#x3D;t;\n    &#125;\n    return p[x];\n&#125;\n\nbool kruskal()&#123;\n    int cnt&#x3D;0;\n    for(int i&#x3D;0;i&lt;m;i++)&#123;\n        int a&#x3D;Edges[i].u,b&#x3D;Edges[i].v,c&#x3D;Edges[i].w;\n        if(find(a)&#x3D;&#x3D;find(b))&#123;\n            continue;\n        &#125;\n        else&#123;\n            cnt++;\n            res+&#x3D;c;\n            p[find(b)]&#x3D;find(a);\n        &#125;\n    &#125;\n    if(cnt&#x3D;&#x3D;n-1)&#123;\n        return true;\n    &#125;\n    else&#123;\n        return false;\n    &#125;\n&#125;\nint main()&#123;\n    cin&gt;&gt;n&gt;&gt;m;\n    for(int i&#x3D;0;i&lt;m;i++)&#123;\n        int u,v,w;\n        cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;\n        Edges[i]&#x3D;&#123;u,v,w&#125;;\n    &#125;\n    for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;\n        p[i]&#x3D;i;\n    &#125;\n    sort(Edges,Edges+m,cmp);\n    if(kruskal())&#123;\n        cout&lt;&lt;res&lt;&lt;endl;\n    &#125;\n    else&#123;\n        cout&lt;&lt;&quot;impossible&quot;&lt;&lt;endl;\n    &#125;\n  \n    return 0;\n&#125;</code></pre>\n\n<h1 id=\"二分图问题\"><a href=\"#二分图问题\" class=\"headerlink\" title=\"二分图问题\"></a>二分图问题</h1><p>我们首先需要知道什么是二分图。</p>\n<p>一个图是二分图<br>当且仅当<br>这个图的点集可以划分为两个集合，使的对于图中的每一条边，两个端点分别处在这两个集合中，而不是在一个集合中。<br>这样的图，就成为二分图。</p>\n<h2 id=\"染色法判定二分图\"><a href=\"#染色法判定二分图\" class=\"headerlink\" title=\"染色法判定二分图\"></a>染色法判定二分图</h2><p>我们从定义出发，我们发现<br>每一条边，两个端点都是处于不同的集合中的。<br>而且这个集合，只有两个。<br>染色法的思想就是，我们不妨设一个集合的颜色会红色，一个集合的颜色为蓝色。<br>然后我们去对节点染色，因为要满足二分图的条件，所以任意的一条边<br>两个端点的颜色必须是一个是红色一个是蓝色。<br>那么对于这个涂色的过程，我们可以使用dfs也可以使用bfs来进行。<br>如果我们顺利的完成了涂色的过程，那么这个图就是第一个二分图。<br>如果在涂色中，发现有一条边的两个节点是同一个颜色的话，就说明他不是二分图。</p>\n<p><a href=\"https://www.acwing.com/problem/content/862/\">题目链接</a></p>\n<p>这个算法的时间复杂度为O(n+m)</p>\n<p>bfs 做法：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nconst int N &#x3D; 1e5+10,M&#x3D;2e5+10;\nint h[N],e[M],ne[M],idx;\nint color[N];\nint n,m;\n\nvoid add(int a,int b)&#123;\n    e[idx]&#x3D;b,ne[idx]&#x3D;h[a],h[a]&#x3D;idx++;\n&#125;\n\nbool bfs()&#123;\n  \n    for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;\n        if(!color[i])&#123;\n            color[i]&#x3D;1;\n            queue&lt;int&gt; work;\n            work.push(i);\n            while(work.size())&#123;\n                int t&#x3D; work.front();\n                work.pop();\n                for(int j&#x3D;h[t];j!&#x3D;-1;j&#x3D;ne[j])&#123;\n                    int k&#x3D;e[j];\n                    if(!color[k])&#123;\n                        color[k]&#x3D;3-color[t];\n                        work.push(k);\n                    &#125;\n                    else if(color[k]&#x3D;&#x3D;color[t])&#123;\n                        return false;   \n                    &#125;\n                &#125;\n            &#125;\n        &#125;  \n    &#125;\n    return true;\n&#125;\n\nint main()&#123;\n    cin&gt;&gt;n&gt;&gt;m;\n    memset(h,-1,sizeof h);\n    for(int i&#x3D;0;i&lt;m;i++)&#123;\n        int a,b;\n        cin&gt;&gt;a&gt;&gt;b;\n        add(a,b),add(b,a);\n    &#125;\n    if(bfs())&#123;\n        cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl;\n    &#125;\n    else&#123;\n        cout&lt;&lt;&quot;No&quot;&lt;&lt;endl;\n    &#125;\n    return 0;\n&#125;</code></pre>\n\n<p>dfs传递的第一个参数节点，第二个参数是该节点应该被涂成什么颜色<br>dfs做法：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nconst int N &#x3D; 1e5+10,M&#x3D;2e5+10;\nint h[N],e[M],ne[M],idx;\nint color[N];\nint n,m;\n\nvoid add(int a,int b)&#123;\n    e[idx]&#x3D;b,ne[idx]&#x3D;h[a],h[a]&#x3D;idx++;\n&#125;\n\nbool dfs(int u,int c)&#123;\n    color[u]&#x3D;c;\n    for(int i&#x3D;h[u];i!&#x3D;-1;i&#x3D;ne[i])&#123;\n        int j&#x3D;e[i];\n        if(!color[j])&#123;\n            if(!dfs(j,3-c)) return false;\n        &#125;\n        else if(color[j]&#x3D;&#x3D;color[u])&#123;\n            return false;\n        &#125;\n    &#125;\n  \n    return true;\n&#125;\n\nint main()&#123;\n    cin&gt;&gt;n&gt;&gt;m;\n    memset(h,-1,sizeof h);\n    for(int i&#x3D;0;i&lt;m;i++)&#123;\n        int a,b;\n        cin&gt;&gt;a&gt;&gt;b;\n        add(a,b),add(b,a);\n    &#125;\n    bool res&#x3D;true;\n    for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;\n        if(!color[i])&#123;\n            if(!dfs(i,1))&#123;\n                res&#x3D;false;\n            &#125;\n        &#125;\n    &#125;\n    if(res) cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl;\n    else cout&lt;&lt;&quot;No&quot;&lt;&lt;endl;\n    return 0;\n&#125;</code></pre>\n\n<h2 id=\"二分图的最大匹配\"><a href=\"#二分图的最大匹配\" class=\"headerlink\" title=\"二分图的最大匹配\"></a>二分图的最大匹配</h2><p>在进行这一节之前，我们需要先知道两个概念<br>二分图的匹配和二分图的最大匹配。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>二分图的匹配：给定一个二分图 G，在 G的一个子图 M中，M的边集{E}中的任意两条边都不依附于同一个顶点，则称M是一个匹配。<br>二分图的最大匹配：所有匹配中包含边数最多的一组匹配被称为二分图的最大匹配，其边数即为最大匹配数。</p></blockquote>\n<p>对于二分图的最大匹配问题，我们采用的算法就是匈牙利算法。</p>\n<p><a href=\"https://www.acwing.com/problem/content/863/\">题目链接</a></p>\n<p>先看一下题目。<br>我们这里为了方便理解。<br>采用一个纳西妲般的比喻来看待这道题。<br>给定一个二分图，分为左右两半部分。<br>我们将这个左右两半部分理解为，左边的是男生，右边的是女生。<br>我们将两个节点之间的连线理解为男生和女生有暗恋关系。<br>然后我们就是那个月老，我们要去牵线。<br>但是恋爱要忠诚对吧，任何一个人都不能脚踏多只船。<br>也就是我们这里二分图的匹配的要求。<br>那么我们应该怎么连线，来使的情侣数最多。<br>其实，我们可以这么看。<br>我们只看左边男生的。（当然也可以只看女生的，一样的）<br>我们遍历过去男生的，看他有没有和谁有暗恋关系，如果有的话，我们就牵线。<br>如果发现对面那个女生已经被前面的某人给拐走了。<br>一般的想法可能是放弃对吧，但是这样的话这题就会造成错解了<br>而这也是匈牙利算法的优越性。<br>如果说我们当前这个男生所有和他有暗恋关系的女生都被占用了<br>那我们尝试去看看占用那个女生的男生是谁，看看能不能够让他换一个女生。<br>如果可以的话，那我们这个男生也算是可以成对了对吧，对于我们的答案来讲，就是使的我们的匹配数更大了。<br>对于所有的男生，都是执行这个过程。<br>最终结果输出就可以了。<br>这就是匈牙利算法。<br>为什么可以只考虑一边呢？<br>因为最大匹配数就是min(n1,n2)<br>而且左右两边是连接的，所以看左边了，其实也就是看右边了。</p>\n<p>这个算法的时间复杂度为O(n*m)，但实际上达不到n*m</p>\n<p>ac code:</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nconst int N &#x3D; 510,M &#x3D; 1e5+10;\nint h[N],e[M],ne[M],idx;\nint match[N];\nbool st[N]; &#x2F;&#x2F;st数组表示该女生是否被占用或者预定\nint n1,n2,m;\nint res;\n\nvoid add(int a,int b)&#123;\n    e[idx]&#x3D;b,ne[idx]&#x3D;h[a],h[a]&#x3D;idx++;\n&#125;\n\nbool find(int x)&#123;\n  \n    for(int i&#x3D;h[x];i!&#x3D;-1;i&#x3D;ne[i])&#123;\n        int j&#x3D;e[i];\n        if(!st[j])&#123;  &#x2F;&#x2F;如果这个女生没有被预定\n            st[j]&#x3D;true;\n            if(match[j]&#x3D;&#x3D;0||find(match[j]))&#123; &#x2F;&#x2F;只有这个女生没有男朋友，或者是他的男朋友可以选择其他人的时候，才是true值，也就是当前这个人是可以找这个女生的\n                match[j]&#x3D;x;\n                return true;\n            &#125;\n        &#125;\n    &#125;\n    return false;\n&#125;\n\nint main()&#123;\n    cin&gt;&gt;n1&gt;&gt;n2&gt;&gt;m;\n    memset(h,-1,sizeof h);\n    while(m--)&#123;\n        int u,v;\n        cin&gt;&gt;u&gt;&gt;v;\n        add(u,v);\n    &#125;  \n    for(int i&#x3D;1;i&lt;&#x3D;n1;i++)&#123;\n        memset(st,false,sizeof st); &#x2F;&#x2F;这里每次find前，都要初始化st数组一次为false，因为每次判断都是独立的。\n        if(find(i))&#123;\n            res++;\n        &#125;\n    &#125;  \n    cout&lt;&lt;res&lt;&lt;endl;\n    return 0;\n&#125;</code></pre>\n\n<p>好了，至此为止，算法基础课的内容图论部分也已经结束了。<br>那么到现在，2023.4.15，终于我将算法基础课的内容都整理好了笔记一遍。<br>除了博弈论中的SG函数内容，那个真听不懂，之后再回来补吧。<br>接下来就是提高课的内容。<br>也是要开始大规模刷题的时候了。<br>提高课可不会像这样一门课一门课的做笔记了。<br>除非在高级数据结构里面会做一下笔记，其他的就是纯刷题了。<br>好了，那么再见了！<br>我们高级数据结构里面再见！<br>Bye!~~~</p>\n","text":"在总结了各种的最短路算法之后，我们终于也是迎来了，图论基础算法的最后一部分内容。一个是最小生成树的求法。一个是有关二分图的问题。 关于这部分的内容，可以看下面这个大致的思维导图。 最小生成树对于基础的图论。最小生成树一共有两种算法。一种是prim算法，一种就是kruskal算法。...","link":"","photos":[],"count_time":{"symbolsCount":"9.4k","symbolsTime":"9 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":39,"path":"api/tags/ACM.json"},{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"Prim","slug":"Prim","count":1,"path":"api/tags/Prim.json"},{"name":"Kruskal","slug":"Kruskal","count":1,"path":"api/tags/Kruskal.json"},{"name":"染色法","slug":"染色法","count":1,"path":"api/tags/染色法.json"},{"name":"二分图","slug":"二分图","count":1,"path":"api/tags/二分图.json"},{"name":"匈牙利算法","slug":"匈牙利算法","count":1,"path":"api/tags/匈牙利算法.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91\"><span class=\"toc-text\">最小生成树</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Prim%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">Prim算法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#kruskal%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">kruskal算法</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E5%88%86%E5%9B%BE%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">二分图问题</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%9F%93%E8%89%B2%E6%B3%95%E5%88%A4%E5%AE%9A%E4%BA%8C%E5%88%86%E5%9B%BE\"><span class=\"toc-text\">染色法判定二分图</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E5%88%86%E5%9B%BE%E7%9A%84%E6%9C%80%E5%A4%A7%E5%8C%B9%E9%85%8D\"><span class=\"toc-text\">二分图的最大匹配</span></a></li></ol></li></ol>","author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"tech otakus save the world","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}},"mapped":true,"prev_post":{"title":"ACM学习笔记day39(树状数组)","uid":"7710f88b0aefcb65b0ee353b8ff291a3","slug":"ACM学习笔记day39","date":"2023-07-18T14:56:43.000Z","updated":"2023-08-27T09:15:47.333Z","comments":true,"path":"api/articles/ACM学习笔记day39.json","keywords":null,"cover":"/img/codeforces.jpg","text":"树状数组的板子。 有几个小结论需要记住。 每个结点t[x]保存以x为根的子树中叶结点值的和 每个结点覆盖的长度为lowbit(x) t[x]结点的父结点为t[x + lowbit(x)] 树的深度为log2n+1 理解树状数组的图为: lowbit操作： int lowbit(i...","link":"","photos":[],"count_time":{"symbolsCount":543,"symbolsTime":"1 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"数据结构","slug":"数据结构","count":23,"path":"api/tags/数据结构.json"},{"name":"binary index tree","slug":"binary-index-tree","count":1,"path":"api/tags/binary-index-tree.json"},{"name":"树状数组","slug":"树状数组","count":1,"path":"api/tags/树状数组.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"tech otakus save the world","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}},"next_post":{"title":"ACM学习笔记day37 (最短路算法总结)","uid":"d62cd488fd25981616571e6226f3871a","slug":"ACM学习笔记day37","date":"2023-03-25T12:51:16.000Z","updated":"2024-12-29T14:18:21.976Z","comments":true,"path":"api/articles/ACM学习笔记day37.json","keywords":null,"cover":"/img/codeforces.jpg","text":"好，我们这一节对最短路算法作一个总结。总的来说基础的最短路算法有四种。分别为 Dijksta,bellman-ford，spfa，floyd算法。不同的算法应对的是不同的情况。 什么算法解决什么问题，可以看下面这张图。 我们最短路问题，可以分为两大类问题，一类是单源最短路，也就是...","link":"","photos":[],"count_time":{"symbolsCount":"8.9k","symbolsTime":"8 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":39,"path":"api/tags/ACM.json"},{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"学习","slug":"学习","count":43,"path":"api/tags/学习.json"},{"name":"最短路问题","slug":"最短路问题","count":1,"path":"api/tags/最短路问题.json"},{"name":"Dijkstra","slug":"Dijkstra","count":1,"path":"api/tags/Dijkstra.json"},{"name":"Bellman-ford","slug":"Bellman-ford","count":1,"path":"api/tags/Bellman-ford.json"},{"name":"spfa","slug":"spfa","count":1,"path":"api/tags/spfa.json"},{"name":"floyd","slug":"floyd","count":1,"path":"api/tags/floyd.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"tech otakus save the world","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}},"feature":false}}