{"title":"ACM学习笔记day36(树和图的DFS和BFS)","uid":"1429a762104f1c731f39acc20f00d741","slug":"ACM学习笔记day36","date":"2023-03-25T12:50:55.000Z","updated":"2023-04-08T10:54:15.019Z","comments":true,"path":"api/articles/ACM学习笔记day36.json","keywords":null,"cover":"/img/codeforces.jpg","content":"<p>水一篇blog（<br>树和图的bfs和dfs。</p>\n<span id=\"more\"></span>\n\n<p>树和图的存储方式采用领接表或者是领接矩阵都可以。<br>dfs和bfs的思路是一样的。<br>bfs套用bfs的模板就可以了，定义一个工作队列。将没有访问过的领接点放入队列中，然后处理即可<br>dfs就遍历他的所有领接点，然后如果没访问过的话就dfs下去。<br>然后进行处理。<br>当然这两个方法都要定义一个st数组来表示这个节点是否被访问过。</p>\n<p>树和图的dfs和bfs就是这样。</p>\n<p>然后要讲一个特别的东西，就是树的重心。<br>重心定义：重心是指树中的一个结点，如果将这个点删除后，剩余各个连通块中点数的最大值最小，那么这个节点被称为树的重心。<br>树的重心表示了这样的一个节点。<br>就是某个节点将其删除之后，他说产生的子连通图要尽可能的支离破碎的，也就是各个子连通块中 点数的最大值最小。</p>\n<p><a href=\"https://www.acwing.com/problem/content/848/\">题目连接</a></p>\n<p>那么我们怎么求树的重心呢？<br>我们根据定义来入手，将一个点删除之后剩余各个连通块中点数的最大值最小的。<br>我们可以枚举所有的点，然后一个一个的去算他的各个连通块中点数的最大值<br>那么我们需要算哪些部分的呢？<br>首先不难发现，我们去掉了一个点之后。<br>很显然他的父节点所连接的子图，除了被删掉的那个点都是在一个连通块内的。<br>那么产生的子连通图就主要在被删除的点的孩子子节点连接的子树中。<br>那么我们只需要递归的去求各个子连通图的点数，要用来算一个总和，然后还要取其中最大的<br>那么他的父节点所在的连通子图就等于总的节点数n减去我们之前算的那个总和。然后再在取个最大的。<br>就是目前来说删掉这个节点，剩余各个连通块中点数的最大值<br>然后用这个去更新ans，ans取最小。<br>最终结果就是ans了。</p>\n<p>当然真暴力枚举，肯定是不行的，那样的话会有很多重复算的。<br>所以我们这里用到了dfs，并且其实是有一点树形DP的思想在里面的。<br>我们在dfs的时候，每次dfs到一个节点，我们就假设删掉这个节点，然后去dfs他的领接节点，求出他的孩子和孙子节点有多少个，然后子连通块中数量最大的是多少<br>求完之后去更新ans。<br>dfs返回的是以当前节点为根节点的子树的节点数。</p>\n<p>code如下:</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nconst int N &#x3D; 2e5+10;\nint h[N],e[N],ne[N],idx;\nbool st[N];\nint n;\nint ans&#x3D;N;\nvoid add(int a,int b)&#123;\n    e[idx]&#x3D;b,ne[idx]&#x3D;h[a],h[a]&#x3D;idx++;\n&#125;\n\nint dfs(int u)&#123;\n    st[u]&#x3D;true;\n    \n    int sum&#x3D;1,res&#x3D;0;\n    for(int i&#x3D;h[u];i!&#x3D;-1;i&#x3D;ne[i])&#123;\n        int j&#x3D;e[i];\n        if(!st[j])&#123;\n            int t &#x3D; dfs(j);\n            res&#x3D;max(res,t);\n            sum+&#x3D;t;\n        &#125;\n    &#125;\n    res&#x3D;max(res,n-sum);\n    ans&#x3D;min(ans,res);\n    return sum;\n&#125;\nint main()&#123;\n    \n    cin&gt;&gt;n;\n    memset(h,-1,sizeof h);\n    for(int i&#x3D;0;i&lt;n-1;i++)&#123;\n        int a,b;\n        cin&gt;&gt;a&gt;&gt;b;\n        add(a,b),add(b,a);\n    &#125;\n    \n    dfs(1);\n    \n    cout&lt;&lt;ans&lt;&lt;endl;\n    \n    return 0;\n&#125;</code></pre>\n\n\n<p>关于图的bfs，在边上的权值都是1的时候，我们求最短路其实是可以用bfs的，而且这样的时间复杂度是很低的，因为就扫一遍图嘛<br>为什么可以用bfs求最短路呢？<br>很简单<br>因为bfs是一层一层来求的，如果bfs先扫到了终点，那么显然这一定是最短的距离。<br>直接break输出结果就可以了。</p>\n<p>That’s all;</p>\n","text":"水一篇blog（树和图的bfs和dfs。 树和图的存储方式采用领接表或者是领接矩阵都可以。dfs和bfs的思路是一样的。bfs套用bfs的模板就可以了，定义一个工作队列。将没有访问过的领接点放入队列中，然后处理即可dfs就遍历他的所有领接点，然后如果没访问过的话就dfs下去。然后...","link":"","photos":[],"count_time":{"symbolsCount":"1.9k","symbolsTime":"2 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":39,"path":"api/tags/ACM.json"},{"name":"学习","slug":"学习","count":43,"path":"api/tags/学习.json"},{"name":"图论","slug":"图论","count":3,"path":"api/tags/图论.json"},{"name":"bfs","slug":"bfs","count":3,"path":"api/tags/bfs.json"},{"name":"dfs","slug":"dfs","count":4,"path":"api/tags/dfs.json"},{"name":"树","slug":"树","count":1,"path":"api/tags/树.json"},{"name":"图","slug":"图","count":1,"path":"api/tags/图.json"}],"toc":"","author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"tech otakus save the world","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}},"mapped":true,"prev_post":{"title":"ACM学习笔记day37 (最短路算法总结)","uid":"d62cd488fd25981616571e6226f3871a","slug":"ACM学习笔记day37","date":"2023-03-25T12:51:16.000Z","updated":"2024-12-29T14:18:21.976Z","comments":true,"path":"api/articles/ACM学习笔记day37.json","keywords":null,"cover":"/img/codeforces.jpg","text":"好，我们这一节对最短路算法作一个总结。总的来说基础的最短路算法有四种。分别为 Dijksta,bellman-ford，spfa，floyd算法。不同的算法应对的是不同的情况。 什么算法解决什么问题，可以看下面这张图。 我们最短路问题，可以分为两大类问题，一类是单源最短路，也就是...","link":"","photos":[],"count_time":{"symbolsCount":"8.9k","symbolsTime":"8 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":39,"path":"api/tags/ACM.json"},{"name":"学习","slug":"学习","count":43,"path":"api/tags/学习.json"},{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"最短路问题","slug":"最短路问题","count":1,"path":"api/tags/最短路问题.json"},{"name":"Dijkstra","slug":"Dijkstra","count":1,"path":"api/tags/Dijkstra.json"},{"name":"Bellman-ford","slug":"Bellman-ford","count":1,"path":"api/tags/Bellman-ford.json"},{"name":"spfa","slug":"spfa","count":1,"path":"api/tags/spfa.json"},{"name":"floyd","slug":"floyd","count":1,"path":"api/tags/floyd.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"tech otakus save the world","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}},"feature":false},"next_post":{"title":"ACM学习笔记day35(拓扑序列)","uid":"f4b8c236f24c3289ca5c3e33420c6ba4","slug":"ACM学习笔记day35","date":"2023-03-21T14:49:38.000Z","updated":"2023-04-08T10:54:07.183Z","comments":true,"path":"api/articles/ACM学习笔记day35.json","keywords":null,"cover":"/img/codeforces.jpg","text":"今天的内容是拓扑排序。 若一个由图中所有点构成的序列A满足：对于图中的每条边 (x,y) x 在 A 中都出现在 y 之前，则称 A 是该图的一个拓扑序列。注意：图的拓扑序并不一定唯一所以题目的答案并不唯一。 那么我们应该怎么去求拓扑序列呢？很显然，我们从定义出发，我们需要保证序...","link":"","photos":[],"count_time":{"symbolsCount":"1.8k","symbolsTime":"2 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":39,"path":"api/tags/ACM.json"},{"name":"学习","slug":"学习","count":43,"path":"api/tags/学习.json"},{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"图论","slug":"图论","count":3,"path":"api/tags/图论.json"},{"name":"bfs","slug":"bfs","count":3,"path":"api/tags/bfs.json"},{"name":"dfs","slug":"dfs","count":4,"path":"api/tags/dfs.json"},{"name":"拓扑排序","slug":"拓扑排序","count":1,"path":"api/tags/拓扑排序.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"tech otakus save the world","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}}}