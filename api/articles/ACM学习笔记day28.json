{"title":"ACM学习笔记day28 (组合数的应用——满足条件的01序列，容斥原理)","uid":"cd92aa8f26118d15f6c9920aff860d6f","slug":"ACM学习笔记day28","date":"2023-02-07T09:31:39.000Z","updated":"2023-04-08T10:52:45.948Z","comments":true,"path":"api/articles/ACM学习笔记day28.json","keywords":null,"cover":"/img/codeforces.jpg","content":"<p>今天的内容是组合数的应用——满足条件的01序列和容斥原理。<br>关于这个满足条件的01序列，其实涉及到了一个特殊的数字卡特兰数。<br>这个我们等会会讲这个。</p>\n<span id=\"more\"></span>\n\n\n<h1 id=\"满足条件的01序列\"><a href=\"#满足条件的01序列\" class=\"headerlink\" title=\"满足条件的01序列\"></a><a href=\"https://www.acwing.com/problem/content/891/\">满足条件的01序列</a></h1><p>题目意思就是给你n个0，n个1，让你排出来一个序列，使得对于任意的前缀，0的数量是大于等于1的数量的。<br>问你这样的序列有多少个？<br>对于这个问题，我们要进行转化。<br>接下里，我们给出一个例子来进行讲解，怎么转化。<br>比如给你6个0,6个1。<br>我们在平面直角坐标系中从(0,0)开始走到(6,6)。<br>按照方格子来走的。<br>我们规定0是向右走一格，1是向上走一格。<br>那么任意一条(0,0)-&gt;(6,6)的路径都可以用01序列来表示。<br>也就是说，题目要求我们的序列，就转化为了图上的一条路径。</p>\n<p><img src=\"https://raw.githubusercontent.com/AusertDream/MyblogImags/main/photo1.png\" alt=\"1\"></p>\n<p>比如一条路径是000000111111<br>就是如下所示：</p>\n<p><img src=\"https://raw.githubusercontent.com/AusertDream/MyblogImags/main/photo11.png\" alt=\"11\"></p>\n<p>因为题目中要求任意一段前缀中，0的个数必须大于等于1的个数。<br>也就是说在图中，我们走过的每一段路，向右的步数要大于向上的步数。<br>也就是说我们的每一段路要在副对角线下方，当然擦边是可以的。这个时候正好相等呗。</p>\n<p><img src=\"https://raw.githubusercontent.com/AusertDream/MyblogImags/main/photo2.png\" alt=\"2\"></p>\n<p>好，接下来我们看图中，如果一条从(0,0)到(6,6)的路径越过了绿线，那他就是一条非法路径，也就是不满足条件的序列。<br>反之就是合法的路径。<br>那么总的路径是多少条？<br>很显然，相当于12个格子，里面填6个1，6个0，C[12][6]条路径。<br>总共是这么多的路径。那么我们要求合法路径，不就等于总的路径-非法路径吗？<br>接下来。<br>我们取任何一条非法路径来看一下。</p>\n<p><img src=\"https://raw.githubusercontent.com/AusertDream/MyblogImags/main/2023%E5%B9%B42%E6%9C%887%E6%97%A5.png\" alt=\"ads\"></p>\n<p>那根红线代表的就是非法线，如果路径碰到了红线就非法了。<br>橙色的一条线为任意的一条非法路径。<br>我们将这条路径第一次碰到红线往后的部分，按照绿线进行轴对称过去。</p>\n<p><img src=\"https://raw.githubusercontent.com/AusertDream/MyblogImags/main/%E5%9B%BE.png\" alt=\"2222\"></p>\n<p>后半部分就变成了这里的这根绿色粗线。<br>他最终到达的地方是(5,7)。<br>这里我们发现任何一条非法路径轴对称过去一定是对应一条到(5,7)的路径的。<br>那么反过来，任何一条到(5,7)的路径一定是对应一条非法路径的。<br>那么其实，我们要求有多少非法路径，也就是求到(5,7)的路径有多少条。<br>而这个很好求，就是12个格子里面选5个位置来放0其他是1，自然就是C[12][5];<br>那么对于(6,6)这种情况，结果就是C[12][6]-C[12][5]。<br>那么对于任意的n，结果就是C[2<em>n][n]-C[2</em>n][n-1]。<br>化简一下就是C[2*n][n]&#x2F;(n+1)。<br>而这个东西就是<code>卡特兰数</code>。<br>很多方案类的问题的结果都是卡特兰数。</p>\n<p>下面是 ac code：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">#include&lt;bits&#x2F;stdc++.h&gt;\nusing  namespace std;\ntypedef long long ll;\nconst int mod &#x3D; 1e9+7;\n\nll qmi(ll a,ll k,ll p)&#123;\n    ll res&#x3D;1;\n    while(k)&#123;\n        if(k&amp;1)&#123;\n            res&#x3D;res*a%p;\n        &#125;\n        a&#x3D;a*a%p;\n        k&gt;&gt;&#x3D;1;\n    &#125;\n    return res;\n&#125;\nll C(ll a,ll b,ll p)&#123;\n    ll res&#x3D;1;\n    for(int i&#x3D;1,j&#x3D;a;i&lt;&#x3D;b;i++,j--)&#123;\n        res&#x3D;res*j%mod;\n        res&#x3D;res*qmi(i,mod-2,mod)%mod;\n    &#125;\n    return res;\n&#125;\nint main()&#123;\n    int n;\n    cin&gt;&gt;n;\n    cout&lt;&lt;C(2*n,n,mod)*qmi(n+1,mod-2,mod)%mod&lt;&lt;endl;\n    return 0;\n&#125;</code></pre>\n\n<h1 id=\"能被整除的数\"><a href=\"#能被整除的数\" class=\"headerlink\" title=\"能被整除的数\"></a><a href=\"https://www.acwing.com/problem/content/892/\">能被整除的数</a></h1><p>这个题是容斥原理的一个体现。<br>容斥原理是啥这里不多说了。<br>也是离散的基础内容。<br>对于这题来说，要求1<del>n中能被给的质数中任意一个数字整除的个数。<br>也就是说：<br>1</del>n中能被p1,p2,p3整除的加起来，再减掉能被p1*p2,p1*p3,p1*p4,…..pn-1*pn整除的，再加上<br>能被p1*p2<em>p3,p1*p2*p4…..等等整除的。后面的依次类推。<br>按照上述规律进行求解即可。<br>注意这里因为我们要模拟一下这个过程，所以时间复杂度会根据质数的个数m呈指数级的往上涨。为什么呢？<br>对于这么多pi的任意项乘积，我们可以使用dfs来做，每一位都dfs过去就可以了。我们也可以用位运算来看。<br>每个数字都有取或者不取的两种状态，那么每一个pi任意项的乘积我们就可以表示为一个01序列<br>而这个序列可以视作二进制数字从而转化为二进制数字。<br>从而总的数字数量为1&lt;&lt;m。<br>我们对于每一个枚举过去的i，进行二进制拆解，而这个拆解的最大长度就是m，质数的个数。<br>所以时间复杂度是O(m</em>2^m)。<br>这题数据的是正好算好的，是不会超时的。<br>哦对了，对于1~n中能被p整除的数字的数量就是n&#x2F;p。<br>这个稍微自己想一下就可以了，不难理解的。</p>\n<p>下面为ac code:</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\n\nint main()&#123;\n    ll n,m;\n    cin&gt;&gt;n&gt;&gt;m;\n    vector&lt;ll&gt; a(m);\n    for(int i&#x3D;0;i&lt;m;i++)&#123;\n        cin&gt;&gt;a[i];\n    &#125;\n    ll res&#x3D;0;\n    for(int i&#x3D;1;i&lt;1&lt;&lt;m;i++)&#123;\n        ll cnt&#x3D;0,ans&#x3D;1;\n        for(int j&#x3D;0;j&lt;m;j++)&#123;\n            if(i&gt;&gt;j&amp;1)&#123;\n                cnt++;\n                ans*&#x3D;a[j];\n                if(ans&gt;n)&#123; &#x2F;&#x2F;注意这里如果n已经比ans小的话，直接就可以结束了，不然之后的话可能结果会爆longlong。\n                    ans&#x3D;-1;\n                    break;\n                &#125;\n            &#125;\n        &#125;\n        if(ans&#x3D;&#x3D;-1)&#123;\n            continue;\n        &#125;\n        if(cnt%2&#x3D;&#x3D;1)&#123;\n            res+&#x3D;n&#x2F;ans;\n        &#125;\n        else&#123;\n            res-&#x3D;n&#x2F;ans;\n        &#125;\n    &#125;\n    cout&lt;&lt;res&lt;&lt;endl;\n    return 0;\n&#125;</code></pre>\n\n<p>OK。这次内容就那么多，接下来的一个博弈论的话，我准备放到写到一个blog里面去。<br>Bye~</p>\n","text":"今天的内容是组合数的应用——满足条件的01序列和容斥原理。关于这个满足条件的01序列，其实涉及到了一个特殊的数字卡特兰数。这个我们等会会讲这个。 满足条件的01序列题目意思就是给你n个0，n个1，让你排出来一个序列，使得对于任意的前缀，0的数量是大于等于1的数量的。问你这样的序列...","link":"","photos":[],"count_time":{"symbolsCount":"3.2k","symbolsTime":"3 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":39,"path":"api/tags/ACM.json"},{"name":"学习","slug":"学习","count":43,"path":"api/tags/学习.json"},{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"数学","slug":"数学","count":7,"path":"api/tags/数学.json"},{"name":"组合数","slug":"组合数","count":2,"path":"api/tags/组合数.json"},{"name":"容斥原理","slug":"容斥原理","count":1,"path":"api/tags/容斥原理.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%BB%A1%E8%B6%B3%E6%9D%A1%E4%BB%B6%E7%9A%8401%E5%BA%8F%E5%88%97\"><span class=\"toc-text\">满足条件的01序列</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E8%83%BD%E8%A2%AB%E6%95%B4%E9%99%A4%E7%9A%84%E6%95%B0\"><span class=\"toc-text\">能被整除的数</span></a></li></ol>","author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"tech otakus save the world","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}},"mapped":true,"prev_post":{"title":"ACM学习笔记day29 (Nim游戏，台阶-Nim游戏)","uid":"8af78f8e46bb9ac28caa93ffafd43362","slug":"ACM学习笔记day29","date":"2023-02-08T08:10:48.000Z","updated":"2023-04-08T10:52:54.992Z","comments":true,"path":"api/articles/ACM学习笔记day29.json","keywords":null,"cover":"/img/codeforces.jpg","text":"今天的内容是博弈论的一部分（后面有涉及到SG函数和MEX函数的额，还没听懂（所以只有这两个了。两个一个是Nim游戏是最基础的模型，台阶-Nim游戏是Nim游戏的进阶版本。 Nim游戏就是两个人轮流拿，随便拿几个，随便拿哪一堆的，拿到最后谁不能操作了，谁就输了。这里我们要讲两个概念...","link":"","photos":[],"count_time":{"symbolsCount":"2.6k","symbolsTime":"2 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":39,"path":"api/tags/ACM.json"},{"name":"学习","slug":"学习","count":43,"path":"api/tags/学习.json"},{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"数学","slug":"数学","count":7,"path":"api/tags/数学.json"},{"name":"博弈论","slug":"博弈论","count":1,"path":"api/tags/博弈论.json"},{"name":"Nim游戏","slug":"Nim游戏","count":1,"path":"api/tags/Nim游戏.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"tech otakus save the world","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}},"next_post":{"title":"ACM学习笔记day27(求组合数的四种办法)","uid":"ee586e84b57b3261ae39e785bb3a8c62","slug":"ACM学习笔记day27","date":"2023-02-05T09:20:05.000Z","updated":"2023-04-08T10:52:38.582Z","comments":true,"path":"api/articles/ACM学习笔记day27.json","keywords":null,"cover":"/img/codeforces.jpg","text":"今天的内容是求组合数の四种办法。前三种是逐渐应对给的数据量变大的情况的。第四种是应对得到的结果太大会把longlong都爆掉的情况的。 注意：本篇中，涉及C[a][b]的均是以下组合数表达式。 因为这个blog主题不支持latex语言，所以也没办法现敲公式。 求组合数I这种求组合...","link":"","photos":[],"count_time":{"symbolsCount":"6.2k","symbolsTime":"6 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":39,"path":"api/tags/ACM.json"},{"name":"学习","slug":"学习","count":43,"path":"api/tags/学习.json"},{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"数学","slug":"数学","count":7,"path":"api/tags/数学.json"},{"name":"组合数","slug":"组合数","count":2,"path":"api/tags/组合数.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"tech otakus save the world","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}}}