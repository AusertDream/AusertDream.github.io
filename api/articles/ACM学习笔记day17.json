{"title":"ACM学习笔记day17(floyd算法求多源最短路)","uid":"633b5f64cd1a9eff1c65ad66ca026b45","slug":"ACM学习笔记day17","date":"2022-12-09T14:20:36.000Z","updated":"2023-04-08T10:51:22.699Z","comments":true,"path":"api/articles/ACM学习笔记day17.json","keywords":null,"cover":"/img/codeforces.jpg","content":"<p>额，距离上次写ACM笔记好像已经过了很久了<br>其实这是有原因(<del>借口</del>)的，在被模电折磨捏~<br>好了，不多bb了<br>今天学习的内容是Floyd算法求多源最短路。<br>这个算法写起来东西很少，同时也比较简单，从整体上去理解的话，感觉还是不难理解的<br>运用的思想就是DP的思想</p>\n<span id=\"more\"></span>\n\n<p>直接上代码吧，思想是dp的思想，但是实际操作起来，只有三重嵌套循环，然后不断的用</p>\n<p>&#96; d[i][j]&#x3D;min(d[i][j],d[i][k]+d[k][j]);</p>\n<p>这个来更新距离，注意在floyd算法中，我们直接将用来存储图信息的领接矩阵作为最终的结果距离矩阵<br>下面为acwing上对应的floyd算法的<a href=\"https://www.acwing.com/problem/content/856/\">题目</a></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nconst int N &#x3D; 210;\nconst int INF &#x3D; 1e9;&#x2F;&#x2F;这里这题INF的值不能太大也不能太小，太大了不知道为啥结果溢出了，太小的话，可能会没有路的长度长，起不到无穷的作用\nint d[N][N];\nint n,m,k;\nvoid floyd()&#123;\n    &#x2F;&#x2F;三重嵌套循环，其中k必须在最外面\n    &#x2F;&#x2F;DP的状态转移方程为d[k][i][j]&#x3D;min(d[k-1][i][k]+d[k-1][k][j],d[k][i][j]);\n    &#x2F;&#x2F;当然这里这个k可以优化掉，额，这就具体涉及DP里面的东西了\n    &#x2F;&#x2F;dp的东西我们之后再说吧\n    for(int k&#x3D;1;k&lt;&#x3D;n;k++)&#123;\n        for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;\n            for(int j&#x3D;1;j&lt;&#x3D;n;j++)&#123;\n                d[i][j]&#x3D;min(d[i][j],d[i][k]+d[k][j]);\n            &#125;\n        &#125;\n    &#125;\n&#125;\n\nint main()&#123;\n    cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;\n    for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;\n        for(int j&#x3D;1;j&lt;&#x3D;n;j++)&#123;\n            if(i&#x3D;&#x3D;j)&#123;\n                d[i][j]&#x3D;&#x3D;0;\n            &#125;\n            else&#123;\n                d[i][j]&#x3D;INF;\n            &#125;\n        &#125;\n    &#125;\n    while(m--)&#123;\n        int x,y,z;\n        cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;\n        d[x][y]&#x3D;min(d[x][y],z);\n    &#125;\n    floyd();\n    while(k--)&#123;\n        int x,y;\n        cin&gt;&gt;x&gt;&gt;y;\n        &#x2F;&#x2F;这里因为存在负权边，所以可能实际上两个节点不能到达的距离结果上来看可能小于INF，所以这里判断条件要改成距离是较大值，而不是INF\n        if(d[x][y]&gt;INF&#x2F;2)&#123;\n            cout&lt;&lt;&quot;impossible&quot;&lt;&lt;endl;\n        &#125;\n        else&#123;\n            cout&lt;&lt;d[x][y]&lt;&lt;endl;\n        &#125;\n    &#125;\n    \n    return 0;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>好了，这就是今天的所有内容了，怎么感觉有点水（<br>emmm，行吧，That’s all<br>明天还要考六级捏<br>Bye~</p>\n","text":"额，距离上次写ACM笔记好像已经过了很久了其实这是有原因(借口)的，在被模电折磨捏~好了，不多bb了今天学习的内容是Floyd算法求多源最短路。这个算法写起来东西很少，同时也比较简单，从整体上去理解的话，感觉还是不难理解的运用的思想就是DP的思想 直接上代码吧，思想是dp的思想，...","link":"","photos":[],"count_time":{"symbolsCount":"1.9k","symbolsTime":"2 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"学习","slug":"学习","count":42,"path":"api/tags/学习.json"},{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"ACM","slug":"ACM","count":39,"path":"api/tags/ACM.json"},{"name":"数据结构","slug":"数据结构","count":23,"path":"api/tags/数据结构.json"},{"name":"算法","slug":"算法","count":20,"path":"api/tags/算法.json"},{"name":"Floyd","slug":"Floyd","count":1,"path":"api/tags/Floyd.json"},{"name":"图论","slug":"图论","count":3,"path":"api/tags/图论.json"}],"toc":"","author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"喜欢前沿科技，想要见证人类科学的飞跃","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}},"mapped":true,"prev_post":{"title":"ACM学习笔记day18(dfs)","uid":"43196df8e77fd8e5155e9b94ef5532f4","slug":"ACM学习笔记day18","date":"2022-12-10T15:15:28.000Z","updated":"2023-04-08T10:51:30.587Z","comments":true,"path":"api/articles/ACM学习笔记day18.json","keywords":null,"cover":"/img/codeforces.jpg","text":"今天的内容是dfs，对应的acwing题目 dfs深搜，不难理解，而且之前在白书上我也学过啥意思也不多赘述这里主要讲解一下这题的思路 给你个n，让你求所有可能的排列组合，也就是求permutation因为n很小，所有dfs能过我们从第0个数字开始接下来选第1个数字，有n中可能对应...","link":"","photos":[],"count_time":{"symbolsCount":"1.3k","symbolsTime":"1 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"学习","slug":"学习","count":42,"path":"api/tags/学习.json"},{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"ACM","slug":"ACM","count":39,"path":"api/tags/ACM.json"},{"name":"数据结构","slug":"数据结构","count":23,"path":"api/tags/数据结构.json"},{"name":"算法","slug":"算法","count":20,"path":"api/tags/算法.json"},{"name":"dfs","slug":"dfs","count":4,"path":"api/tags/dfs.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"喜欢前沿科技，想要见证人类科学的飞跃","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}},"next_post":{"title":"ACM学习笔记day16(朴素dijkstra求最短路径)","uid":"569c66ff03a6fea9d4ceedb2c072fa60","slug":"ACM学习笔记day16","date":"2022-12-03T13:32:15.000Z","updated":"2023-04-08T10:51:15.100Z","comments":true,"path":"api/articles/ACM学习笔记day16.json","keywords":null,"cover":"/img/codeforces.jpg","text":"Hello，guys！今天我们学习的内容是dijkstra算法求最短路径,题目emm，第一次学这个的话，感觉还是比较抽象的，不过想了一段时间，稍微整理了一下思路，感觉也还可以应该（ 朴素Dijkstra为什么叫朴素dijkstra呢？因为目前这个dijkstra算法的时间复杂度是...","link":"","photos":[],"count_time":{"symbolsCount":"2.8k","symbolsTime":"3 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"学习","slug":"学习","count":42,"path":"api/tags/学习.json"},{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"ACM","slug":"ACM","count":39,"path":"api/tags/ACM.json"},{"name":"数据结构","slug":"数据结构","count":23,"path":"api/tags/数据结构.json"},{"name":"算法","slug":"算法","count":20,"path":"api/tags/算法.json"},{"name":"蒟蒻","slug":"蒟蒻","count":4,"path":"api/tags/蒟蒻.json"},{"name":"dijkstra","slug":"dijkstra","count":1,"path":"api/tags/dijkstra.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"喜欢前沿科技，想要见证人类科学的飞跃","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}}}