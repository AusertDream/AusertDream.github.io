{"title":"ACM学习笔记day34 (DP专题的总结)","uid":"2c328a2145590af1c8c2b559a8951062","slug":"ACM学习笔记day34","date":"2023-03-19T10:29:55.000Z","updated":"2023-04-08T10:53:59.571Z","comments":true,"path":"api/articles/ACM学习笔记day34.json","keywords":null,"cover":"/img/codeforces.jpg","content":"<p>已经很久没有写笔记了。主要是我一方面我摆（bushi,另外一个就是，后面的各种DP其实写笔记也没啥好写的，主要是理解这个DP是啥，然后也没有对应的板子好写的。<br>自然也就不更新笔记了。<br>那么最近是把基础的DP都学完了，作一个总结，大致的讲一下DP到底是个啥。DP的分类有啥怎么分类的。</p>\n<span id=\"more\"></span>\n\n\n<h1 id=\"什么是动态规划？\"><a href=\"#什么是动态规划？\" class=\"headerlink\" title=\"什么是动态规划？\"></a>什么是动态规划？</h1><p>这个问题其实很难回答。<br>因为对于动态规划的定义，其实很难下定义。<br>但是对于动态规划的概括其实很简单。<br>动态规划就是在运行的过程中，不断的去运用之前已经得到的信息，从而来使得时间复杂度降低。<br>那么相应的，作为代价，空间复杂度就会上升，也就是常说的那句：用空间换时间。<br>怎么运用，这个就是状态转移方程了。<br>其实在说DP之前，我们应该先知道另外一个东西，那就是记忆化搜索。<br>在阿美莉卡那边的教学中，一般都是先教记忆化搜索，然后再教DP的。<br>其实我觉得这样是挺合理的，因为其实记忆化搜索就是DP问题的前身。</p>\n<p>如何建立状态，如何建立状态转移方程，那么这就是DP问题的难点了。</p>\n<h1 id=\"DP问题的分类。\"><a href=\"#DP问题的分类。\" class=\"headerlink\" title=\"DP问题的分类。\"></a>DP问题的分类。</h1><p>当然这里的DP问题分类是最基础的DP分类，之后专题总结应该还会补充。<br>总的来说分为以下几类：<br>背包问题，线性DP，区间DP，计数类DP，数位统计DP，状态压缩DP，树形DP，记忆化搜索。<br>这里背包问题其实是线性DP的内容，只不过因为太经典了，所以我们这里单独作为一类。</p>\n<h2 id=\"背包问题\"><a href=\"#背包问题\" class=\"headerlink\" title=\"背包问题\"></a>背包问题</h2><p>背包问题，可以说是DP问题的非常经典的一个问题了。<br>背包问题可以分为很多种类，包括但不限于 01背包，完全背包，多重背包，分组背包。<br>其中最核心的还是01背包问题，因为其他问题是01背包的变种，其核心思路还是和01背包问题大差不差的。</p>\n<p>01背包问题，通常的二维数组解法就是dp[i][j]表示对于背包剩余容量为j，我们已经拿到了第i个物品，此时里面的最大价值是多少。<br>对于第i个物品，我们一共就有两种选择，拿或者不拿，通过这个我们就可以很轻松的得到dp的状态转移方程。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>dp[i][j]&#x3D;max(dp[i-1][j],dp[i-1][j-v[i]]+w[i]);</p></blockquote>\n<p>当然这里v和w数组到底是啥，可以去看我之前背包问题的具体分析的blog。<img src=\"https://ausertdream.github.io/2023/02/11/ACM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0day30/\" alt=\"传送门\">;</p>\n<p>其他的背包问题具体可以看我其他的blog，都有分析的。</p>\n<h2 id=\"线性DP\"><a href=\"#线性DP\" class=\"headerlink\" title=\"线性DP\"></a>线性DP</h2><p>什么是线性DP呢？<br>其实很简单。<br>我们都知道DP他是有一个存储状态的数组的。一般我们都叫他dp数组，或者是f数组。<br>那么我们也都知道，要做动态规划的问题，一方面要处理边界值，另一方便，就是遍历一边我们的dp数组来解决问题。<br>那么怎么遍历呢？<br>线性DP的遍历方式就是从头遍历到尾巴。<br>比如说这样的一个二维数组</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">1 2 3 \n4 5 6\n7 8 9\n\n我们线性DP的方向就是这样的:\n\n1-&gt;2-&gt;3 \n-&gt;4-&gt;5-&gt;6\n-&gt;7-&gt;8-&gt;9\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>那么这样子的遍历方式就是线性DP。<br>概念很好理解，但是碰到题目，那就难了。<br>不过这种东西还是要多练才可以。</p>\n<h2 id=\"区间DP\"><a href=\"#区间DP\" class=\"headerlink\" title=\"区间DP\"></a>区间DP</h2><p>区间DP和线性DP最大的不同点就在于，他每次DP的时候，是规定了一个DP的区间长度的。</p>\n<p>区间dp就是在区间上进行动态规划，求解一段区间上的最优解。主要是通过合并小区间的最优解进而得出整个大区间上最优解的dp算法</p>\n<p>我们会发现，这个求解局部最优解是不是有点眼熟，没错，贪心也是求取局部最优解的，不过，贪心没有将各个局部的最优解合并。</p>\n<p>其实，光听那么说会感觉很抽象，说实话，这个阐述我也不太理解，能懂，但是实际上并不理解。这个我估计还是题目做少了。</p>\n<h2 id=\"计数类DP\"><a href=\"#计数类DP\" class=\"headerlink\" title=\"计数类DP\"></a>计数类DP</h2><p>计数类DP顾名思义，其实就是一种运用DP去统计数量的问题。<br>计数类DP是是比一般的DP问题约束更多的。<br>因为一般的DP问题，只要求我们对于情况的枚举不能遗漏，如果有重复是没有关系的。<br>但是计数类的DP，是不能遗漏同时也不能重复，因为他最终是要统计出来有多少个可行解的。<br>如果重复，显然会使得结果偏大。</p>\n<p>比较常见的问题，比如说<img src=\"https://www.acwing.com/problem/content/902/\" alt=\"整数划分\">问题。<br>这里其实就是让你求一个整数可以划分成多少种可能，那么很显然，我们dp过去的时候，肯定不能重复算，也不能漏算。<br>这就是计数类DP问题。<br>计数类DP问题他的遍历方法和线性dp是一样的。</p>\n<h2 id=\"数位统计DP\"><a href=\"#数位统计DP\" class=\"headerlink\" title=\"数位统计DP\"></a>数位统计DP</h2><p>数位DP往往都是这样的题型，给定一个闭区间[l,r]，让你求在这个区间内的某种条件的，数的个数。<br>这种时候，一般这个区间都会开的很大，如果暴力做的话，肯定会TLE的。<br>而这种时候，我们不能在这个区间内的所有数字上做文章，而是要在要在给的边界上做文章。<br>具体在哪里做文章呢？其实就是数字位上，这也就是为什么他被成为数位DP。<br>当然这个讲的很抽象，还是要多做题去理解的。</p>\n<h2 id=\"状态压缩DP\"><a href=\"#状态压缩DP\" class=\"headerlink\" title=\"状态压缩DP\"></a>状态压缩DP</h2><p>状态压缩DP，这其实是一类非常奇妙的DP。我们来看这个名字，状态压缩。<br>什么叫状态压缩？其实就是将我们需要表示的状态，采用特殊的形式来表示，比如说用二进制数字来表示，或者string来表示。<br>以方便我们放入我们的dp数组，好进行遍历，状态转移的求解。<br>而这个过程也就叫状态压缩。关于这个的题，我这里也是有一篇博客的来着的。</p>\n<h2 id=\"树形DP\"><a href=\"#树形DP\" class=\"headerlink\" title=\"树形DP\"></a>树形DP</h2><p>这个很好理解，顾名思义，就是相当于在树上面进行DP的过程。一般也会搭配dfs的过程。</p>\n<h2 id=\"记忆化搜索\"><a href=\"#记忆化搜索\" class=\"headerlink\" title=\"记忆化搜索\"></a>记忆化搜索</h2><p>这个其实也很好理解，就是在dfs爆搜的过程中，加入了一个dp数组，用来存储我们之前已经爆搜过的数据，来减少不必要的冗余搜索。<br>过程上来看，和树形DP有一点像，但又不是完全一样的。</p>\n<p>好的，那么DP专题到这里是大致的讲完了。<br>终于把之前的坑给填完了（<br>总之，对于DP说实话还是不太理解的，还是需要多刷题。题目做的太少了。<br>我们下次再见捏<br>Bye~~</p>\n","feature":true,"text":"已经很久没有写笔记了。主要是我一方面我摆（bushi,另外一个就是，后面的各种DP其实写笔记也没啥好写的，主要是理解这个DP是啥，然后也没有对应的板子好写的。自然也就不更新笔记了。那么最近是把基础的DP都学完了，作一个总结，大致的讲一下DP到底是个啥。DP的分类有啥怎么分类的。 ...","link":"","photos":[],"count_time":{"symbolsCount":"2.3k","symbolsTime":"2 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"ACM","slug":"ACM","count":39,"path":"api/tags/ACM.json"},{"name":"笔记","slug":"笔记","count":3,"path":"api/tags/笔记.json"},{"name":"DP","slug":"DP","count":5,"path":"api/tags/DP.json"},{"name":"动态规划","slug":"动态规划","count":5,"path":"api/tags/动态规划.json"},{"name":"专题总结","slug":"专题总结","count":1,"path":"api/tags/专题总结.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%9F\"><span class=\"toc-text\">什么是动态规划？</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#DP%E9%97%AE%E9%A2%98%E7%9A%84%E5%88%86%E7%B1%BB%E3%80%82\"><span class=\"toc-text\">DP问题的分类。</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">背包问题</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BA%BF%E6%80%A7DP\"><span class=\"toc-text\">线性DP</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8C%BA%E9%97%B4DP\"><span class=\"toc-text\">区间DP</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%AE%A1%E6%95%B0%E7%B1%BBDP\"><span class=\"toc-text\">计数类DP</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%95%B0%E4%BD%8D%E7%BB%9F%E8%AE%A1DP\"><span class=\"toc-text\">数位统计DP</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9DP\"><span class=\"toc-text\">状态压缩DP</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%A0%91%E5%BD%A2DP\"><span class=\"toc-text\">树形DP</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2\"><span class=\"toc-text\">记忆化搜索</span></a></li></ol></li></ol>","author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"喜欢前沿科技，想要见证人类科学的飞跃","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}},"mapped":true,"prev_post":{"title":"ACM学习笔记day37 (最短路算法总结)","uid":"d62cd488fd25981616571e6226f3871a","slug":"ACM学习笔记day37","date":"2023-03-25T12:51:16.000Z","updated":"2023-04-09T11:44:17.664Z","comments":true,"path":"api/articles/ACM学习笔记day37.json","keywords":null,"cover":"/img/codeforces.jpg","text":"好，我们这一节对最短路算法作一个总结。总的来说基础的最短路算法有四种。分别为 Dijksta,bellman-ford，spfa，floyd算法。不同的算法应对的是不同的情况。 什么算法解决什么问题，可以看下面这张图。 我们最短路问题，可以分为两大类问题，一类是单源最短路，也就是...","link":"","photos":[],"count_time":{"symbolsCount":"8.9k","symbolsTime":"8 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"学习","slug":"学习","count":42,"path":"api/tags/学习.json"},{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"ACM","slug":"ACM","count":39,"path":"api/tags/ACM.json"},{"name":"最短路问题","slug":"最短路问题","count":1,"path":"api/tags/最短路问题.json"},{"name":"Dijkstra","slug":"Dijkstra","count":1,"path":"api/tags/Dijkstra.json"},{"name":"Bellman-ford","slug":"Bellman-ford","count":1,"path":"api/tags/Bellman-ford.json"},{"name":"spfa","slug":"spfa","count":1,"path":"api/tags/spfa.json"},{"name":"floyd","slug":"floyd","count":1,"path":"api/tags/floyd.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"喜欢前沿科技，想要见证人类科学的飞跃","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}},"feature":true},"next_post":{"title":"ACM小本本","uid":"4a9ea142753f2671aa4c5ecbc1f2c491","slug":"ACM小本本","date":"2022-11-09T12:43:41.000Z","updated":"2023-08-25T14:20:11.540Z","comments":true,"path":"api/articles/ACM小本本.json","keywords":null,"cover":"/img/codeforces.jpg","text":"这里是记录ACM知识点中一些零碎的东西，或者一些小的注意点啥的 1.使用二分模板的时候，当修改left值的时候，注意要让mid&#x3D;left+right+1&gt;&gt;1，不然会出现mid&#x3D;left然后死循环的出现2.快排和归并的本质就是分治，快排是先处理数据...","link":"","photos":[],"count_time":{"symbolsCount":"2k","symbolsTime":"2 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"学习","slug":"学习","count":42,"path":"api/tags/学习.json"},{"name":"ACM","slug":"ACM","count":39,"path":"api/tags/ACM.json"},{"name":"笔记本","slug":"笔记本","count":1,"path":"api/tags/笔记本.json"},{"name":"零碎的","slug":"零碎的","count":1,"path":"api/tags/零碎的.json"},{"name":"知识点","slug":"知识点","count":1,"path":"api/tags/知识点.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"喜欢前沿科技，想要见证人类科学的飞跃","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}},"feature":true}}