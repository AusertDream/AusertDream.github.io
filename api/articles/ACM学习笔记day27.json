{"title":"ACM学习笔记day27(求组合数的四种办法)","uid":"ee586e84b57b3261ae39e785bb3a8c62","slug":"ACM学习笔记day27","date":"2023-02-05T09:20:05.000Z","updated":"2023-04-08T10:52:38.582Z","comments":true,"path":"api/articles/ACM学习笔记day27.json","keywords":null,"cover":"/img/codeforces.jpg","content":"<p>今天的内容是求组合数の四种办法。<br>前三种是逐渐应对给的数据量变大的情况的。<br>第四种是应对得到的结果太大会把longlong都爆掉的情况的。</p>\n<span id=\"more\"></span>\n\n<p>注意：<br>本篇中，涉及C[a][b]的均是以下组合数表达式。</p>\n<p><img src=\"https://raw.githubusercontent.com/AusertDream/MyblogImags/main/CAB.png\" alt=\"cad\"></p>\n<p>因为这个blog主题不支持latex语言，所以也没办法现敲公式。</p>\n<h1 id=\"求组合数I\"><a href=\"#求组合数I\" class=\"headerlink\" title=\"求组合数I\"></a><a href=\"https://www.acwing.com/problem/content/887/\">求组合数I</a></h1><p>这种求组合数的办法是很简单的方法，也就是预处理的办法，来实现O(1)的查询。<br>如何预处理？<br>题目要我们求c[a][b]，a,b最大就是2000，那我们把C[1][0]~C[2000][2000]全部算出来不就可以了。<br>然后每次询问的时候直接去数组里面查找就可以了。<br>这种方法的时间复杂度取决于a和b的大小，设最大为N，那么时间复杂度自然就是O(N^2)。<br>那么我们要如何在N^2的限制下求完全部的组合数呢？其实存在以下这个递推式。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>c[a][b]&#x3D;c[a-1][b]+c[a-1][b-1]</p></blockquote>\n<p>这个式子也很好理解，从a个东西中拿b个，总共就分为两种情况。<br>对于其中的任何一个特定的东西，我们有拿他和不拿两种，<br>如果拿他，那么我们就在剩下的a-1个中拿b-1个，反之，就在剩下的a-1个中拿b个。<br>严格的数学证明就是用定义去证明，写成阶乘的形式，然后化简就可以了。</p>\n<p>因此有了这个递推式之后，我们就可以直接预处理出所有组合数的值了，当然别忘了取余。</p>\n<p>ac code:</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nconst int N &#x3D; 2010,mod &#x3D; 1e9+7;\nint n;\nint c[N][N];\n\nvoid init()&#123;\n    for(int i&#x3D;0;i&lt;N;i++)&#123;\n        for(int j&#x3D;0;j&lt;&#x3D;i;j++)&#123;\n            if(j&#x3D;&#x3D;0)&#123;\n                c[i][j]&#x3D;1; &#x2F;&#x2F;如果j为零的话，组合数的值固定为1的，这里就是边界问题。\n            &#125;\n            else&#123;\n                c[i][j]&#x3D;(c[i-1][j]+c[i-1][j-1])%mod;\n            &#125;\n        &#125;\n    &#125;\n&#125;\nint main()&#123;\n    cin&gt;&gt;n;\n    init();\n    while(n--)&#123;\n        int a,b;\n        cin&gt;&gt;a&gt;&gt;b;\n        cout&lt;&lt;c[a][b]&lt;&lt;endl;\n    &#125;\n    return 0;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h1 id=\"求组合数II\"><a href=\"#求组合数II\" class=\"headerlink\" title=\"求组合数II\"></a><a href=\"https://www.acwing.com/problem/content/888/\">求组合数II</a></h1><p>这个情况下呢，给的a和b他的最大值N，已经比较大了。<br>如果再沿用上面的做法，是行不通的，因为N^2肯定会超时的。<br>那么这里我们也是使用预处理的办法，不过我们不是把所有的组合数结果直接预处理出来。<br>而是预处理出来阶乘的结果。然后我们对于每一个询问，按照定义，用已经知道的阶乘的结果去计算就可以了。<br>当然这里会有一个问题。<br>结果是要求取模的。<br>我们预处理阶乘的时候也是要取模的。不然肯定会爆longlong的。<br>那么如果我们直接用阶乘去作除法的话，很明显是不对的。<br>因为两个数相除的取模结果是不等于分别取模然后相除的结果的。<br>那么这里我们就要用到一个数的逆元。<br>逆元其实就是同余一个数的情况下，一个数的倒数而已。<br>也就是说对于我们求到的每一个阶乘，我们同时要求一个他的同余mod的逆元。<br>比如我们求导3!的时候，我们要求一下他的同余mod的逆元，然后存起来。<br>最后我们求C[a][b]的时候<br>原本应该是a!&#x2F;b!&#x2F;(a-b)!<br>这里的除以b!就可以改成乘以b!的逆元，从而保证了计算的正确性。<br>(a-b)!同理。<br>当然这题他给的模数1e9+7是质数，所以可以用费马小定理用快速幂去求逆元，不然的话就只能是扩欧了。</p>\n<p>ac code:</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\nconst int N &#x3D; 1e5+10;,mod&#x3D;1e9+7;\nint n;\nll fact[N],infact[N];\n\nll qmi(ll a,ll b,ll c)&#123;\n    ll res&#x3D;1;\n    while(b)&#123;\n        if(b&amp;1)&#123;\n            res&#x3D;res*a%c;\n        &#125;\n        a&#x3D;a*a%c;\n        b&gt;&gt;&#x3D;1;\n    &#125;\n    return res;\n&#125;\nint main()&#123;\n    cin&gt;&gt;n;\n    fact[0]&#x3D;infact[0]&#x3D;1;\n    for(int i&#x3D;1;i&lt;N;i++)&#123;\n        fact[i]&#x3D;fact[i-1]*i%mod;\n        infact[i]&#x3D;infact[i-1]*qmi(i,mod-2,mod)%mod; &#x2F;&#x2F;这里阶乘的逆元也满足递推关系式的。\n        &#x2F;&#x2F;e.g 1&#x2F;3!是不是就是1&#x2F;2!*1&#x2F;3?只不过这里都是对应数字的逆元罢了。这里的qmi就是i的模mod下的逆元。\n    &#125;\n    while(n--)&#123;\n        ll a,b;\n        cin&gt;&gt;a&gt;&gt;b;\n        cout&lt;&lt;fact[a]*infact[b]%mod*infact[a-b]%mod&lt;&lt;endl;\n    &#125;\n    return 0;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>算法的时间复杂度是O(N*log(mod-2))。<br>这里这个N是a和b的最大值，mod是他给的模数。</p>\n<h1 id=\"求组合数III\"><a href=\"#求组合数III\" class=\"headerlink\" title=\"求组合数III\"></a><a href=\"https://www.acwing.com/problem/content/889/\">求组合数III</a></h1><p>这题的话，给的a和b的数据范围特别大，N都一定到了longlong类型的上限了。<br>那么很显然上一个预处理阶乘的办法肯定是不行的了。<br>这里我们就不能够预处理的。<br>因为数据太大了。<br>同时我们注意到他给的询问次数很少就20次。<br>那么其实我们可以边询问边计算。<br>那么怎么才能够快速的计算出来这个结果呢？<br>这里我们要使用到<code>Lucas定理</code>。<br>什么是卢卡斯定理？<br>如下：</p>\n<p><img src=\"https://raw.githubusercontent.com/AusertDream/MyblogImags/main/Lucas.png\" alt=\"Lucas\"></p>\n<p>对于乘积的左边，我们可以直接用组合数的定义去求，对于右边我们可以递归的使用Lucas定理。<br>这样我们就使用了Lucas定理解决了这个问题。<br>关于Lucas定理的证明，理解起来不难的，就是一个构造性的证明。<br>不做要求，会用Lucas就可以了。<br>证明如下：</p>\n<p><img src=\"https://raw.githubusercontent.com/AusertDream/MyblogImags/main/Lucas%E8%AF%81%E6%98%8E.jpg\" alt=\"Lucas证明\"></p>\n<p>既然知道了Lucas定理，那么我们接下来做这题就很很简单了。<br>公式怎么说就怎么写就可以了。</p>\n<p>当然在用定义求组合数的时候，因为涉及到了除法，在同余的情况下，就是乘上一个他的逆元就行了。<br>同样，因为p为质数，所以求逆元用快速幂就可以了。<br>不要真的做除法会出问题的（</p>\n<p>ac code:</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\nint n;\nint p;\n\nll qmi(ll a,ll b,ll c)&#123;\n    ll res&#x3D;1;\n    while(b)&#123;\n        if(b&amp;1)&#123;\n            res&#x3D;res*a%c;\n        &#125;\n        a&#x3D;a*a%c;\n        b&gt;&gt;&#x3D;1;\n    &#125;\n    return res;\n&#125;\n\nll C(ll a,ll b)&#123;\n    ll res&#x3D;1;\n    for(int i&#x3D;1,j&#x3D;a;i&lt;&#x3D;b;j--,i++)&#123;\n        res&#x3D;res*j%p;\n        res&#x3D;res*qmi(i,p-2,p)%p;\n    &#125;\n    return res; \n&#125;\n\nll lucas(ll a,ll b)&#123;\n    if(a&lt;p&amp;&amp;b&lt;p) return C(a,b);\n    else&#123;\n        return C(a%p,b%p)*lucas(a&#x2F;p,b&#x2F;p)%p;\n    &#125;\n&#125;\n\nint main()&#123;\n    cin&gt;&gt;n;\n    while(n--)&#123;\n        ll a,b;\n        cin&gt;&gt;a&gt;&gt;b&gt;&gt;p;\n        cout&lt;&lt;lucas(a,b)&lt;&lt;endl;\n    &#125;\n    return 0;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>我们设N为给的数据的最大值。<br>这个算法的时间复杂度是</p>\n<p><img src=\"https://raw.githubusercontent.com/AusertDream/MyblogImags/main/OlogpN.png\" alt=\"oooo\"></p>\n<p>对于后面的两个log函数，如果p很大，那么乘积前面那个就会很小，反之亦然。<br>所以总的来说，时间复杂度不会超过1e8的。</p>\n<h1 id=\"求组合数IV\"><a href=\"#求组合数IV\" class=\"headerlink\" title=\"求组合数IV\"></a><a href=\"https://www.acwing.com/problem/content/890/\">求组合数IV</a></h1><p>这个第四种求组合数的方法呢。<br>是对于没有让你取模的情况下的方法。<br>也就是涉及到了高精度计算。d<br>如果我们就顺其自然的去做，就会涉及到了高精度乘除法。<br>并且时间复杂度也会比较高。<br>所以我们采用的办法是，将组合数的结果拆分成质因数的次幂乘积式。然后用高精度乘法来一个一个计算过去。<br>那么怎么得到这个式子就是一个难点。<br>我们按照组合数计算的定义，组合数等于三个阶乘的乘除的式子。<br>那么我们求出阶乘的质因数次幂表达式，不就可以得出来组合数的了？<br>如何来得到阶乘的质因数次幂表达式？</p>\n<p>这里，我们需要采用筛质数的办法，把所有范围内的质数全部筛出来，然后一个一个去检查阶乘中有几个这个数。<br>那么如何检查？</p>\n<p>对于n! 他分解质因数之后质数p的次幂就等于以下表达式</p>\n<p><img src=\"https://raw.githubusercontent.com/AusertDream/MyblogImags/main/121221221.png\" alt=\"121121111\"></p>\n<p>其中n&#x2F;p就代表了什么？<br>n!中1个p，2个p…的个数。<br>p^2同理，这样我们就能够把n!里面所有的p的个数求出来了，也就是我们要求的p的次幂。<br>我们求出了一个阶乘的，对于阶乘相除的，就把对应次幂的相减就是了，因为是乘除法。</p>\n<p>ac code:</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nvector&lt;int&gt; primes;\nconst int N &#x3D; 5010;\nbool flag[N];\nint cimi[N];\n\nint getcimi(int n,int p)&#123;\n    int res&#x3D;0;\n    while(n)&#123;\n        res+&#x3D;n&#x2F;p;\n        n&#x2F;&#x3D;p;\n    &#125;\n    return res;\n&#125;\nvoid getprimes(int a)&#123;\n    for(int i&#x3D;2;i&lt;&#x3D;a;i++)&#123;\n        if(!flag[i])&#123;\n            primes.push_back(i);\n        &#125;\n        for(int j&#x3D;0;primes[j]*i&lt;&#x3D;a;j++)&#123;\n            flag[primes[j]*i]&#x3D;true;\n            if(i%primes[j]&#x3D;&#x3D;0) break;\n        &#125;\n    &#125;\n&#125;\n\nvector&lt;int&gt; mulp(vector&lt;int&gt; a,int b)&#123;\n    int t&#x3D;0;\n    vector&lt;int&gt; res;\n    for(int i&#x3D;0;i&lt;a.size();i++)&#123;\n        t+&#x3D;a[i]*b;\n        res.push_back(t%10);\n        t&#x2F;&#x3D;10;\n    &#125;\n    while(t)&#123;\n        res.push_back(t%10);\n        t&#x2F;&#x3D;10;\n    &#125;\n    return res;\n&#125;\n\nint main()&#123;\n    int a,b;\n    cin&gt;&gt;a&gt;&gt;b;\n    getprimes(a);\n    \n    for(int i&#x3D;0;i&lt;primes.size();i++)&#123;\n        int p&#x3D;primes[i];\n        cimi[i]&#x3D;getcimi(a,p)-getcimi(b,p)-getcimi(a-b,p);\n    &#125;\n    vector&lt;int&gt; res;\n    res.push_back(1);\n    for(int i&#x3D;0;i&lt;primes.size();i++)&#123;\n        for(int j&#x3D;0;j&lt;cimi[i];j++)&#123;\n            res&#x3D;mulp(res,primes[i]);\n        &#125;\n    &#125;\n    \n    for(int i&#x3D;res.size()-1;i&gt;&#x3D;0;i--)&#123;\n        cout&lt;&lt;res[i];\n    &#125;\n    cout&lt;&lt;endl;\n    \n\n    \n    return 0;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>OK,那么至此就是求组合数的四种办法了，前三种是一种比一种优化，第四种是专门应对不求模的情况的。<br>我们下次再见<br>Bye~</p>\n","text":"今天的内容是求组合数の四种办法。前三种是逐渐应对给的数据量变大的情况的。第四种是应对得到的结果太大会把longlong都爆掉的情况的。 注意：本篇中，涉及C[a][b]的均是以下组合数表达式。 因为这个blog主题不支持latex语言，所以也没办法现敲公式。 求组合数I这种求组合...","link":"","photos":[],"count_time":{"symbolsCount":"6.2k","symbolsTime":"6 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":39,"path":"api/tags/ACM.json"},{"name":"学习","slug":"学习","count":42,"path":"api/tags/学习.json"},{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"数学","slug":"数学","count":7,"path":"api/tags/数学.json"},{"name":"组合数","slug":"组合数","count":2,"path":"api/tags/组合数.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%B1%82%E7%BB%84%E5%90%88%E6%95%B0I\"><span class=\"toc-text\">求组合数I</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%B1%82%E7%BB%84%E5%90%88%E6%95%B0II\"><span class=\"toc-text\">求组合数II</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%B1%82%E7%BB%84%E5%90%88%E6%95%B0III\"><span class=\"toc-text\">求组合数III</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%B1%82%E7%BB%84%E5%90%88%E6%95%B0IV\"><span class=\"toc-text\">求组合数IV</span></a></li></ol>","author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"喜欢前沿科技，想要见证人类科学的飞跃","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}},"mapped":true,"prev_post":{"title":"ACM学习笔记day28 (组合数的应用——满足条件的01序列，容斥原理)","uid":"cd92aa8f26118d15f6c9920aff860d6f","slug":"ACM学习笔记day28","date":"2023-02-07T09:31:39.000Z","updated":"2023-04-08T10:52:45.948Z","comments":true,"path":"api/articles/ACM学习笔记day28.json","keywords":null,"cover":"/img/codeforces.jpg","text":"今天的内容是组合数的应用——满足条件的01序列和容斥原理。关于这个满足条件的01序列，其实涉及到了一个特殊的数字卡特兰数。这个我们等会会讲这个。 满足条件的01序列题目意思就是给你n个0，n个1，让你排出来一个序列，使得对于任意的前缀，0的数量是大于等于1的数量的。问你这样的序列...","link":"","photos":[],"count_time":{"symbolsCount":"3.2k","symbolsTime":"3 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":39,"path":"api/tags/ACM.json"},{"name":"学习","slug":"学习","count":42,"path":"api/tags/学习.json"},{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"数学","slug":"数学","count":7,"path":"api/tags/数学.json"},{"name":"组合数","slug":"组合数","count":2,"path":"api/tags/组合数.json"},{"name":"容斥原理","slug":"容斥原理","count":1,"path":"api/tags/容斥原理.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"喜欢前沿科技，想要见证人类科学的飞跃","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}},"next_post":{"title":"ACM学习笔记day26 (高斯消元解线性方程组和异或方程组)","uid":"1a520a07ea86cfe9d127f0b6811d1363","slug":"ACM学习笔记day26","date":"2023-02-04T13:00:01.000Z","updated":"2023-04-08T10:52:31.322Z","comments":true,"path":"api/articles/ACM学习笔记day26.json","keywords":null,"cover":"/img/codeforces.jpg","text":"今天的内容是使用高斯消元解线性方程组和异或方程组。什么是高斯消元，不多说，线代的基本内容。 高斯消元解线性方程组用高斯消元解线性方程组的时候，编程解决其实就是一个模拟的事情。我们写程序去模拟我们的实际进行的步骤。该模板的时间复杂度为O(n^3)。可以看到时间复杂度还是很高的。如果...","link":"","photos":[],"count_time":{"symbolsCount":"4.7k","symbolsTime":"4 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":39,"path":"api/tags/ACM.json"},{"name":"学习","slug":"学习","count":42,"path":"api/tags/学习.json"},{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"数学","slug":"数学","count":7,"path":"api/tags/数学.json"},{"name":"高斯消元","slug":"高斯消元","count":1,"path":"api/tags/高斯消元.json"},{"name":"解方程组","slug":"解方程组","count":1,"path":"api/tags/解方程组.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"喜欢前沿科技，想要见证人类科学的飞跃","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}}}