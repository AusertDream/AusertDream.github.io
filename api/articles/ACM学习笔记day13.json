{"title":"ACM学习笔记day13(求连通块中点的数量)","uid":"d45c53bbd2d951bda24bba0bdde79964","slug":"ACM学习笔记day13","date":"2022-11-25T11:42:49.000Z","updated":"2023-04-08T10:50:52.060Z","comments":true,"path":"api/articles/ACM学习笔记day13.json","keywords":null,"cover":"/img/codeforces.jpg","content":"<p>今天的内容是求连通块中点的数量</p>\n<h2 id=\"求连通块中点的数量\"><a href=\"#求连通块中点的数量\" class=\"headerlink\" title=\"求连通块中点的数量\"></a>求连通块中点的数量</h2><p>这题和并查集那道模板题差不多<br>就是多了一个要求<br>让你统计集合中的数量而已</p>\n<span id=\"more\"></span>\n\n<p>这里我们用到一个cnt数组，同时我们规定，只有根节点的cnt数据是有意义的<br>这样我们就避免了要给多个同连通块的集合重新赋值的麻烦</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nconst int N &#x3D; 100010;\nint p[N],cnt[N];\nint n,m;\n\nint find(int x)&#123;\n    if(p[x]!&#x3D;x)&#123;\n        p[x]&#x3D;find(p[x]);\n    &#125;\n    return p[x];\n&#125;\n\nint main()&#123;\n    cin&gt;&gt;n&gt;&gt;m;\n    for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;\n        p[i]&#x3D;i;\n        cnt[i]&#x3D;1; &#x2F;&#x2F;一开始每一个连通块中都只有一个点\n    &#125;\n    while(m--)&#123;\n        string op;\n        cin&gt;&gt;op;\n        if(op&#x3D;&#x3D;&quot;C&quot;)&#123;\n            int a,b;\n            cin&gt;&gt;a&gt;&gt;b;\n            if(find(a)&#x3D;&#x3D;find(b)) continue; &#x2F;&#x2F;这里特判一下，如果a和b已经在同一个连通块里面了，不需要在加啥了，不然会将值翻倍导致WA\n            cnt[find(b)]+&#x3D;cnt[find(a)];&#x2F;&#x2F;新的树的cnt个数也就是原来的加上另外一个的cnt值\n            p[find(a)]&#x3D;find(b); &#x2F;&#x2F;这里cnt改变要先进行，不然find(a)的值会被改变，也就会导致cnt计数错误\n        &#125;\n        else if(op&#x3D;&#x3D;&quot;Q1&quot;)&#123;\n            int a,b;\n            cin&gt;&gt;a&gt;&gt;b;\n            if(find(a)&#x3D;&#x3D;find(b))&#123;\n                cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl;\n            &#125;\n            else&#123;\n                cout&lt;&lt;&quot;No&quot;&lt;&lt;endl;\n            &#125;\n        &#125;\n        else&#123;\n            int a;\n            cin&gt;&gt;a;\n            cout&lt;&lt;cnt[find(a)]&lt;&lt;endl;&#x2F;&#x2F;要就输出结果的话，就直接输出a的根节点的cnt的值就可以了\n        &#125;\n    &#125;\n    return 0;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>","text":"今天的内容是求连通块中点的数量 求连通块中点的数量这题和并查集那道模板题差不多就是多了一个要求让你统计集合中的数量而已 这里我们用到一个cnt数组，同时我们规定，只有根节点的cnt数据是有意义的这样我们就避免了要给多个同连通块的集合重新赋值的麻烦 #include&lt;bits...","link":"","photos":[],"count_time":{"symbolsCount":"1.5k","symbolsTime":"1 mins."},"categories":[{"name":"ACM","slug":"ACM","count":38,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":36,"path":"api/tags/ACM.json"},{"name":"学习","slug":"学习","count":41,"path":"api/tags/学习.json"},{"name":"打卡","slug":"打卡","count":34,"path":"api/tags/打卡.json"},{"name":"数据结构","slug":"数据结构","count":20,"path":"api/tags/数据结构.json"},{"name":"算法","slug":"算法","count":20,"path":"api/tags/算法.json"},{"name":"并查集","slug":"并查集","count":2,"path":"api/tags/并查集.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%B1%82%E8%BF%9E%E9%80%9A%E5%9D%97%E4%B8%AD%E7%82%B9%E7%9A%84%E6%95%B0%E9%87%8F\"><span class=\"toc-text\">求连通块中点的数量</span></a></li></ol>","author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"喜欢前沿科技，想要见证人类科学的飞跃","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}},"mapped":true,"prev_post":{"title":"ACM学习笔记day14（带权并查集，堆排序，模拟堆）","uid":"baee1de5b96302e6e975d5e11b914928","slug":"ACM学习笔记day14","date":"2022-12-01T14:13:12.000Z","updated":"2023-04-08T10:50:59.395Z","comments":true,"path":"api/articles/ACM学习笔记day14.json","keywords":null,"cover":"/img/codeforces.jpg","text":"Hello guys!感觉好久没有写笔记了，上次写笔记好像是呃呃呃，五天前了吧。要忙学校的好多事情，呜呜呜，我有罪orz好了，不bb了，今天的学习内容是带权并查集（食物链）,堆模拟,堆排序 带权并查集带权并查集就是原来并查集的升级版，plus版本。相较于原来的普通的并查集，带权并...","link":"","photos":[],"count_time":{"symbolsCount":"8.2k","symbolsTime":"7 mins."},"categories":[{"name":"ACM","slug":"ACM","count":38,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":36,"path":"api/tags/ACM.json"},{"name":"学习","slug":"学习","count":41,"path":"api/tags/学习.json"},{"name":"打卡","slug":"打卡","count":34,"path":"api/tags/打卡.json"},{"name":"数据结构","slug":"数据结构","count":20,"path":"api/tags/数据结构.json"},{"name":"算法","slug":"算法","count":20,"path":"api/tags/算法.json"},{"name":"带权并查集","slug":"带权并查集","count":1,"path":"api/tags/带权并查集.json"},{"name":"堆","slug":"堆","count":1,"path":"api/tags/堆.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"喜欢前沿科技，想要见证人类科学的飞跃","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}},"next_post":{"title":"ACM学习笔记day12(最大异或对，并查集)","uid":"5299e436ed1961fa0cb39dca432850d2","slug":"ACM学习笔记day12","date":"2022-11-24T14:50:04.000Z","updated":"2023-04-08T10:50:43.082Z","comments":true,"path":"api/articles/ACM学习笔记day12.json","keywords":null,"cover":"/img/codeforces.jpg","text":"今天的内容是Trie树的应用和并查集的学习。这个最大异或对的话，就是Trie树的应用，然后有别于之前那个Trie树存的数据不一样，之前那个存的是char，现在这个存的是0和1。然后并查集的话感觉就是构建了一个森林，然后每一颗树代表了一定的信息。 最大异或对最大异或对。题目是啥呢，...","link":"","photos":[],"count_time":{"symbolsCount":"3.9k","symbolsTime":"4 mins."},"categories":[{"name":"ACM","slug":"ACM","count":38,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":36,"path":"api/tags/ACM.json"},{"name":"打卡","slug":"打卡","count":34,"path":"api/tags/打卡.json"},{"name":"数据结构","slug":"数据结构","count":20,"path":"api/tags/数据结构.json"},{"name":"算法","slug":"算法","count":20,"path":"api/tags/算法.json"},{"name":"并查集","slug":"并查集","count":2,"path":"api/tags/并查集.json"},{"name":"Trie树","slug":"Trie树","count":1,"path":"api/tags/Trie树.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"喜欢前沿科技，想要见证人类科学的飞跃","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}}}