{"title":"ACM学习笔记day19(N皇后问题-2种dfs解法)","uid":"983fdf7c1cf56eb82d4bc470facb21cc","slug":"ACM学习笔记day19","date":"2022-12-11T14:48:21.000Z","updated":"2023-04-08T10:51:37.675Z","comments":true,"path":"api/articles/ACM学习笔记day19.json","keywords":null,"cover":"/img/codeforces.jpg","content":"<p>今天的内容是N皇后问题，有两种dfs方法，但是自己在写的时候还是碰到了不少问题的。</p>\n<span id=\"more\"></span>\n<h2 id=\"第一种dfs方法\"><a href=\"#第一种dfs方法\" class=\"headerlink\" title=\"第一种dfs方法\"></a>第一种dfs方法</h2><p>这种dfs方法，是基于我们已经知道了，每一行每一列每一主对角线和副对角线上只能有一个皇后。<br>思想和数字的全排列差不多。<br>我们dfs第零行到第n-1行，然后枚举第零列到第n-1列，如果有满足条件的，就放一个皇后。<br>直到递归的深度到达n之后，输出一个解。然后回溯寻找其他的解。<br>这里要涉及一个第x行第y列的格子是第几个主对角线的和第几个副对角线的问题。<br>我们定义的dg数组是指副对角线的。<br>udg数组是指主对角线的。实际上这两个东西的含义相反的话也没事的。<br>其中对于第x行第y列的格子，他对应的dg下标是x+y<br>而udg的则是x-y+n;<br>为什么是这样的？<br>我们看下面两张图。</p>\n<p>这张图中，描述的是udg的情况，我们可以通过找规律来理解为什么x,y对应的是x-y+n<br>这里加n是为了让他的值为非负，不然数组会越界的。</p>\n<p><img src=\"https://raw.githubusercontent.com/AusertDream/MyblogImags/main/N%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98%E5%9B%BE1.png\" alt=\"N皇后图1\"></p>\n<p>这张图中，描述的是dg的情况，我们也可以通过找规律来理解为什么x，y对应的是x+y</p>\n<p><img src=\"https://raw.githubusercontent.com/AusertDream/MyblogImags/main/N%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98%E5%9B%BE2.png\" alt=\"N皇后图2\"></p>\n<p>下面为代码：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nconst int N&#x3D;20;\nchar graph[N][N];\nint n;\nbool col[N],dg[N],udg[N];\n\nvoid dfs(int x)&#123;\n    if(x&#x3D;&#x3D;n)&#123; &#x2F;&#x2F;递归到n的时候，可以停止了，因为这个时候n行都被放完了。\n        for(int i&#x3D;0;i&lt;n;i++)&#123;\n            for(int j&#x3D;0;j&lt;n;j++)&#123;\n                cout&lt;&lt;graph[i][j];\n            &#125;\n            cout&lt;&lt;endl;\n        &#125;\n        cout&lt;&lt;endl;\n        return;\n    &#125;\n    for(int i&#x3D;0;i&lt;n;i++)&#123; &#x2F;&#x2F;逐列寻找可以放的地方\n        if(!col[i]&amp;&amp;!dg[x+i]&amp;&amp;!udg[x-i+n])&#123;\n            graph[x][i]&#x3D;&#39;Q&#39;;\n            col[i]&#x3D;1;\n            dg[x+i]&#x3D;1;\n            udg[x-i+n]&#x3D;1; &#x2F;&#x2F;将皇后放下，同时更新所有的数组。\n            dfs(x+1);\n            graph[x][i]&#x3D;&#39;.&#39;; &#x2F;&#x2F;恢复现场\n            col[i]&#x3D;0;\n            dg[x+i]&#x3D;0;\n            udg[x-i+n]&#x3D;0;\n        &#125;\n    &#125;\n&#125;\n\nint main()&#123;\n    cin&gt;&gt;n;\n    for(int i&#x3D;0;i&lt;n;i++)&#123;\n        for(int j&#x3D;0;j&lt;n;j++)&#123;\n            graph[i][j]&#x3D;&#39;.&#39;;\n        &#125;\n    &#125;\n    dfs(0); &#x2F;&#x2F;从第零行开始dfs\n    return 0;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>这种算法的时间复杂度是O(n*n!)<br>可以看见复杂度很高，当然后面还有优化的。</p>\n<h2 id=\"第二种dfs方法\"><a href=\"#第二种dfs方法\" class=\"headerlink\" title=\"第二种dfs方法\"></a>第二种dfs方法</h2><p>这一种dfs的方法比上一种更加的朴素。我们对于每一个格子，分别有两种选择，放还是不放。<br>以此构成一个二叉决策树，树的深度就是n方，格子的个数。<br>思路很简单。<br>下面为代码：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nconst int N &#x3D; 20;\nint n;\nchar graph[N][N];\nbool row[N],col[N],dg[N],udg[N];\n\nvoid dfs(int x,int y,int s)&#123;\n    if(y&#x3D;&#x3D;n)&#123; &#x2F;&#x2F;如果y&#x3D;&#x3D;n说明已经出界了，那我们让y回到零，同时让行数++\n        y&#x3D;0;\n        x++;\n    &#125;\n    if(x&#x3D;&#x3D;n)&#123;\n        if(s&#x3D;&#x3D;n)&#123; &#x2F;&#x2F;如果x到了n就说明n-1.n-1这个点已经过了，并且皇后已经放了n个的话就可以输出了，然后结束递归\n            for(int i&#x3D;0;i&lt;n;i++)&#123;\n                for(int j&#x3D;0;j&lt;n;j++)&#123;\n                    cout&lt;&lt;graph[i][j];\n                &#125;\n                cout&lt;&lt;endl;\n            &#125;\n            cout&lt;&lt;endl;\n        &#125;\n        return;\n    &#125;\n    &#x2F;&#x2F;不放皇后的情况\n    dfs(x,y+1,s);\n    &#x2F;&#x2F;放皇后的情况，这里要放的时候要注意不能和其他皇后起冲突\n    if(!row[x]&amp;&amp;!col[y]&amp;&amp;!dg[x+y]&amp;&amp;!udg[x-y+n])&#123;\n        row[x]&#x3D;1; &#x2F;&#x2F;更新所有数组\n        col[y]&#x3D;1;\n        dg[x+y]&#x3D;1;\n        udg[x-y+n]&#x3D;1;\n        graph[x][y]&#x3D;&#39;Q&#39;;\n        dfs(x,y+1,s+1); &#x2F;&#x2F;然后前往下一个点，同时放的皇后计数器++。\n        row[x]&#x3D;0; &#x2F;&#x2F;恢复现场\n        col[y]&#x3D;0;\n        dg[x+y]&#x3D;0;\n        udg[x-y+n]&#x3D;0;\n        graph[x][y]&#x3D;&#39;.&#39;;\n    &#125;\n&#125;\n\nint main()&#123;\n    cin&gt;&gt;n;\n    for(int i&#x3D;0;i&lt;n;i++)&#123;\n        for(int j&#x3D;0;j&lt;n;j++)&#123;\n            graph[i][j]&#x3D;&#39;.&#39;;\n        &#125;\n    &#125;\n    dfs(0,0,0); &#x2F;&#x2F;三个参数分别为第x行第y列，当前已经放了几个皇后了。\n    \n    return 0;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>这个算法的时间复杂度是O(2^(n^2))。<br>时间复杂度也是非常的高。</p>\n<p>好的，就那么多。<br>我们下次再见~<br>Bye~</p>\n","text":"今天的内容是N皇后问题，有两种dfs方法，但是自己在写的时候还是碰到了不少问题的。 第一种dfs方法这种dfs方法，是基于我们已经知道了，每一行每一列每一主对角线和副对角线上只能有一个皇后。思想和数字的全排列差不多。我们dfs第零行到第n-1行，然后枚举第零列到第n-1列，如果有...","link":"","photos":[],"count_time":{"symbolsCount":"3.4k","symbolsTime":"3 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":39,"path":"api/tags/ACM.json"},{"name":"学习","slug":"学习","count":42,"path":"api/tags/学习.json"},{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"数据结构","slug":"数据结构","count":23,"path":"api/tags/数据结构.json"},{"name":"算法","slug":"算法","count":20,"path":"api/tags/算法.json"},{"name":"dfs","slug":"dfs","count":4,"path":"api/tags/dfs.json"},{"name":"N皇后","slug":"N皇后","count":1,"path":"api/tags/N皇后.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%AC%AC%E4%B8%80%E7%A7%8Ddfs%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">第一种dfs方法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%AC%AC%E4%BA%8C%E7%A7%8Ddfs%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">第二种dfs方法</span></a></li></ol>","author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"喜欢前沿科技，想要见证人类科学的飞跃","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}},"mapped":true,"prev_post":{"title":"题解-Codeforces-Round-837-div-2","uid":"8939638ff3772e749e6b91f98033c73a","slug":"题解-Codeforces-Round-837-div-2","date":"2022-12-12T11:57:48.000Z","updated":"2023-08-27T09:17:27.684Z","comments":true,"path":"api/articles/题解-Codeforces-Round-837-div-2.json","keywords":null,"cover":"/img/二次元の图/1.jpg","text":"蒟蒻又日常来尝试div2了，这次独立（额，算独立吗）做出来的只有A，B还是问了别人才做出来的，接下里的这个就是B的题解。下面这个做法真的十分的优雅。代码很简洁，思路也很清楚。 B-Hossam and Friends 题目链接 题目描述：一个人有n个朋友，按照1,2,3,4…，n...","link":"","photos":[],"count_time":{"symbolsCount":"2.2k","symbolsTime":"2 mins."},"categories":[{"name":"题解","slug":"题解","count":1,"path":"api/categories/题解.json"}],"tags":[{"name":"ACM","slug":"ACM","count":39,"path":"api/tags/ACM.json"},{"name":"学习","slug":"学习","count":42,"path":"api/tags/学习.json"},{"name":"数据结构","slug":"数据结构","count":23,"path":"api/tags/数据结构.json"},{"name":"算法","slug":"算法","count":20,"path":"api/tags/算法.json"},{"name":"codeforces","slug":"codeforces","count":1,"path":"api/tags/codeforces.json"},{"name":"题解","slug":"题解","count":1,"path":"api/tags/题解.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"喜欢前沿科技，想要见证人类科学的飞跃","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}},"next_post":{"title":"网站开发日志2(新增了图床)","uid":"d247f335debb5355e7105da57059aeeb","slug":"网站开发日志2","date":"2022-12-11T08:51:32.000Z","updated":"2023-08-27T09:18:15.701Z","comments":true,"path":"api/articles/网站开发日志2.json","keywords":null,"cover":[],"text":"emmm，日志是之后写的，实际的实现功能在之前就完成了这里只是补个开发日志而已 更新内容： 新增了图床，博客中可以上传图片了 简单学习了一下图床，现在所有的图片我都放图床上了那么接下来，我们博客里面也就能看到图片力！好耶！ ","link":"","photos":[],"count_time":{"symbolsCount":124,"symbolsTime":"1 mins."},"categories":[{"name":"个人博客开发","slug":"个人博客开发","count":2,"path":"api/categories/个人博客开发.json"}],"tags":[{"name":"学习","slug":"学习","count":42,"path":"api/tags/学习.json"},{"name":"网站部署","slug":"网站部署","count":2,"path":"api/tags/网站部署.json"},{"name":"网站开发","slug":"网站开发","count":2,"path":"api/tags/网站开发.json"},{"name":"网站维护","slug":"网站维护","count":2,"path":"api/tags/网站维护.json"},{"name":"图床","slug":"图床","count":1,"path":"api/tags/图床.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"喜欢前沿科技，想要见证人类科学的飞跃","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}}}