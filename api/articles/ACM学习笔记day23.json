{"title":"ACM学习笔记day23(欧拉函数，筛法求欧拉函数，快速幂，快速幂求逆元)","uid":"ead55ceebbb5da582503c01cc4b636b6","slug":"ACM学习笔记day23","date":"2023-01-24T13:07:47.000Z","updated":"2023-04-08T10:52:11.128Z","comments":true,"path":"api/articles/ACM学习笔记day23.json","keywords":null,"cover":"/img/codeforces.jpg","content":"<p>今天的内容是欧拉函数和快速幂，主要是这两个。<br>其中最后那个逆元，emm感觉好难理解QAQ</p>\n<span id=\"more\"></span>\n\n<h1 id=\"欧拉函数\"><a href=\"#欧拉函数\" class=\"headerlink\" title=\"欧拉函数\"></a><a href=\"https://www.acwing.com/problem/content/875/\">欧拉函数</a></h1><p>欧拉函数的定义：</p>\n<p><img src=\"https://raw.githubusercontent.com/AusertDream/MyblogImags/main/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0.png\" alt=\"Euler function\"></p>\n<p>由定义我们容易得出，对于求一个数字N的欧拉函数的值，我们按照定义来就可以了。<br>时间复杂度是O(sqrt(N))。因为分解质因数要根号n，然后乘法乘上去也是根号n。<br>所以时间复杂度是这样的。<br>关于这个公式的证明其实是一个容斥原理。<br>我们知道N有k个质因数，那么这k个质因数的次幂肯定和N不是互质的对吧。<br>那么我们就要删掉这些个东西，比如他的有一个质因数p1，那么我们就要删掉N&#x2F;p1个数字。<br>N&#x2F;p1就代表了，p1*1,p1*2….这些有几个了。<br>其他的依次类推。<br>那么,就变成了 </p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>N - N&#x2F;p1-N&#x2F;p2-N&#x2F;p3….<br>但是也有可能什么呢？<br>有的因数啊，他的质因数里面既包括p1又包括p2那样的话我们就多删了这个数字一次，所以我们要加上去这个。<br>那么就变成了<br>N - N&#x2F;p1-N&#x2F;p2-N&#x2F;p3….+N&#x2F;p1*p2+N&#x2F;p1*p3+….N&#x2F;*p(k-1)*pk…<br>这里我们可能又多加了p1,p2,p3交集的部分，所以我们又要删掉他。<br>…….<br>以此类推，会们会得到一个形式上很类似上面的循环的表达式，而这个表达式化简下来就是公式定义里面的式子。<br>知道了定义之后，那么我么再来求欧拉函数的值就好多了。<br>就分两步。</p></blockquote>\n<ol>\n<li>一个是分解质因数。</li>\n<li>计算欧拉函数的值。<br>下面为代码:<pre class=\"line-numbers language-none\"><code class=\"language-none\">#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nint n;\n\n\n\nint main()&#123;\n    cin&gt;&gt;n;\n    while(n--)&#123;\n        int x;\n        cin&gt;&gt;x;\n        int res&#x3D;x;\n        for(int i&#x3D;2;i&lt;&#x3D;x&#x2F;i;i++)&#123;\n            if(x%i&#x3D;&#x3D;0)&#123;\n                res&#x3D;res&#x2F;i*(i-1);\n                while(x%i&#x3D;&#x3D;0) x&#x2F;&#x3D;i;\n            &#125;\n        &#125;\n        if(x&gt;1)&#123;\n            res&#x3D;res&#x2F;x*(x-1);\n        &#125;\n        cout&lt;&lt;res&lt;&lt;endl;\n    &#125;\n    return 0;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ol>\n<h1 id=\"筛法求欧拉函数\"><a href=\"#筛法求欧拉函数\" class=\"headerlink\" title=\"筛法求欧拉函数\"></a><a href=\"https://www.acwing.com/problem/content/876/\">筛法求欧拉函数</a></h1><p>如果要求某一个数的欧拉函数的值，那我们用上面的公式来做，完全可以了。<br>但是如果我们要求1到某一个数的欧拉函数的值，那么用上面那个方法来做，会是n*sqrt(n)的时间复杂度，会非常的慢。<br>那么这里我们就可以借助欧拉筛来解决这个问题。<br>我们一边在用线性筛的同时，处理我们所需的欧拉函数的结果，这样我们可以在O(n)的时间内，解决这个问题。<br>既然要用到线性筛，那么我们肯定先把线性山的板子先写一下对吧。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">typedef long long ll;\nconst int N &#x3D; 1e6+10;\nint n;\nbool flag[N];\nvector&lt;int&gt; primes;\n\nll geteulers(int n)&#123;\n    for(int i&#x3D;2;i&lt;&#x3D;n;i++)&#123;\n        if(!flag[i])&#123;\n            primes.push_back(i);\n        &#125;\n        for(int j&#x3D;0;primes[j]*i&lt;&#x3D;n;j++)&#123;\n            flag[primes[j]*i]&#x3D;true;\n            if(i%primes[j]&#x3D;&#x3D;0)&#123;\n                break;\n            &#125;\n        &#125;\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>如上，是个线性筛的板子。<br>那么我们这里要额外动用一个数组，phi[N]。<br>phi[i]表示数字i的欧拉函数的值。<br>我们求完phi数组，最后直接对这个数组求和就是最终的结果了。<br>这里我们在做线性筛的时候，我们可以一并进行phi[i]的求解。<br>分三种情况讨论。我们要处理的就是三种数字，质数的欧拉函数值，线性筛中，通过质数筛掉的数字的欧拉函数的值。<br>其中又可以分为两种，如下：</p>\n<h3 id=\"1-如果i正好是质数。\"><a href=\"#1-如果i正好是质数。\" class=\"headerlink\" title=\"1. 如果i正好是质数。\"></a>1. 如果i正好是质数。</h3><pre><code>那么很显然，前面的i-1个数字全是和他互质的，他的欧拉函数的值就是i-1.\n证明也很好证，因为质数的定义就是他的约数只有1和他本身，如果前面有数字和i有相同的除1以外的约数的话，那么就不满足质数的定义了。\n</code></pre>\n<h3 id=\"2-如果i-primes-j-x3D-x3D-0\"><a href=\"#2-如果i-primes-j-x3D-x3D-0\" class=\"headerlink\" title=\"2. 如果i%primes[j]&#x3D;&#x3D;0\"></a>2. 如果i%primes[j]&#x3D;&#x3D;0</h3><pre><code>这种情况下，我们要求primes[j]*i的欧拉函数值，因为primes[j]已经是i的因数的，所以如果把i分解质因数，质因数的个数不会变，改变的只会是某个质因数的次幂。而我们从欧拉函数的公式上来看，这样的话是不会改变欧拉函数的值的。那么我么可以得以下的公式。\nprimes[j]用pj简写。\n</code></pre>\n<p><img src=\"https://raw.githubusercontent.com/AusertDream/MyblogImags/main/1.png\" alt=\"1\"></p>\n<p>也就是说phi[primes[j]*i]&#x3D;primes[j]*phi[i];</p>\n<h3 id=\"3-如果i-primes-j-x3D-0\"><a href=\"#3-如果i-primes-j-x3D-0\" class=\"headerlink\" title=\"3. 如果i%primes[j]!&#x3D;0\"></a>3. 如果i%primes[j]!&#x3D;0</h3><pre><code>这里就说明primes[j]不是他的质因数对吧，那么相应的，公式中就要多加一下pj的项，其他不变，那么我们就可以得到下面的公式。\n</code></pre>\n<p><img src=\"https://raw.githubusercontent.com/AusertDream/MyblogImags/main/2.png\" alt=\"2\"></p>\n<p>也就是说phi[primes[j]*i]&#x3D;phi[i]*(primes[j]-1);</p>\n<p>那么我们这里，一开始的时候要初始化一下phi[1]&#x3D;1，根据维基和google上的定义，我们规定1和1是算是互质的。<br>那么代码如下:</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nvector&lt;int&gt; primes;\ntypedef long long ll;\nconst int N &#x3D; 1e6+10;\nint phi[N];\nbool flag[N];\n\nll getprimes(int n)&#123;\n    phi[1]&#x3D;1;\n    for(int i&#x3D;2;i&lt;&#x3D;n;i++)&#123;\n        if(!flag[i])&#123;\n            primes.push_back(i);\n            phi[i]&#x3D;i-1;\n        &#125;\n        for(int j&#x3D;0;primes[j]*i&lt;&#x3D;n;j++)&#123;\n            flag[primes[j]*i]&#x3D;true;\n            if(i%primes[j]&#x3D;&#x3D;0)&#123;\n                phi[primes[j]*i]&#x3D;primes[j]*phi[i];\n                break;\n            &#125;\n            phi[primes[j]*i]&#x3D;(primes[j]-1)*phi[i];\n        &#125;\n    &#125; \n    ll res&#x3D;0;\n    for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;\n        res+&#x3D;phi[i];\n    &#125;\n    return res;\n&#125;\n\nint main()&#123;\n    int n;\n    cin&gt;&gt;n;\n    cout&lt;&lt;getprimes(n)&lt;&lt;endl;\n    return 0;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h1 id=\"快速幂\"><a href=\"#快速幂\" class=\"headerlink\" title=\"快速幂\"></a><a href=\"https://www.acwing.com/problem/content/877/\">快速幂</a></h1><p>快速幂这个东西，顾名思义。<br>就是能够快速的求出一个数的次幂是多少。<br>比如我们要求a^b是多少，如果朴素做法的话就是，一个一个乘过去。<br>这样我们的时间就是O(b）,很明显，太慢了。<br>我们使用快速幂的话，我们就能够在logb的时间内求出来结果。<br>好，那我们来看一下快速幂是怎么求的。<br>我们要求a^b,我们先把下面的东西求出来:</p>\n<p><img src=\"https://raw.githubusercontent.com/AusertDream/MyblogImags/main/3.png\" alt=\"3\"></p>\n<p>注意，这里这个东西的求法也是有讲究的，我们发现一个数字就等于他前面那个数字的平方，所以我们每次求某个数字的时候，他的值就是他前面那个数字的平方。<br>然后利用这个来求a^b。<br>那么怎么求呢？<br>其实快速幂的原理，就是将幂用二进制来表示，比如5&#x3D;(101)_2,那么5就可以表示为5&#x3D;2^2+2^0,对应的到次幂的话，就是对应的底数<br>相乘就是了。如图：</p>\n<p><img src=\"https://raw.githubusercontent.com/AusertDream/MyblogImags/main/4.png\" alt=\"4\"></p>\n<p>我们发现最终的表达式中我们要的值是之前求过的，这也就是为什么我们要提前算一下a的各个2的次幂的次幂的值。<br>当然在实际过程中不需要预先算好，我们只要一步一步拆解b，然后推进的同时更新我们的数值就可以了。<br>以下为代码：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\n\nll  qmi(ll a,ll b,ll p)&#123;\n    ll ans&#x3D;1;\n    while(b)&#123; &#x2F;&#x2F;一直到b为零为止\n        if(b&amp;1)&#123; &#x2F;&#x2F;如果b的最后一位是1的话，那么就相当于要乘一个值的。\n            ans&#x3D;ans*a%p; &#x2F;&#x2F;这里这个a就是不断更新的a平方的次幂的值。\n        &#125;\n        a&#x3D;a*a%p; &#x2F;&#x2F;更新a，根据上面的结论，后一个数字的值就是前面数字的平方，当然，要记得取模。\n        b&gt;&gt;&#x3D;1; &#x2F;&#x2F;b右移一位。\n    &#125;\n    &#x2F;&#x2F;相当于，这里我们用a作为那个我们要乘的数字，不断更新a。使得算法大大的简化了。\n    return ans;\n&#125;\nint main()&#123;\n    int n;\n    cin&gt;&gt;n;\n    while(n--)&#123;\n        ll a,b,p;\n        cin&gt;&gt;a&gt;&gt;b&gt;&gt;p;\n        cout&lt;&lt;qmi(a,b,p)&lt;&lt;endl;\n    &#125;\n    return 0;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n<h1 id=\"快速幂求逆元\"><a href=\"#快速幂求逆元\" class=\"headerlink\" title=\"快速幂求逆元\"></a><a href=\"https://www.acwing.com/problem/content/878/\">快速幂求逆元</a></h1><p>这题主要是利用快速幂去求逆元的。<br>题目上是让你求逆元，但是运用到了一个结论，然后就转化为了用快速幂去求逆元的题目了。<br>逆元定义如下：</p>\n<p><img src=\"https://raw.githubusercontent.com/AusertDream/MyblogImags/main/5.png\" alt=\"5\"></p>\n<p>额，这个鸟定义七绕八拐的，真不太懂，不过感觉有点离散的味道，这个逆元。<br>反正就是当b和m互质的时候，对于任意的能够让b整除的a，存在一个x，<br>使得 a&#x2F;b&#x3D;a*x(同余m)，这个x就叫做b的模m乘法逆元，记作b^-1(mod m);<br>其中b必须和m互质，不然的话b是不存在乘法逆元的。<br>然后这题的话，用到了一个定理。就是上面写的，当m为质数的时候，b^(m-2)就是b的乘法逆元。<br>因为题目给的模p一定是质数，所以我们就把这个问题转化为了求b^(m-2)的值就是了。<br>当然要判断一下b和m是不是互质的，如果不是的话，是不存在逆元的。 </p>\n<p>代码如下：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\nll qmi(ll a,ll b,ll p)&#123;\n    ll res&#x3D;1;\n    while(b)&#123;\n        if(b&amp;1)&#123;\n            res&#x3D;res*a%p;\n        &#125;\n        a&#x3D;a*a%p;\n        b&gt;&gt;&#x3D;1;\n    &#125;\n    return res;\n&#125;\nint mygcd(ll a,ll b)&#123;\n    if(b&#x3D;&#x3D;0) return a;\n    else return mygcd(b,a%b);\n&#125;\n\n\nint main()&#123;\n    int n;\n    cin&gt;&gt;n;\n    while(n--)&#123;\n        int a,p;\n        cin&gt;&gt;a&gt;&gt;p;\n        if(mygcd(a,p)!&#x3D;1)&#123;\n            cout&lt;&lt;&quot;impossible&quot;&lt;&lt;endl;\n        &#125;\n        else&#123;\n            cout&lt;&lt;qmi(a,p-2,p)&lt;&lt;endl;\n        &#125;\n    &#125;\n    return 0;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n<p>好了，那么今天的内容，额，写这个写了两天了，就到这里了。<br>我们下次再见捏<br>Bye~</p>\n","text":"今天的内容是欧拉函数和快速幂，主要是这两个。其中最后那个逆元，emm感觉好难理解QAQ 欧拉函数欧拉函数的定义： 由定义我们容易得出，对于求一个数字N的欧拉函数的值，我们按照定义来就可以了。时间复杂度是O(sqrt(N))。因为分解质因数要根号n，然后乘法乘上去也是根号n。所以时...","link":"","photos":[],"count_time":{"symbolsCount":"5.8k","symbolsTime":"5 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"学习","slug":"学习","count":42,"path":"api/tags/学习.json"},{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"ACM","slug":"ACM","count":39,"path":"api/tags/ACM.json"},{"name":"数论","slug":"数论","count":5,"path":"api/tags/数论.json"},{"name":"数学","slug":"数学","count":7,"path":"api/tags/数学.json"},{"name":"快速幂","slug":"快速幂","count":1,"path":"api/tags/快速幂.json"},{"name":"欧拉函数","slug":"欧拉函数","count":1,"path":"api/tags/欧拉函数.json"},{"name":"逆元","slug":"逆元","count":1,"path":"api/tags/逆元.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">欧拉函数</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%AD%9B%E6%B3%95%E6%B1%82%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">筛法求欧拉函数</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E5%A6%82%E6%9E%9Ci%E6%AD%A3%E5%A5%BD%E6%98%AF%E8%B4%A8%E6%95%B0%E3%80%82\"><span class=\"toc-text\">1. 如果i正好是质数。</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E5%A6%82%E6%9E%9Ci-primes-j-x3D-x3D-0\"><span class=\"toc-text\">2. 如果i%primes[j]&#x3D;&#x3D;0</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E5%A6%82%E6%9E%9Ci-primes-j-x3D-0\"><span class=\"toc-text\">3. 如果i%primes[j]!&#x3D;0</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%BF%AB%E9%80%9F%E5%B9%82\"><span class=\"toc-text\">快速幂</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%BF%AB%E9%80%9F%E5%B9%82%E6%B1%82%E9%80%86%E5%85%83\"><span class=\"toc-text\">快速幂求逆元</span></a></li></ol>","author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"喜欢前沿科技，想要见证人类科学的飞跃","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}},"mapped":true,"prev_post":{"title":"ACM学习笔记day24(扩展欧几里得算法，线性同余方程，中国剩余定理)","uid":"e8f352fc1ae41c272b21fc150a45992f","slug":"ACM学习笔记day24","date":"2023-02-02T14:25:04.000Z","updated":"2023-04-08T10:52:17.703Z","comments":true,"path":"api/articles/ACM学习笔记day24.json","keywords":null,"cover":"/img/codeforces.jpg","text":"emm，好像距离上次写博客好像是很久以前了呢(懒狗，摆烂王是吧)话不多说，直接进入正题，今天的内容是扩展欧几里得算法和CRT，也就是中国剩余定理，或者也叫孙子定理。 扩展欧几里得算法这个算法其实和欧几里得算法很像，都是用到了辗转相除法。只不过在辗转相除的同时，一边算了一个GCD，...","link":"","photos":[],"count_time":{"symbolsCount":"4.1k","symbolsTime":"4 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"学习","slug":"学习","count":42,"path":"api/tags/学习.json"},{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"蒟蒻","slug":"蒟蒻","count":4,"path":"api/tags/蒟蒻.json"},{"name":"数论","slug":"数论","count":5,"path":"api/tags/数论.json"},{"name":"扩展欧几里得","slug":"扩展欧几里得","count":1,"path":"api/tags/扩展欧几里得.json"},{"name":"CRT","slug":"CRT","count":1,"path":"api/tags/CRT.json"},{"name":"中国剩余定理","slug":"中国剩余定理","count":1,"path":"api/tags/中国剩余定理.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"喜欢前沿科技，想要见证人类科学的飞跃","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}},"next_post":{"title":"ACM学习笔记day22 (约数个数，约数之和，最大公约数)","uid":"3438dc43ca9a9de9df433abe2e751c9e","slug":"ACM学习笔记day22","date":"2023-01-23T13:17:12.000Z","updated":"2023-04-08T10:52:01.459Z","comments":true,"path":"api/articles/ACM学习笔记day22.json","keywords":null,"cover":"/img/codeforces.jpg","text":"浅过了个年，差不多了，应该回来念书了XD今天的内容是约数个数，约数之和，最大公约数。 约数个数,约数之和对于这个问题，其实就是两个公式。具体的证明，可以自寻资料查看。这里仅给出结果，和我自己的理解。严格的数学证明我们不多赘述。以下为公式(图中pi为N的质因数)： 好，公式我们给出...","link":"","photos":[],"count_time":{"symbolsCount":"3.2k","symbolsTime":"3 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"学习","slug":"学习","count":42,"path":"api/tags/学习.json"},{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"ACM","slug":"ACM","count":39,"path":"api/tags/ACM.json"},{"name":"数论","slug":"数论","count":5,"path":"api/tags/数论.json"},{"name":"约数","slug":"约数","count":2,"path":"api/tags/约数.json"},{"name":"公式","slug":"公式","count":1,"path":"api/tags/公式.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"喜欢前沿科技，想要见证人类科学的飞跃","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}}}