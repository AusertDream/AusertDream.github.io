{"title":"ACM学习笔记day39(树状数组)","uid":"7710f88b0aefcb65b0ee353b8ff291a3","slug":"ACM学习笔记day39","date":"2023-07-18T14:56:43.000Z","updated":"2023-08-25T14:17:44.654Z","comments":true,"path":"api/articles/ACM学习笔记day39.json","keywords":null,"cover":"/img/codeforces.jpg","content":"<p>树状数组的板子。</p>\n<p>有几个小结论需要记住。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><ol>\n<li>每个结点t[x]保存以x为根的子树中叶结点值的和</li>\n<li>每个结点覆盖的长度为lowbit(x)</li>\n<li>t[x]结点的父结点为t[x + lowbit(x)]</li>\n<li>树的深度为log2n+1</li>\n</ol></blockquote>\n<p>理解树状数组的图为:</p>\n<p><img src=\"https://cdn.acwing.com/media/article/image/2020/05/28/9584_251f95d4a0-%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84-%E7%BB%93%E7%82%B9%E8%A6%86%E7%9B%96%E7%9A%84%E9%95%BF%E5%BA%A6.png\"></p>\n<p>lowbit操作：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">\nint lowbit(int x)&#123;\n\treturn x &amp; -x;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>add操作（其实也就是modity操作)：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">\nvoid add(int x, int d)&#123;\n\tfor(int i&#x3D;x;i&lt;&#x3D;n;i+&#x3D;lowbit(i))&#123;\n\t\ttree[i]+&#x3D;d;\n\t&#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>query操作（查询从第一个到第x个所有的前缀和是多少）：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">\nint query(int x)&#123;\n\tint res&#x3D;0;\n\tfor(int i&#x3D;x;i;i-&#x3D;lowbit(i))&#123;\n\t\tres+&#x3D;tree[i];\n\t&#125;\n\treturn res;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>树状数组就这两个操作，一个查询，一个修改里面数值，时间复杂度都是logn级别的。</p>\n","feature":true,"text":"树状数组的板子。 有几个小结论需要记住。 每个结点t[x]保存以x为根的子树中叶结点值的和 每个结点覆盖的长度为lowbit(x) t[x]结点的父结点为t[x + lowbit(x)] 树的深度为log2n+1 理解树状数组的图为: lowbit操作： int lowbit(i...","link":"","photos":[],"count_time":{"symbolsCount":543,"symbolsTime":"1 mins."},"categories":[{"name":"ACM","slug":"ACM","count":40,"path":"api/categories/ACM.json"}],"tags":[{"name":"数据结构","slug":"数据结构","count":21,"path":"api/tags/数据结构.json"},{"name":"binary index tree","slug":"binary-index-tree","count":1,"path":"api/tags/binary-index-tree.json"},{"name":"树状数组","slug":"树状数组","count":1,"path":"api/tags/树状数组.json"}],"toc":"","author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"喜欢前沿科技，想要见证人类科学的飞跃","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}},"mapped":true,"prev_post":{"title":"扩展欧几里得2（exgcd的最小正整数解，通解）","uid":"f37560f9bc1b5fea2432f5534d910cca","slug":"扩展欧几里得2","date":"2023-07-19T13:53:28.000Z","updated":"2023-08-25T14:16:32.938Z","comments":true,"path":"api/articles/扩展欧几里得2.json","keywords":null,"cover":"/img/codeforces.jpg","text":"由exgcd我们可以得到如下式子的一对解，前提是有解。ax+by&#x3D;c; (c%gcd(a,b)&#x3D;&#x3D;0)设一组解为x1,y1;即ax1+by1&#x3D;c; 记 u &#x3D; a*b&#x2F;gcd(a,b); 通解为:x&#x3D;x1+u&...","link":"","photos":[],"count_time":{"symbolsCount":398,"symbolsTime":"1 mins."},"categories":[{"name":"ACM","slug":"ACM","count":40,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":37,"path":"api/tags/ACM.json"},{"name":"exgcd","slug":"exgcd","count":1,"path":"api/tags/exgcd.json"},{"name":"最小正整数解","slug":"最小正整数解","count":1,"path":"api/tags/最小正整数解.json"},{"name":"通解","slug":"通解","count":1,"path":"api/tags/通解.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"喜欢前沿科技，想要见证人类科学的飞跃","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}},"feature":true},"next_post":{"title":"ACM学习笔记day38(最小生成树,染色法判定二分图，匈牙利算法)","uid":"aade77e076015616546b7ec40503f52f","slug":"ACM学习笔记day38","date":"2023-03-25T12:51:23.000Z","updated":"2023-08-25T14:17:28.624Z","comments":true,"path":"api/articles/ACM学习笔记day38.json","keywords":null,"cover":"/img/codeforces.jpg","text":"在总结了各种的最短路算法之后，我们终于也是迎来了，图论基础算法的最后一部分内容。一个是最小生成树的求法。一个是有关二分图的问题。 关于这部分的内容，可以看下面这个大致的思维导图。 最小生成树对于基础的图论。最小生成树一共有两种算法。一种是prim算法，一种就是kruskal算法。...","link":"","photos":[],"count_time":{"symbolsCount":"9.4k","symbolsTime":"9 mins."},"categories":[{"name":"ACM","slug":"ACM","count":40,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":37,"path":"api/tags/ACM.json"},{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"Prim","slug":"Prim","count":1,"path":"api/tags/Prim.json"},{"name":"Kruskal","slug":"Kruskal","count":1,"path":"api/tags/Kruskal.json"},{"name":"染色法","slug":"染色法","count":1,"path":"api/tags/染色法.json"},{"name":"二分图","slug":"二分图","count":1,"path":"api/tags/二分图.json"},{"name":"匈牙利算法","slug":"匈牙利算法","count":1,"path":"api/tags/匈牙利算法.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"喜欢前沿科技，想要见证人类科学的飞跃","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}},"feature":true}}