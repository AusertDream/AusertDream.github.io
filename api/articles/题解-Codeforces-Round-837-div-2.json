{"title":"题解-Codeforces-Round-837-div-2","uid":"8939638ff3772e749e6b91f98033c73a","slug":"题解-Codeforces-Round-837-div-2","date":"2022-12-12T11:57:48.000Z","updated":"2023-08-27T09:17:27.684Z","comments":true,"path":"api/articles/题解-Codeforces-Round-837-div-2.json","keywords":null,"cover":"/img/二次元の图/1.jpg","content":"<p>蒟蒻又日常来尝试div2了，这次独立（额，算独立吗）做出来的只有A，B还是问了别人才做出来的，接下里的这个就是B的题解。<br>下面这个做法真的十分的优雅。<br>代码很简洁，思路也很清楚。</p>\n<p><img src=\"https://raw.githubusercontent.com/AusertDream/MyblogImags/main/1.jpg\" alt=\"1\"></p>\n<span id=\"more\"></span>\n\n<p>B-Hossam and Friends</p>\n<p><a href=\"https://codeforces.com/contest/1771/problem/B\">题目链接</a></p>\n<h2 id=\"题目描述：\"><a href=\"#题目描述：\" class=\"headerlink\" title=\"题目描述：\"></a>题目描述：</h2><p>一个人有n个朋友，按照1,2,3,4…，n的顺序。<br>现在他有m对数据，里面的每对数据表示这两个人互相不认识。<br>定义good segment：以l为左边界，r为右边界的一个segment(包括l和r)，如果里面的每个人都互相认识，那么我们就认为他是一个good segment<br>问你，这n个人中有多少个good segment。</p>\n<h2 id=\"题目思路：\"><a href=\"#题目思路：\" class=\"headerlink\" title=\"题目思路：\"></a>题目思路：</h2><p>这里呢，我们使用到了一个数组a，这个数组存放的不是1,2,3,4….这些朋友。<br>这个数组的含义，就是这个解法最妙的地方。<br>a[i]表示以左边界i的最大右边界+1。<br>什么意思呢，就比如说a[2]&#x3D;5，就说明2~4这些人是互相认识的。<br>所以我们对于m次输入的x和y，表示x和y不认识，为了能够方便维护我们的数组<br>如果x&gt;y就让x和y swap一下。<br>然后让a[x]&#x3D;min(a[x],y)即可，就这样维护了a[x]新的右边界，当然要去min值，因为有可能给的这个y是大于原来的那个的。<br>然后我们要继续维护一下这个a数组。<br>为什么呢？我们来看下面这一种特殊的情况。<br>我们得到如下的a数组</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>a[i]: 1 2 3 4 5 6 7 8 9 100 99 65 43 65 47 100 ……<br>下标: 1 2 3 4 5 6 7 8 9 10  11 12 13 14 15  16</p></blockquote>\n<p>不难发现，我们对于第12个人来说，最大good segment的右边界是65-1,但是第11个人的右边界却是99<br>65和12都不认识，那11~98这个区间里面，肯定是有人不认识的，也就不可能是good segment。<br>所以我们要根据他右边的那个数来更新自己。<br>因为a[i]表示的值是最大右边界嘛。<br>同时要注意，更新的时候必须从右边开始更新，而不是左边<br>试想一下，对于10 11 12这三个数字，更新完之后，显然应该是43 43 43<br>但是如果从左边更新的话，就会变成99 65 43<br>显然这样是不对的。<br>理由也很简单，因为a[i]的值是右边界的最大值，每一个a[i]的值是否正确，都是依托于他右边的值的，所有我们要从右边开始更新<br>确保每次更新都是正确的。<br>更新完之后，我们让ans+&#x3D;每一个a[i]-i即可，也就是以i为边界的最长good segment的长度。<br>下面为代码实现：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">#include&lt;bits&#x2F;stdc++.h&gt;\t\nusing namespace std;\t\nconstexpr int INF &#x3D; 2100000000;\ntypedef long long ll;\t\ntypedef unsigned long long ULL;\nconstexpr ll INF64 &#x3D; 1e18;\nconst int N &#x3D; 100003;\t\ntypedef pair&lt;int, int&gt; PII;\n#define mysort(a) sort(a.begin(),a.end());\n#define mysort(a,n) sort(a,a+n);\nint n, m;\nint a[N];\n\nvoid solve() &#123;\n\tcin &gt;&gt; n &gt;&gt; m;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;\n\t\ta[i] &#x3D; n + 1;\n\t&#125;\n\twhile (m--) &#123;\n\t\tint x, y;\n\t\tcin &gt;&gt; x &gt;&gt; y;\n\t\tif (x &gt; y) &#123;\n\t\t\tswap(x, y);\n\t\t&#125;\n\t\ta[x] &#x3D; min(a[x], y);\n\t&#125;\n\tfor (int i &#x3D; n - 1; i &gt;&#x3D; 1; i--) &#123;\n\t\ta[i] &#x3D; min(a[i], a[i + 1]);\n\t&#125;\n\tll ans &#x3D; 0;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;\n\t\tans +&#x3D; a[i] - i;\n\t&#125;\n\tcout &lt;&lt; ans &lt;&lt; endl;\n\n&#125;\n\t\t\t\t\t\t\n\n\t\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t\t\nint main()\n&#123;\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\t\t\t\t\t \n\tint t;\t\t\t\t\t\n\tcin &gt;&gt; t;\t\t\t\t\n\twhile (t--)\t\t\t\t\n\t&#123;\t\t\t\t\t\t\n\t\tsolve();\t\t\t\n\t&#125;\t\t\t\t\t\t\n\treturn 0;\n&#125;\t\t<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>先这样吧，如果后面的C我干出来了，或者是有很优美的算法解决问题的话，我也会更新在博客里面。<br>Bye~</p>\n","text":"蒟蒻又日常来尝试div2了，这次独立（额，算独立吗）做出来的只有A，B还是问了别人才做出来的，接下里的这个就是B的题解。下面这个做法真的十分的优雅。代码很简洁，思路也很清楚。 B-Hossam and Friends 题目链接 题目描述：一个人有n个朋友，按照1,2,3,4…，n...","link":"","photos":[],"count_time":{"symbolsCount":"2.2k","symbolsTime":"2 mins."},"categories":[{"name":"题解","slug":"题解","count":1,"path":"api/categories/题解.json"}],"tags":[{"name":"学习","slug":"学习","count":42,"path":"api/tags/学习.json"},{"name":"ACM","slug":"ACM","count":39,"path":"api/tags/ACM.json"},{"name":"数据结构","slug":"数据结构","count":23,"path":"api/tags/数据结构.json"},{"name":"算法","slug":"算法","count":20,"path":"api/tags/算法.json"},{"name":"codeforces","slug":"codeforces","count":1,"path":"api/tags/codeforces.json"},{"name":"题解","slug":"题解","count":1,"path":"api/tags/题解.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%EF%BC%9A\"><span class=\"toc-text\">题目描述：</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%A2%98%E7%9B%AE%E6%80%9D%E8%B7%AF%EF%BC%9A\"><span class=\"toc-text\">题目思路：</span></a></li></ol>","author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"喜欢前沿科技，想要见证人类科学的飞跃","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}},"mapped":true,"prev_post":{"title":"ACM学习笔记day20(走迷宫bfs)","uid":"955da31dc34cc48d9fa1d8587dc420ff","slug":"ACM学习笔记day20","date":"2022-12-16T13:50:22.000Z","updated":"2023-04-08T10:51:47.380Z","comments":true,"path":"api/articles/ACM学习笔记day20.json","keywords":null,"cover":"/img/codeforces.jpg","text":"hello guys！今天的内容是走迷宫。额，好像叕好久没有更新博客了。呃呃呃。好像确实有点摆（是非常吧。好的，我们来看问题。 走迷宫问题，这个不多说，啥意思很容易理解题源：acwing;所用的思想就是bfs算法。bfs算法其实是有一个固定的算法模板的。 while(queue非...","link":"","photos":[],"count_time":{"symbolsCount":"1.9k","symbolsTime":"2 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"学习","slug":"学习","count":42,"path":"api/tags/学习.json"},{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"ACM","slug":"ACM","count":39,"path":"api/tags/ACM.json"},{"name":"数据结构","slug":"数据结构","count":23,"path":"api/tags/数据结构.json"},{"name":"算法","slug":"算法","count":20,"path":"api/tags/算法.json"},{"name":"bfs","slug":"bfs","count":3,"path":"api/tags/bfs.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"喜欢前沿科技，想要见证人类科学的飞跃","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}},"next_post":{"title":"ACM学习笔记day19(N皇后问题-2种dfs解法)","uid":"983fdf7c1cf56eb82d4bc470facb21cc","slug":"ACM学习笔记day19","date":"2022-12-11T14:48:21.000Z","updated":"2023-04-08T10:51:37.675Z","comments":true,"path":"api/articles/ACM学习笔记day19.json","keywords":null,"cover":"/img/codeforces.jpg","text":"今天的内容是N皇后问题，有两种dfs方法，但是自己在写的时候还是碰到了不少问题的。 第一种dfs方法这种dfs方法，是基于我们已经知道了，每一行每一列每一主对角线和副对角线上只能有一个皇后。思想和数字的全排列差不多。我们dfs第零行到第n-1行，然后枚举第零列到第n-1列，如果有...","link":"","photos":[],"count_time":{"symbolsCount":"3.4k","symbolsTime":"3 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"学习","slug":"学习","count":42,"path":"api/tags/学习.json"},{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"ACM","slug":"ACM","count":39,"path":"api/tags/ACM.json"},{"name":"数据结构","slug":"数据结构","count":23,"path":"api/tags/数据结构.json"},{"name":"算法","slug":"算法","count":20,"path":"api/tags/算法.json"},{"name":"dfs","slug":"dfs","count":4,"path":"api/tags/dfs.json"},{"name":"N皇后","slug":"N皇后","count":1,"path":"api/tags/N皇后.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"喜欢前沿科技，想要见证人类科学的飞跃","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}}}