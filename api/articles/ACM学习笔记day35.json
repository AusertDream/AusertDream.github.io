{"title":"ACM学习笔记day35(拓扑序列)","uid":"f4b8c236f24c3289ca5c3e33420c6ba4","slug":"ACM学习笔记day35","date":"2023-03-21T14:49:38.000Z","updated":"2023-04-08T10:54:07.183Z","comments":true,"path":"api/articles/ACM学习笔记day35.json","keywords":null,"cover":"/img/codeforces.jpg","content":"<p>今天的内容是拓扑排序。</p>\n<span id=\"more\"></span>\n\n\n<p>若一个由图中所有点构成的序列A满足：对于图中的每条边 (x,y) x 在 A 中都出现在 y 之前，则称 A 是该图的一个拓扑序列。<br>注意：图的拓扑序并不一定唯一<br>所以<a href=\"https://www.acwing.com/problem/content/850/\">题目</a>的答案并不唯一。</p>\n<p>那么我们应该怎么去求拓扑序列呢？<br>很显然，我们从定义出发，我们需要保证序列中的一个点，一定出现在他后面的点之前。<br>那我们就可以这样子来选择出来一条拓扑序列。<br>我们每次选择入度为零的点，将其放入我们的拓扑序列中去，然后将这个点删掉，同时将相关的边也删掉。<br>重复这个过程直到所有点都被删掉。<br>那么我们实际实现的时候，我们就需要额外记录一下每一个节点的入度。<br>然后每次选择入度为零的，并且没有被选过的点，放入拓扑序列中去就可以了。<br>然后更新这个点所有的领接点的入度就可以了。</p>\n<p>下面为ac code：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nconst int N &#x3D; 1e5+10;\nint e[N],ne[N],h[N],idx;\nint d[N];\nbool st[N];\nvector&lt;int&gt; res;\nint n,m;\n\nvoid add(int a,int b)&#123;\n    e[idx]&#x3D;b,ne[idx]&#x3D;h[a],h[a]&#x3D;idx++;\n&#125;\n\nbool topsort()&#123;\n    queue&lt;int&gt; work;\n    for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;\n        if(d[i]&#x3D;&#x3D;0)&#123;\n            work.push(i);\n            st[i]&#x3D;true;\n        &#125;\n    &#125;\n    while(work.size())&#123;\n        int t &#x3D;work.front();\n        work.pop();\n        for(int i&#x3D;h[t];i!&#x3D;-1;i&#x3D;ne[i])&#123;\n            int j&#x3D;e[i];\n            d[j]--;\n            if(d[j]&#x3D;&#x3D;0&amp;&amp;!st[j])&#123;\n                work.push(j);\n            &#125;\n        &#125;\n        res.push_back(t);\n    &#125;\n    if(res.size()&#x3D;&#x3D;n)&#123;\n        return true;\n    &#125;\n    else&#123;\n        return false;\n    &#125;\n&#125;\nint main()&#123;\n    cin&gt;&gt;n&gt;&gt;m;\n    memset(h,-1,sizeof h);\n    for(int i&#x3D;0;i&lt;m;i++)&#123;\n        int a,b;\n        cin&gt;&gt;a&gt;&gt;b;\n        add(a,b);\n        d[b]++;\n    &#125;\n    if(topsort())&#123;\n        for(int i&#x3D;0;i&lt;n;i++)&#123;\n            cout&lt;&lt;res[i]&lt;&lt;&#39; &#39;;\n        &#125;\n        cout&lt;&lt;endl;\n    &#125;\n    else&#123;\n        cout&lt;&lt;-1&lt;&lt;endl;\n    &#125;\n    \n    return 0;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n<p>好的，那么这里就是拓扑排序的全部内容了。<br>我么下次再见。</p>\n","text":"今天的内容是拓扑排序。 若一个由图中所有点构成的序列A满足：对于图中的每条边 (x,y) x 在 A 中都出现在 y 之前，则称 A 是该图的一个拓扑序列。注意：图的拓扑序并不一定唯一所以题目的答案并不唯一。 那么我们应该怎么去求拓扑序列呢？很显然，我们从定义出发，我们需要保证序...","link":"","photos":[],"count_time":{"symbolsCount":"1.8k","symbolsTime":"2 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":39,"path":"api/tags/ACM.json"},{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"学习","slug":"学习","count":42,"path":"api/tags/学习.json"},{"name":"图论","slug":"图论","count":3,"path":"api/tags/图论.json"},{"name":"dfs","slug":"dfs","count":4,"path":"api/tags/dfs.json"},{"name":"bfs","slug":"bfs","count":3,"path":"api/tags/bfs.json"},{"name":"拓扑排序","slug":"拓扑排序","count":1,"path":"api/tags/拓扑排序.json"}],"toc":"","author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"喜欢前沿科技，想要见证人类科学的飞跃","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}},"mapped":true,"prev_post":{"title":"ACM学习笔记day36(树和图的DFS和BFS)","uid":"1429a762104f1c731f39acc20f00d741","slug":"ACM学习笔记day36","date":"2023-03-25T12:50:55.000Z","updated":"2023-04-08T10:54:15.019Z","comments":true,"path":"api/articles/ACM学习笔记day36.json","keywords":null,"cover":"/img/codeforces.jpg","text":"水一篇blog（树和图的bfs和dfs。 树和图的存储方式采用领接表或者是领接矩阵都可以。dfs和bfs的思路是一样的。bfs套用bfs的模板就可以了，定义一个工作队列。将没有访问过的领接点放入队列中，然后处理即可dfs就遍历他的所有领接点，然后如果没访问过的话就dfs下去。然后...","link":"","photos":[],"count_time":{"symbolsCount":"1.9k","symbolsTime":"2 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":39,"path":"api/tags/ACM.json"},{"name":"学习","slug":"学习","count":42,"path":"api/tags/学习.json"},{"name":"图论","slug":"图论","count":3,"path":"api/tags/图论.json"},{"name":"dfs","slug":"dfs","count":4,"path":"api/tags/dfs.json"},{"name":"bfs","slug":"bfs","count":3,"path":"api/tags/bfs.json"},{"name":"树","slug":"树","count":1,"path":"api/tags/树.json"},{"name":"图","slug":"图","count":1,"path":"api/tags/图.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"喜欢前沿科技，想要见证人类科学的飞跃","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}},"next_post":{"title":"Django使用日志1","uid":"61b5f3ff4f3925a999a96e334e6690e1","slug":"Django使用日志1","date":"2023-03-11T15:02:23.000Z","updated":"2023-08-27T09:16:43.194Z","comments":true,"path":"api/articles/Django使用日志1.json","keywords":null,"cover":null,"text":"wc，后端开发可太cooooool了！ django-admin startproject &lt;name&gt; 这条指令用于在当前文件夹下产生一个 &lt;name&gt; 的django默认框架的文件 这样做了之后，其实目前就已经可以作为一个网页的后端了，我们可以尝试部署...","link":"","photos":[],"count_time":{"symbolsCount":241,"symbolsTime":"1 mins."},"categories":[{"name":"Django","slug":"Django","count":1,"path":"api/categories/Django.json"}],"tags":[{"name":"后端","slug":"后端","count":1,"path":"api/tags/后端.json"},{"name":"backend","slug":"backend","count":1,"path":"api/tags/backend.json"},{"name":"Django","slug":"Django","count":1,"path":"api/tags/Django.json"},{"name":"开发","slug":"开发","count":1,"path":"api/tags/开发.json"},{"name":"项目","slug":"项目","count":1,"path":"api/tags/项目.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"喜欢前沿科技，想要见证人类科学的飞跃","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}}}