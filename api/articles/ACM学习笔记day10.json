{"title":"ACM学习笔记day10(KMP)","uid":"f3213b374a759ee017011c4487f29020","slug":"ACM学习笔记day10","date":"2022-11-19T14:38:53.000Z","updated":"2023-04-08T10:49:28.522Z","comments":true,"path":"api/articles/ACM学习笔记day10.json","keywords":null,"cover":"/img/codeforces.jpg","content":"<p>今天的学习内容是！<br>KMP！<br>呃呃呃，理解了大概两天的样子，<br>现在终于是差不多有点理解了。</p>\n<span id=\"more\"></span>\n\n\n<h2 id=\"KMP\"><a href=\"#KMP\" class=\"headerlink\" title=\"KMP\"></a>KMP</h2><p><a href=\"https://www.acwing.com/problem/content/833/\">题目链接acwing</a><br>KMP算法用于两个字符串匹配的时候提供一个线性时间复杂度的做法。<br>其中一个关键的东西，就是next数组<br>next数组定义：next[i]的值，表示主串匹配到第i位的时候，第i-1个字符以前的后缀和模板串前缀长度最长的部分的最后一个字符的位置，他记录的位置<br>是模板串里的位置。<br>比如： next[5]&#x3D;3，表示主串匹配到第5位的时候，最长的和主串的后缀相同的模板串的前缀的最后的一个字符的位置是3。<br>介绍为next数组的含义<br>下面为KMP的思想(next数组的求法我们放到最后)：<br>我们用i从头遍历主串，然后用另外一个指针j去遍历模板串<br>这里我们初始化i&#x3D;0，j&#x3D;-1(为什么让j为-1，这里是为了和next数组里面存的数据相对应)<br>我们记主串为S，模板串为P<br>去比较S[i]&#x3D;&#x3D;P[j+1]吗？ &#x2F;&#x2F;我们这里为什么要P[j+1]而不是P[j]呢？因为我们默认j是已经匹配好的最后一个字符，是为了配合next的定义</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>如果相等，那最好，直接j++就可以了</p></blockquote>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>如果不相等，我们得让j回退吧，但是如果j从头开始就是暴力做法了，会很多重复的浪费的步骤，这里我们就要用到next数组了<br>我们直接让j&#x3D;next[j],让j回退到最大长度的已经匹配好的地方，然后再进行P[j+1]&#x3D;&#x3D;S[i]的比较<br>这里我们使用一个while循环一下</p></blockquote>\n<p>See see code</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F;KMP算法\n &#x2F;&#x2F;m为主串长度\n    for (int i &#x3D; 0, j &#x3D; -1; i &lt; m; i++) &#123;\n        &#x2F;&#x2F;循环判断 s[i] !&#x3D; p[j + 1]是否？，如果不相等就就让j回溯到ne[j]。直至相等为止\n        while (j !&#x3D; -1 &amp;&amp; s[i] !&#x3D; p[j + 1]) &#123;\n            j &#x3D; ne[j];\n        &#125;\n        &#x2F;&#x2F;如果相等，让j自加\n        if (s[i] &#x3D;&#x3D; p[j + 1]) &#123;\n            j++;\n        &#125;\n        &#x2F;&#x2F;这里，如果j&#x3D;&#x3D;n-1，说明j已经指向了模板串的最后一位了，而根据我们之前的定义，j是已经匹配好的串的最后一位，\n        &#x2F;&#x2F;那么j&#x3D;&#x3D;n-1就说明，已经匹配好了。\n        &#x2F;&#x2F;输出i-n+1就是匹配的串的第一个字符的位置了\n        if (j &#x3D;&#x3D; n - 1) &#123;\n            cout &lt;&lt; i - n + 1 &lt;&lt; &#39; &#39;;\n            j &#x3D; ne[j];&#x2F;&#x2F;这里，可能会有多个模板串重叠的情况，所以要让j回退一次，\n        &#125;\n    &#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>然后接下来，就是求解next数组的部分，这部分其实是KMP算法里面最难的部分了<br>就是这东西一直不理解(哭)<br>我们在匹配的时候，发现第i个位置匹配的位置不对了，这里我们可以看到前面的其实是有一部分模板串的前缀和主串的后缀是匹配的，我们想办法<br>把那里的位置给存下来，然后让j直接等于他就可以了，这既是next数组<br>那么怎么求next数组呢？<br>因为我们是要在已经匹配好的地方去找next应该在哪里<br>而此时因为上下已经匹配了<br>所以我们只要对模板串操作就可以了<br>反正两部分都是一样的嘛<br>我们怎么求这个next数组呢?<br>其实思路和求主串和模板串匹配是一样的<br>我们结合代码来看</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F;构造next数组\n &#x2F;&#x2F;n为模板串长度\n    &#x2F;&#x2F;老规矩，遍历一边模板串，这里求next数组其实就是让模板串和模板串进行一个字符匹配\n    &#x2F;&#x2F;我们初始化next数组全部都是-1，表示最长相同部分的最后一个位置为-1，不存在\n    for (int i &#x3D; 1, j &#x3D; -1; i &lt; n; i++) &#123;\n        &#x2F;&#x2F;这里i指的P当做主串，j指向的P当做模板串。\n        &#x2F;&#x2F;这里其实有点状态转移的思想，当我们遍历到i的时候，如果p[i]!&#x3D;p[j+1]则让j回溯\n        &#x2F;&#x2F;再进行比较\n        while (j !&#x3D; -1 &amp;&amp; p[i] !&#x3D; p[j + 1]) &#123;\n            j &#x3D; ne[j];\n        &#125;\n        &#x2F;&#x2F;如果相等了，就让j++，j往后一个位置\n        if (p[i] &#x3D;&#x3D; p[j + 1]) &#123;\n            j++;\n        &#125;\n        ne[i] &#x3D; j; &#x2F;&#x2F;每次都记录一下当前的j的位置，\n        &#x2F;&#x2F;不难发现，如果运行到了这一步，说明第i个位置这里，j已经是相同后缀的最后一位了\n        &#x2F;&#x2F;这里是是p[j+1]在和他们比较，所以j++后直接存入ne中去，\n        &#x2F;&#x2F;如果不相等的话，仍然存之前那个值\n    &#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>下面为完整代码</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nconstexpr auto INF &#x3D; 2100000000;\nconstexpr long long INF64 &#x3D; 1e18;\nconst int N &#x3D; 1000010;\ntypedef pair&lt;int, int&gt; PII;\n\nint n, m;\nstring s, p;\nint ne[N] &#x3D; &#123; -1 &#125;;\n\nint main()\n&#123;\n    cin &gt;&gt; n &gt;&gt; p &gt;&gt; m &gt;&gt; s;\n    &#x2F;&#x2F;构造next数组\n    for (int i &#x3D; 1, j &#x3D; -1; i &lt; n; i++) &#123;\n        while (j !&#x3D; -1 &amp;&amp; p[i] !&#x3D; p[j + 1]) &#123;\n            j &#x3D; ne[j];\n        &#125;\n        if (p[i] &#x3D;&#x3D; p[j + 1]) &#123;\n            j++;\n        &#125;\n        ne[i] &#x3D; j;\n    &#125;\n\n\n    &#x2F;&#x2F;KMP算法\n    for (int i &#x3D; 0, j &#x3D; -1; i &lt; m; i++) &#123;\n        while (j !&#x3D; -1 &amp;&amp; s[i] !&#x3D; p[j + 1]) &#123;\n            j &#x3D; ne[j];\n        &#125;\n        if (s[i] &#x3D;&#x3D; p[j + 1]) &#123;\n            j++;\n        &#125;\n        if (j &#x3D;&#x3D; n - 1) &#123;\n            cout &lt;&lt; i - n + 1 &lt;&lt; &#39; &#39;;\n            j &#x3D; ne[j];\n        &#125;\n    &#125;\n    cout &lt;&lt; endl;\n    return 0;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>总的来说<br>KMP算法感觉还是挺难理解的<br>搞了两天的时间。<br>害<br>OK<br>That’s all<br>Bye~</p>\n","text":"今天的学习内容是！KMP！呃呃呃，理解了大概两天的样子，现在终于是差不多有点理解了。 KMP题目链接acwingKMP算法用于两个字符串匹配的时候提供一个线性时间复杂度的做法。其中一个关键的东西，就是next数组next数组定义：next[i]的值，表示主串匹配到第i位的时候，第...","link":"","photos":[],"count_time":{"symbolsCount":"3.7k","symbolsTime":"3 mins."},"categories":[{"name":"ACM","slug":"ACM","count":39,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":37,"path":"api/tags/ACM.json"},{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"学习","slug":"学习","count":41,"path":"api/tags/学习.json"},{"name":"算法","slug":"算法","count":20,"path":"api/tags/算法.json"},{"name":"数据结构","slug":"数据结构","count":21,"path":"api/tags/数据结构.json"},{"name":"KMP","slug":"KMP","count":1,"path":"api/tags/KMP.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#KMP\"><span class=\"toc-text\">KMP</span></a></li></ol>","author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"喜欢前沿科技，想要见证人类科学的飞跃","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}},"mapped":true,"prev_post":{"title":"ACM学习笔记day11(Trie树)","uid":"cf4a03b1403b8a8d56d4650e2b121d28","slug":"ACM学习笔记day11","date":"2022-11-20T13:36:27.000Z","updated":"2023-04-08T10:50:36.627Z","comments":true,"path":"api/articles/ACM学习笔记day11.json","keywords":null,"cover":"/img/codeforces.jpg","text":"Hello guys！今天学习的内容是Trie树，应该也是叫字典树题目链接acwing 直接上代码吧理解不难 #include&lt;iostream&gt; #include&lt;string&gt; using namespace std; const int N &#x3...","link":"","photos":[],"count_time":{"symbolsCount":"1.6k","symbolsTime":"1 mins."},"categories":[{"name":"ACM","slug":"ACM","count":39,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":37,"path":"api/tags/ACM.json"},{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"学习","slug":"学习","count":41,"path":"api/tags/学习.json"},{"name":"算法","slug":"算法","count":20,"path":"api/tags/算法.json"},{"name":"数据结构","slug":"数据结构","count":21,"path":"api/tags/数据结构.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"喜欢前沿科技，想要见证人类科学的飞跃","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}},"next_post":{"title":"ACM学习笔记day9(滑动窗口，双端队列)","uid":"958adf9461e6c3975304da3314c38d67","slug":"ACM学习笔记day9","date":"2022-11-17T13:07:42.000Z","updated":"2023-04-08T10:49:25.073Z","comments":true,"path":"api/articles/ACM学习笔记day9.json","keywords":null,"cover":"/img/codeforces.jpg","text":"今天学习的时间比较短，哦，确实也挺短的不过当时比较困，理解起来也很慢，所以今天的内容只有一个是滑动窗口和双端队列！ 滑动窗口什么是滑动窗口！就是单调队列的一道经典例题链接这里因为要用到了单调队列。我acwing上打卡用的是数组模拟双端队列的。而目前上面的题解是使用STL里面的双端...","link":"","photos":[],"count_time":{"symbolsCount":"2.4k","symbolsTime":"2 mins."},"categories":[{"name":"ACM","slug":"ACM","count":39,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":37,"path":"api/tags/ACM.json"},{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"学习","slug":"学习","count":41,"path":"api/tags/学习.json"},{"name":"算法","slug":"算法","count":20,"path":"api/tags/算法.json"},{"name":"数据结构","slug":"数据结构","count":21,"path":"api/tags/数据结构.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"喜欢前沿科技，想要见证人类科学的飞跃","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}}}