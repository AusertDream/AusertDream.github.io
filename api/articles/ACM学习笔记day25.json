{"title":"ACM学习笔记day25(扩展中国剩余定理)","uid":"3f5d2f03fa2075448efe1519bfee1297","slug":"ACM学习笔记day25","date":"2023-02-03T10:09:28.000Z","updated":"2023-04-08T10:52:24.226Z","comments":true,"path":"api/articles/ACM学习笔记day25.json","keywords":null,"cover":"/img/codeforces.jpg","content":"<p>大标题就是题目链接。<br>这节的内容是扩展CRT。<br>其实就是在原来的基础上去掉了模数两两互质的条件。<br>这样的话CRT就不能用了，得用扩展中国剩余定理。<br>虽然说是扩展CRT，但是其实和CRT没什么关系，是一种解决这类问题的方法罢了</p>\n<span id=\"more\"></span>\n\n<p>CRT解决的是什么问题，可以看我的上一篇博客，就在上面一篇。<br>这里我们不在赘述啥是中国剩余定理。</p>\n<p>对于模数不两两的互质的情况，这个时候我们无法再使用CRT来直接求出来结果了。<br>我们对此的思想是，将方程组中的方程的数量逐渐减少，最后就剩一条方程，那样的话，结果不就很好求了吗？<br>问题来了，怎么使得方程数量逐渐减少呢？<br>这里我们使用的方法是将两条方程合并。<br>不断的进行这个过程，最终得到的结果就能够很容易的得出来解了。<br>如何合并？<br>因为过程比较复杂，码字太麻烦了，直接看草稿吧。<br>这里我们只举例第一条方程和第二条方程，其他的同理。<br>如下：</p>\n<p><img src=\"https://raw.githubusercontent.com/AusertDream/MyblogImags/main/dsssdaefds.jpg\" alt=\"12131231\"></p>\n<p>通过这种方法，我们就把两条方程化成了一条方程。</p>\n<p>下面针对acwing上这题作出点小note。<br>题目给的数据范围比较极限，所以取k1的值的时候要取最小正整数，不然会爆long long<br>其次结果要取最小正整数，这个是题目要求的。</p>\n<p>实际程序中，我们只需要两组对应的a和m就够了，一个不断维护，作为新的a和m，一个用来接收新的a和m。</p>\n<p>下面为ac code：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\n\nll exgcd(ll a,ll b,ll&amp; x,ll&amp; y)&#123;\n    if(b&#x3D;&#x3D;0)&#123;\n        x&#x3D;1,y&#x3D;0;\n        return a;\n    &#125;    \n    ll t&#x3D;exgcd(b,a%b,y,x);\n    y-&#x3D;a&#x2F;b*x;\n    return t;\n&#125;\n\nint main()&#123;\n    int n;\n    cin&gt;&gt;n;\n    ll a1,m1;\n    cin&gt;&gt;a1&gt;&gt;m1;\n    n--;\n    while(n--)&#123;\n        ll a2,m2;\n        cin&gt;&gt;a2&gt;&gt;m2;\n        ll k1,k2;\n        ll d&#x3D;exgcd(a1,a2,k1,k2);\n        if((m2-m1)%d!&#x3D;0)&#123;\n            cout&lt;&lt;-1&lt;&lt;endl;\n            return 0;\n        &#125;\n        k1*&#x3D;(m2-m1)&#x2F;d;\n        ll t&#x3D;a2&#x2F;d;\n        k1&#x3D;(k1%t+t)%t;&#x2F;&#x2F;这里k1要为最小的正整数。\n        &#x2F;&#x2F;然后更新a和m的值就可以了。\n        m1&#x3D;k1*a1+m1;\n        a1&#x3D;a1*a2&#x2F;d;\n    &#125;\n    &#x2F;&#x2F;结果的x就是x&#x3D;k*a1+m1;\n    &#x2F;&#x2F;要取最小的正整数。\n    cout&lt;&lt;(m1%a1+a1)%a1&lt;&lt;endl;\n    return 0;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>这个扩展欧几里得算法还是比较难理解的。<br>不过也海星，毕竟就是数学的东西。<br>qwq<br>我觉得这个确实挺难的，所以单独发了个blog来写这个笔记。<br>那我们下次再见捏<br>bye~</p>\n","text":"大标题就是题目链接。这节的内容是扩展CRT。其实就是在原来的基础上去掉了模数两两互质的条件。这样的话CRT就不能用了，得用扩展中国剩余定理。虽然说是扩展CRT，但是其实和CRT没什么关系，是一种解决这类问题的方法罢了 CRT解决的是什么问题，可以看我的上一篇博客，就在上面一篇。这...","link":"","photos":[],"count_time":{"symbolsCount":"1.6k","symbolsTime":"1 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"学习","slug":"学习","count":41,"path":"api/tags/学习.json"},{"name":"数论","slug":"数论","count":5,"path":"api/tags/数论.json"},{"name":"数学","slug":"数学","count":7,"path":"api/tags/数学.json"},{"name":"扩展中国剩余定理","slug":"扩展中国剩余定理","count":1,"path":"api/tags/扩展中国剩余定理.json"}],"toc":"","author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"喜欢前沿科技，想要见证人类科学的飞跃","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}},"mapped":true,"prev_post":{"title":"ACM学习笔记day26 (高斯消元解线性方程组和异或方程组)","uid":"1a520a07ea86cfe9d127f0b6811d1363","slug":"ACM学习笔记day26","date":"2023-02-04T13:00:01.000Z","updated":"2023-04-08T10:52:31.322Z","comments":true,"path":"api/articles/ACM学习笔记day26.json","keywords":null,"cover":"/img/codeforces.jpg","text":"今天的内容是使用高斯消元解线性方程组和异或方程组。什么是高斯消元，不多说，线代的基本内容。 高斯消元解线性方程组用高斯消元解线性方程组的时候，编程解决其实就是一个模拟的事情。我们写程序去模拟我们的实际进行的步骤。该模板的时间复杂度为O(n^3)。可以看到时间复杂度还是很高的。如果...","link":"","photos":[],"count_time":{"symbolsCount":"4.7k","symbolsTime":"4 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":39,"path":"api/tags/ACM.json"},{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"学习","slug":"学习","count":41,"path":"api/tags/学习.json"},{"name":"数学","slug":"数学","count":7,"path":"api/tags/数学.json"},{"name":"高斯消元","slug":"高斯消元","count":1,"path":"api/tags/高斯消元.json"},{"name":"解方程组","slug":"解方程组","count":1,"path":"api/tags/解方程组.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"喜欢前沿科技，想要见证人类科学的飞跃","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}},"next_post":{"title":"ACM学习笔记day24(扩展欧几里得算法，线性同余方程，中国剩余定理)","uid":"e8f352fc1ae41c272b21fc150a45992f","slug":"ACM学习笔记day24","date":"2023-02-02T14:25:04.000Z","updated":"2023-04-08T10:52:17.703Z","comments":true,"path":"api/articles/ACM学习笔记day24.json","keywords":null,"cover":"/img/codeforces.jpg","text":"emm，好像距离上次写博客好像是很久以前了呢(懒狗，摆烂王是吧)话不多说，直接进入正题，今天的内容是扩展欧几里得算法和CRT，也就是中国剩余定理，或者也叫孙子定理。 扩展欧几里得算法这个算法其实和欧几里得算法很像，都是用到了辗转相除法。只不过在辗转相除的同时，一边算了一个GCD，...","link":"","photos":[],"count_time":{"symbolsCount":"4.1k","symbolsTime":"4 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"学习","slug":"学习","count":41,"path":"api/tags/学习.json"},{"name":"蒟蒻","slug":"蒟蒻","count":4,"path":"api/tags/蒟蒻.json"},{"name":"数论","slug":"数论","count":5,"path":"api/tags/数论.json"},{"name":"扩展欧几里得","slug":"扩展欧几里得","count":1,"path":"api/tags/扩展欧几里得.json"},{"name":"CRT","slug":"CRT","count":1,"path":"api/tags/CRT.json"},{"name":"中国剩余定理","slug":"中国剩余定理","count":1,"path":"api/tags/中国剩余定理.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"喜欢前沿科技，想要见证人类科学的飞跃","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}}}