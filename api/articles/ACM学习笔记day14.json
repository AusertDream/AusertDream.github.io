{"title":"ACM学习笔记day14（带权并查集，堆排序，模拟堆）","uid":"baee1de5b96302e6e975d5e11b914928","slug":"ACM学习笔记day14","date":"2022-12-01T14:13:12.000Z","updated":"2023-04-08T10:50:59.395Z","comments":true,"path":"api/articles/ACM学习笔记day14.json","keywords":null,"cover":"/img/codeforces.jpg","content":"<p>Hello guys!<br>感觉好久没有写笔记了，上次写笔记好像是呃呃呃，五天前了吧。<br>要忙学校的好多事情，呜呜呜，我有罪orz<br>好了，不bb了，今天的学习内容是<a href=\"https://www.acwing.com/problem/content/242/\">带权并查集</a>（食物链）,<a href=\"https://www.acwing.com/problem/content/841/\">堆模拟</a>,<a href=\"https://www.acwing.com/problem/content/840/\">堆排序</a></p>\n<span id=\"more\"></span>\n\n<h2 id=\"带权并查集\"><a href=\"#带权并查集\" class=\"headerlink\" title=\"带权并查集\"></a>带权并查集</h2><p>带权并查集就是原来并查集的升级版，plus版本。<br>相较于原来的普通的并查集，带权并查集我们所维护的树，每一条边都有了权值。<br>这就是带权并查集<br>下面针对acwing上这道题目来理解带权并查集。<br>食物链的题目。<br>题目简单描述一下，有ABC三种动物，这三种动物是互相吃的<br>比如，A吃B，B吃C，C吃A，食物链是形成一个闭环的。<br>然后现在有N个动物，给你k个说法，判断里面有多少假话。<br>假话的标准(满足其中一个就是假话)是：</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>当前的话与前面的某些真的话冲突，就是假话；<br>当前的话中 X 或 Y 比 N 大，就是假话；<br>当前的话表示 X 吃 X，就是假话。</p></blockquote>\n<p>k个说法中，有两种形式</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><ol>\n<li>1 X Y 表示X和Y 是同类</li>\n<li>2 X Y 表示X吃Y。</li>\n</ol></blockquote>\n<p>对于这题，我们维护一个树，树的不同节点，表示各个动物，然后我们对于每个节点，使之与根节点建立联系<br>如果说，当前节点与根节点的距离为1，就定义为当前节点吃根节点，如果为2，就是被根节点吃<br>如果是3就是与根节点同类<br>实际过程中，这个距离难免会出现大于3的情况，因为一共就三种动物，所以距离是以3为循环的<br>所以我们处理操作的时候让距离mod3就可以了<br>这里我们要定义两个数组，一个是p[N]，一个是d[N]，p是该节点的父亲节点，这个不多赘述<br>而d是该节点的距离其双亲节点的距离，注意！是到双亲的距离，不是根节点的距离，这个概念很重要！！<br>好，我们定义完这个并查集的带权信息后，<br>那么我们怎么界定X和Y是否是同类，是否是吃和被吃的关系呢？<br>如果是同类并且根节点是同一个的话，如果X到根节点的距离%3为零，并且Y到根节点的距离%3也为零，就说明X和Y都是和根节点同类的<br>也就说明X和Y同类。在数值上表现为(d[x]-d[y])%3&#x3D;&#x3D;0<br>如果X是吃Y的并且在根节点是一致的，那我们就去找X是和根节点是同类的，然后Y是被根节点吃的，当然这是一种特殊的情况，但是计算值可以代表普遍属性<br>也就是(d[x]-d[y]-1)%3&#x3D;&#x3D;0<br>如果根节点不一样的话，说明我们所维护的树上，没有这个信息，不用管肯定是真的，将目前的信息加入到树上。<br>下面为代码：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nconst int N &#x3D; 100010;\nint p[N],d[N]; &#x2F;&#x2F;p代表一个节点的双亲节点是谁，d表示一个节点的到双亲结点的距离\nint n,m; &#x2F;&#x2F;n是节点个数，m是m个陈述\n&#x2F;&#x2F;并查集里面基础的模板查找，find函数，查找一个节点的根节点，同时进行路劲压缩和d距离的修改\nint find(int x)&#123;\n    if(p[x]!&#x3D;x)&#123;\n        int t&#x3D;find(p[x]); &#x2F;&#x2F;这里要提前存一下他的根节点是哪个，如果这里不存t，下面那个地方写p[X]&#x3D;find（p[x]）会出错\n        &#x2F;&#x2F;具体原因是因为递归的关系，这种写法才可以，如果看到不懂的，可以自己模拟一下递归的过程，或者直接记住这个就可以了\n        d[x]+&#x3D;d[p[x]]; &#x2F;&#x2F;将当前这个节点到根节点的距离递加父节点到根节点的距离。如果去模拟这个递推的过程的话，这个\n        &#x2F;&#x2F;不难理解，先根节点的一个孩子节点进行，然后再孩子节点，距离弄完，同时也把他直接连到了根节点上。\n        &#x2F;&#x2F;同时，这个时候再让d[x]+&#x3D;d[p[x]]也就是当前节点到根节点的距离了\n        p[x]&#x3D;t; &#x2F;&#x2F;路径压缩 \n    &#125;\n    return p[x]; &#x2F;&#x2F;返回根节点\n&#125;\nint main()&#123;\n    cin&gt;&gt;n&gt;&gt;m;\n    &#x2F;&#x2F;p数组的初始化，不要忘了！\n    for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;\n        p[i]&#x3D;i;\n    &#125;\n    int res&#x3D;0; &#x2F;&#x2F;结果\n    &#x2F;&#x2F;m次询问\n    while(m--)&#123;\n        int t,x,y;\n        cin&gt;&gt;t&gt;&gt;x&gt;&gt;y;\n        if(x&gt;n||y&gt;n)&#123; &#x2F;&#x2F;如果x，y超出了n的范围，直接可以得出来是假的\n            res++;\n        &#125;\n        else&#123;\n        int px&#x3D;find(x),py&#x3D;find(y); &#x2F;&#x2F;非常妙的一步\n        &#x2F;&#x2F;首先先把x和y的根节点给存储起来，这还不是最妙的\n        &#x2F;&#x2F;最妙的是先进行了这样的一部操作，是进行了一次路径压缩，也就是说，下面用到的d[x],d[y]，\n        &#x2F;&#x2F;定义上是该节点到他的父节点的距离，但是实际上是到根节点的距离，这样，我们也就方便我们接下来的操作了。\n        if(t&#x3D;&#x3D;1)&#123; \n            if(px&#x3D;&#x3D;py&amp;&amp;(d[x]-d[y])%3)&#123; &#x2F;&#x2F;如果在一棵树上，并且不是同类的话\n                res++; &#x2F;&#x2F;假话++：\n            &#125;\n            else if(px!&#x3D;py)&#123; &#x2F;&#x2F;如果不在一棵树上，说明目前没有这个信息，就把他存进去\n                &#x2F;&#x2F;添加信息，其实很简单，就两步操作，一个是把树连过去，一个是修改d的值\n                &#x2F;&#x2F;注意，如果把px连py上，那么要修改的是d[px]而不是其他的比如d[x]或者d[y]\n                &#x2F;&#x2F;修改根才是真的修改，不然都是部分的修改，没有修改本质\n                d[px]&#x3D;d[y]-d[x];  &#x2F;&#x2F;这个可以画图加上列方程求解这里为啥是这个值\n                p[px]&#x3D;py; &#x2F;&#x2F;把px连到py上\n            &#125;\n        &#125;\n        else&#123;\n            if(px&#x3D;&#x3D;py&amp;&amp;(d[x]-d[y]-1)%3)&#123; &#x2F;&#x2F;如果在同一树上并且不满足x吃y的关系，res++\n                res++;\n            &#125;\n            else if(px!&#x3D;py)&#123;\n                d[px]&#x3D;1+d[y]-d[x]; &#x2F;&#x2F;为什么是这个值同理，画图加方程求解\n                p[px]&#x3D;py;\n            &#125;\n        &#125;\n        &#125;\n    &#125;\n    cout&lt;&lt;res&lt;&lt;endl;\n    return 0;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>好了，差不多这题差不多就是这么个意思，关键就在于使用带权并查集然后并且赋予权值意义，结合题意来求解</p>\n<p>下一题是</p>\n<h2 id=\"模拟堆\"><a href=\"#模拟堆\" class=\"headerlink\" title=\"模拟堆\"></a>模拟堆</h2><p>什么是堆？其实堆就是一个完全二叉树，堆分为小根堆和大根堆。<br>小根堆就是，根节点的值是小于等于左右孩子节点的值的，对于一棵树的每一颗子树都是这样的，这样就是小根堆<br>大根堆同理。<br>堆一般有三个操作</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>1.插入一个数<br>2.输出当前集合的最小值<br>3.删除最小值</p></blockquote>\n<p>除此之外，有更进阶的操作是</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>4.删除第k个插入的数字<br>5.修改第k个插入的数字</p></blockquote>\n<p>这些那么多操作的背后，有两个基本的操作</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>1.up操作，就是把当前数字的位置往上移动，直到目前的位置满足小根堆的定义或者大根堆的定义<br>2.down操作和up操作刚好反过来。</p></blockquote>\n<p>模拟堆，我们一般用一维数组来存储，一个节点的左孩子是2*i，右孩子是2*i+1,这里其实就是完全二叉树的一个性质<br>用到了这个性质来用数组模拟二叉树的结构。</p>\n<p>对于acwing上的这题模拟堆，要想满足还要删除修改第k个值，需要用到两个额外的数组，一个是ph[N],一个是hp[N]<br>其中ph[i]，表示第i个插入的数组在堆中是第几个数字，hp[i]表示堆中的第i个数字是第几个插入的<br>为什么要用到这两个数组呢？<br>因为我们修改一个数的值的时候，为了维护堆，必然要让他up和down的，那么此时他在堆的编号和他实际是第几个插入的已经不匹配了<br>所以我们需要这么两个数组来获取编号信息<br>同时，因为我们用到了这两个数组，普通的swap函数已经不能用了，我们需要自己写一个特殊的swap函数，用于交换数字之后，hp和ph的值也要交换<br>下面结合代码来看看如何操作</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nconst int N &#x3D;100010;\nint n,m; &#x2F;&#x2F;这里这个m是统计第几个插入的数字的\nint heap[N],hp[N],ph[N],sz;  &#x2F;&#x2F;sz表示当前堆的大小，sz指向的是当前堆的最后一个数字\n&#x2F;&#x2F;heap数组用于存放堆的数据，hp和ph上面已经说明过了\n&#x2F;&#x2F;堆里面特殊的swap操作,首先你要交换ph指针，然后交换hp指针，然后交换heap里面的数值 这里，输入的数值是堆里面的第几个数\n&#x2F;&#x2F;也不在是单纯的数值了\nvoid heap_swap(int a,int b)&#123;\n    swap(ph[hp[a]],ph[hp[b]]);\n    swap(hp[a],hp[b]);\n    swap(heap[a],heap[b]);\n&#125;\n\nvoid down(int i)&#123;\n    int min&#x3D;i; &#x2F;&#x2F;记录三个数中的最小的那个标号\n    if(2*i&lt;&#x3D;sz&amp;&amp;heap[2*i]&lt;heap[min])&#123; &#x2F;&#x2F;如果存在左孩子，并且左孩子比min值小，就把min更新\n        min&#x3D;2*i;\n    &#125;\n    if(2*i+1&lt;&#x3D;sz&amp;&amp;heap[2*i+1]&lt;heap[min])&#123; &#x2F;&#x2F;同理，维护min\n        min&#x3D;2*i+1;\n    &#125;\n    if(min!&#x3D;i)&#123; &#x2F;&#x2F;如果此时min和要求down的i不一样，说明此时的i需要往下移动\n        heap_swap(min,i); &#x2F;&#x2F;交换min和i的值\n        down(min); &#x2F;&#x2F;递归继续进行down操作直到满足小根堆的条件\n    &#125;\n&#125;\n\nvoid up(int i)&#123;\n    if(i&#x2F;2&gt;0&amp;&amp;heap[i]&lt;heap[i&#x2F;2])&#123; &#x2F;&#x2F;如果他的值是小于双亲结点，那么就交换一下数字，然后继续up就可以了\n        heap_swap(i,i&#x2F;2);\n        up(i&#x2F;2);\n    &#125;\n&#125;\n\nint main()&#123;\n    cin&gt;&gt;n;\n    while(n--)&#123;\n        string op;\n        cin&gt;&gt;op;\n        if(op&#x3D;&#x3D;&quot;I&quot;)&#123;\n            &#x2F;&#x2F;插入一个数字x\n            int x;\n            cin&gt;&gt;x;\n            m++; &#x2F;&#x2F;m++，这是第m插入的\n            sz++; &#x2F;&#x2F;同时数字的大小也要增加1\n            ph[m]&#x3D;sz; &#x2F;&#x2F;第m个插入的在堆里面是第sz个\n            hp[sz]&#x3D;m; &#x2F;&#x2F;堆里面的第sz个是第m个插入的\n            heap[sz]&#x3D;x; &#x2F;&#x2F;把值存入heap里面去 \n            up(sz); &#x2F;&#x2F;因为插入在尾部，所以要up他，来维护小根堆的定义\n        &#125;\n        else if(op&#x3D;&#x3D;&quot;PM&quot;)&#123;\n            cout&lt;&lt;heap[1]&lt;&lt;endl;\n        &#125;\n        else if(op&#x3D;&#x3D;&quot;DM&quot;)&#123;\n            heap_swap(1,sz); &#x2F;&#x2F;删除最小的节点，就直接交换第一个节点和最后一个可以了\n            sz--;&#x2F;&#x2F;sz--就是删掉了最后一个节点\n            down(1); &#x2F;&#x2F;别忘了要down一下最后一个节点，来维护小根堆的定义\n        &#125;\n        else if(op&#x3D;&#x3D;&quot;D&quot;)&#123;\n            int k;\n            cin&gt;&gt;k;\n            &#x2F;&#x2F;要删除第k个数字，同理的，把第k个数字和最后一个数字交换一下\n            int u&#x3D;ph[k]; &#x2F;&#x2F;要先存一下ph[k]的信息，交换完之后的话，不存到这个u里面，会不知道down和up谁去\n            heap_swap(ph[k],sz);\n            sz--;\n            up(u);\n            down(u);\n        &#125;\n        else&#123;\n            int k,x;\n            cin&gt;&gt;k&gt;&gt;x;\n            heap[ph[k]]&#x3D;x; &#x2F;&#x2F;修改值\n            up(ph[k]); &#x2F;&#x2F;然后维护一下小根堆\n            down(ph[k]);\n        &#125;\n    &#125;\n    return 0;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>总之，模拟堆的基本思想就是用一维数组去模拟完全二叉树的结构，然后根据堆的结构去维护这样的一个树<br>基本的操作就是两个up和down，删除操作一般是要删除的节点和最后一个节点互换，然后删除最后一个节点来进行的。<br>基本的东西就这些<br><br><br>接下来的就是堆排序<br>理解了模拟堆之后，堆排序也就很简单了。<br>因为我们如果要升序排序的话，只要构建一个小根堆就可以了<br>降序的话就是大根堆</p>\n<p>我们来看acwing的这道题，直接结合代码来说明了<br>理解完堆之后<br>理解这个不难的</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nconst int N &#x3D; 100010;\nint n,m;\nint heap[N],sz;\n&#x2F;&#x2F;正常的down操作，这里我们不需要up操作\n&#x2F;&#x2F;因为我们只要前m小的数字，输出一个删掉一个，不会用到up操作的\nvoid down(int n)&#123;\n    int t&#x3D;n;\n    if(2*n&lt;&#x3D;sz&amp;&amp;heap[2*n]&lt;heap[t])&#123;\n        t&#x3D;2*n;\n    &#125;\n    if(2*n+1&lt;&#x3D;sz&amp;&amp;heap[2*n+1]&lt;heap[t])&#123;\n        t&#x3D;2*n+1;\n    &#125;\n    if(t!&#x3D;n)&#123;\n        swap(heap[t],heap[n]);\n        down(t);\n    &#125;\n&#125;\n\nint main()&#123;\n    cin&gt;&gt;n&gt;&gt;m;\n    sz&#x3D;n;\n    for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;\n        cin&gt;&gt;heap[i]; &#x2F;&#x2F;我们先把数据都输入到堆里面去\n    &#125;\n    &#x2F;&#x2F;这里这个是个特殊的操作，我们如何快速构建一个堆？在O(n)时间内\n    &#x2F;&#x2F;我们从第n&#x2F;2开始进行down操作，一直进行到第1个\n    &#x2F;&#x2F;这么操作之后的话我们就把数据成功构建成一个堆了\n    &#x2F;&#x2F;当然也可以一个一个插入，这样的话是O(nlogn)的时间复杂度了\n    for(int i&#x3D;n&#x2F;2;i;i--)&#123;\n        down(i); \n    &#125;\n    while(m--)&#123;\n        cout&lt;&lt;heap[1]&lt;&lt;&quot; &quot;; &#x2F;&#x2F;输出最小值\n        heap[1]&#x3D;heap[sz]; &#x2F;&#x2F;删除最小值\n        sz--;\n        down(1); &#x2F;&#x2F;别忘了再维护一下小根堆\n    &#125;\n    return 0;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>好啦，这就是全部内容啦，模拟堆和食物链这两题里面你的东西还是比较多的，不过理解起来还好，问题不是很大<br>那么bye~<br>我们下次再见啦~qwq</p>\n","text":"Hello guys!感觉好久没有写笔记了，上次写笔记好像是呃呃呃，五天前了吧。要忙学校的好多事情，呜呜呜，我有罪orz好了，不bb了，今天的学习内容是带权并查集（食物链）,堆模拟,堆排序 带权并查集带权并查集就是原来并查集的升级版，plus版本。相较于原来的普通的并查集，带权并...","link":"","photos":[],"count_time":{"symbolsCount":"8.2k","symbolsTime":"7 mins."},"categories":[{"name":"ACM","slug":"ACM","count":38,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":37,"path":"api/tags/ACM.json"},{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"学习","slug":"学习","count":41,"path":"api/tags/学习.json"},{"name":"算法","slug":"算法","count":20,"path":"api/tags/算法.json"},{"name":"数据结构","slug":"数据结构","count":20,"path":"api/tags/数据结构.json"},{"name":"带权并查集","slug":"带权并查集","count":1,"path":"api/tags/带权并查集.json"},{"name":"堆","slug":"堆","count":1,"path":"api/tags/堆.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%B8%A6%E6%9D%83%E5%B9%B6%E6%9F%A5%E9%9B%86\"><span class=\"toc-text\">带权并查集</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%A8%A1%E6%8B%9F%E5%A0%86\"><span class=\"toc-text\">模拟堆</span></a></li></ol>","author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"喜欢前沿科技，想要见证人类科学的飞跃","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}},"mapped":true,"prev_post":{"title":"ACM学习笔记day15(哈希，字符串的哈希)","uid":"5358138299a8ff147d7f561517fe5a1d","slug":"ACM学习笔记day15","date":"2022-12-02T12:15:59.000Z","updated":"2023-04-08T10:51:06.595Z","comments":true,"path":"api/articles/ACM学习笔记day15.json","keywords":null,"cover":"/img/codeforces.jpg","text":"hello guys！今天的学习内容是哈希表，也就是散列表对应acwing上的模拟散列表和字符串哈希 那么问题来了什么是哈希表呢？一句话来总结就是，不保序的离散化离散化其实是哈希化的一种特殊情况我们将数据范围很大的，较少的数字，映射到一个比较小的数组，这就是哈希，不过中间的那个映...","link":"","photos":[],"count_time":{"symbolsCount":"4.8k","symbolsTime":"4 mins."},"categories":[{"name":"ACM","slug":"ACM","count":38,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":37,"path":"api/tags/ACM.json"},{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"学习","slug":"学习","count":41,"path":"api/tags/学习.json"},{"name":"算法","slug":"算法","count":20,"path":"api/tags/算法.json"},{"name":"数据结构","slug":"数据结构","count":20,"path":"api/tags/数据结构.json"},{"name":"笔记","slug":"笔记","count":3,"path":"api/tags/笔记.json"},{"name":"哈希表","slug":"哈希表","count":1,"path":"api/tags/哈希表.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"喜欢前沿科技，想要见证人类科学的飞跃","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}},"next_post":{"title":"ACM学习笔记day13(求连通块中点的数量)","uid":"d45c53bbd2d951bda24bba0bdde79964","slug":"ACM学习笔记day13","date":"2022-11-25T11:42:49.000Z","updated":"2023-04-08T10:50:52.060Z","comments":true,"path":"api/articles/ACM学习笔记day13.json","keywords":null,"cover":"/img/codeforces.jpg","text":"今天的内容是求连通块中点的数量 求连通块中点的数量这题和并查集那道模板题差不多就是多了一个要求让你统计集合中的数量而已 这里我们用到一个cnt数组，同时我们规定，只有根节点的cnt数据是有意义的这样我们就避免了要给多个同连通块的集合重新赋值的麻烦 #include&lt;bits...","link":"","photos":[],"count_time":{"symbolsCount":"1.5k","symbolsTime":"1 mins."},"categories":[{"name":"ACM","slug":"ACM","count":38,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":37,"path":"api/tags/ACM.json"},{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"学习","slug":"学习","count":41,"path":"api/tags/学习.json"},{"name":"算法","slug":"算法","count":20,"path":"api/tags/算法.json"},{"name":"数据结构","slug":"数据结构","count":20,"path":"api/tags/数据结构.json"},{"name":"并查集","slug":"并查集","count":2,"path":"api/tags/并查集.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"喜欢前沿科技，想要见证人类科学的飞跃","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}}}