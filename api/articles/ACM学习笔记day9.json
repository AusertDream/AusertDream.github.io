{"title":"ACM学习笔记day9(滑动窗口，双端队列)","uid":"958adf9461e6c3975304da3314c38d67","slug":"ACM学习笔记day9","date":"2022-11-17T13:07:42.000Z","updated":"2023-04-08T10:49:25.073Z","comments":true,"path":"api/articles/ACM学习笔记day9.json","keywords":null,"cover":"/img/codeforces.jpg","content":"<p>今天学习的时间比较短，哦，确实也挺短的<br>不过当时比较困，理解起来也很慢，所以今天的内容只有一个<br>是滑动窗口和双端队列！</p>\n<span id=\"more\"></span>\n\n<h2 id=\"滑动窗口\"><a href=\"#滑动窗口\" class=\"headerlink\" title=\"滑动窗口\"></a>滑动窗口</h2><p>什么是滑动窗口！<br>就是单调队列的一道经典例题<br><a href=\"https://www.acwing.com/activity/content/problem/content/868/\">链接</a><br>这里因为要用到了单调队列。<br>我acwing上打卡用的是数组模拟双端队列的。<br>而目前上面的题解是使用STL里面的双端队列的<br>都差不多，感觉用STL里面的逻辑上会比较清楚<br>OK，下面开始解释这道题<br>窗口在不断滑动，然后我们要求窗口里面的最大最小值。<br>这里我们用到了单调队列，每次操作过后，使得队列的头部始终是最小值。<br>这样他要求输出的东西，知道输出头部的数值就可以了。<br>求最大值同理。<br><br><br>具体思路是什么呢<br>我们使用一个deque<int> ans;<br>里面存放的是数字的index而不是他的值——这样是为了方便检查front元素是否已经超出窗口外了<br>如果存放的是值的话，会增加时间复杂度也不容易判断是否超出窗口外了<br>我们用i指针从头部遍历存放的数组。<br>我们每次把第i个数据的index存入ans中去<br>当ans非空且如果front元素比i-k+1要小，就弹出front元素。<br>为什么呢？<br>因为我们用deque去模拟这个窗口，但因为我们是一个一个数据弹进去的<br>当窗口移动的时候，可能前面有个最小值，一直都是接下来几个数字的最小值，<br>再往后移动的时候，这个数出窗口了，那窗口内的最小值肯定就不是他了，所以必须把他弹出。<br>此外，当ans非空的时候，检查back是否大于等于a[i]的值，如果大或者等于就循环弹出，直到比a[i]小为止<br>这是为了不断维护deque的单调性，确保front元素一直都是窗口内的最小值<br>这些操作之后，如果i&gt;&#x3D;k-1的话就输出front元素。<br>这样采用deque的方式，用单调队列的算法解决了这个问题。<br>求最大值的话，同理，只要把while弹出的地方，条件改成小于等于就可以了<br>其他同理<br>下面为代码：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">#include &lt;iostream&gt;\n#include&lt;stack&gt;\n#include&lt;queue&gt;\n#include&lt;algorithm&gt;\n#include&lt;string&gt;\n#include&lt;iomanip&gt;\n#include&lt;deque&gt;\nusing namespace std;\n#include&lt;math.h&gt;\nconst int N &#x3D; 1000010;\ntypedef pair&lt;int, int&gt; PII;\ntypedef long long ll;\n\nint n, k;\nint a[N];\n\nint main() &#123;\n    cin &gt;&gt; n &gt;&gt; k;\n    for (int i &#x3D; 0; i &lt; n; i++) &#123;\n        cin &gt;&gt; a[i];\n    &#125;\n    deque&lt;int&gt; ans;\n    &#x2F;&#x2F;求最小值\n    for (int i &#x3D; 0; i &lt; n; i++) &#123;\n        &#x2F;&#x2F;如果ans里面的front元素已经出窗口了，就直接弹出\n        if (!ans.empty()&amp;&amp;ans.front()&lt;i-k+1) &#123;\n            ans.pop_front();\n        &#125;\n        &#x2F;&#x2F;如果back元素&gt;&#x3D;a[i]，就循环弹出直到条件不满足位置\n        while (!ans.empty() &amp;&amp; a[ans.back()] &gt;&#x3D; a[i]) &#123;\n            ans.pop_back();\n        &#125;\n        &#x2F;&#x2F;最后再把i存放及你去\n        ans.push_back(i);\n        &#x2F;&#x2F;输出front元素\n        if (i &gt;&#x3D; k-1) &#123;\n            cout &lt;&lt; a[ans.front()] &lt;&lt; &#39; &#39;;\n        &#125;\n    &#125;\n    ans.clear(); &#x2F;&#x2F;记得清空一下deque\n    cout&lt;&lt;endl;\n    &#x2F;&#x2F;求最大值，同理\n    for (int i &#x3D; 0; i &lt; n; i++) &#123;\n        if (!ans.empty()&amp;&amp;ans.front()&lt;i-k+1) &#123;\n            ans.pop_front();\n        &#125;\n        while (!ans.empty() &amp;&amp; a[ans.back()] &lt;&#x3D; a[i]) &#123;\n            ans.pop_back();\n        &#125;\n        ans.push_back(i);\n        if (i &gt;&#x3D; k-1) &#123;\n            cout &lt;&lt; a[ans.front()] &lt;&lt; &#39; &#39;;\n        &#125;\n    &#125;\n    return 0;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>OK!<br>That’s all<br>bye~~~~~~</p>\n","text":"今天学习的时间比较短，哦，确实也挺短的不过当时比较困，理解起来也很慢，所以今天的内容只有一个是滑动窗口和双端队列！ 滑动窗口什么是滑动窗口！就是单调队列的一道经典例题链接这里因为要用到了单调队列。我acwing上打卡用的是数组模拟双端队列的。而目前上面的题解是使用STL里面的双端...","link":"","photos":[],"count_time":{"symbolsCount":"2.4k","symbolsTime":"2 mins."},"categories":[{"name":"ACM","slug":"ACM","count":40,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":38,"path":"api/tags/ACM.json"},{"name":"学习","slug":"学习","count":41,"path":"api/tags/学习.json"},{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"数据结构","slug":"数据结构","count":21,"path":"api/tags/数据结构.json"},{"name":"算法","slug":"算法","count":20,"path":"api/tags/算法.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3\"><span class=\"toc-text\">滑动窗口</span></a></li></ol>","author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"喜欢前沿科技，想要见证人类科学的飞跃","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}},"mapped":true,"prev_post":{"title":"ACM学习笔记day10(KMP)","uid":"f3213b374a759ee017011c4487f29020","slug":"ACM学习笔记day10","date":"2022-11-19T14:38:53.000Z","updated":"2023-04-08T10:49:28.522Z","comments":true,"path":"api/articles/ACM学习笔记day10.json","keywords":null,"cover":"/img/codeforces.jpg","text":"今天的学习内容是！KMP！呃呃呃，理解了大概两天的样子，现在终于是差不多有点理解了。 KMP题目链接acwingKMP算法用于两个字符串匹配的时候提供一个线性时间复杂度的做法。其中一个关键的东西，就是next数组next数组定义：next[i]的值，表示主串匹配到第i位的时候，第...","link":"","photos":[],"count_time":{"symbolsCount":"3.7k","symbolsTime":"3 mins."},"categories":[{"name":"ACM","slug":"ACM","count":40,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":38,"path":"api/tags/ACM.json"},{"name":"学习","slug":"学习","count":41,"path":"api/tags/学习.json"},{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"数据结构","slug":"数据结构","count":21,"path":"api/tags/数据结构.json"},{"name":"算法","slug":"算法","count":20,"path":"api/tags/算法.json"},{"name":"KMP","slug":"KMP","count":1,"path":"api/tags/KMP.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"喜欢前沿科技，想要见证人类科学的飞跃","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}},"next_post":{"title":"ACM学习笔记day8(模拟栈，表达式求值，模拟队列，单调栈)","uid":"0bde88ed9132d2dd0ee34fc3f801dfcc","slug":"ACM学习笔记day8","date":"2022-11-15T13:52:59.000Z","updated":"2023-04-08T10:49:21.906Z","comments":true,"path":"api/articles/ACM学习笔记day8.json","keywords":null,"cover":"/img/codeforces.jpg","text":"wdnmd,受不了了，一拳把地球打爆。今天的内容原本应该是11月13号的因为当晚是有个讲座要听，没空写博客想着明天写，结果昨天忙的要死，今天还是忙的要死今天晚上终于稍微有点空了，赶紧把博客给补了，顺便也隔了几天复习一下东西。今天主要学的是 模拟栈，表达式求值，模拟队列和单调栈。 ...","link":"","photos":[],"count_time":{"symbolsCount":"2.9k","symbolsTime":"3 mins."},"categories":[{"name":"ACM","slug":"ACM","count":40,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":38,"path":"api/tags/ACM.json"},{"name":"学习","slug":"学习","count":41,"path":"api/tags/学习.json"},{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"数据结构","slug":"数据结构","count":21,"path":"api/tags/数据结构.json"},{"name":"算法","slug":"算法","count":20,"path":"api/tags/算法.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"喜欢前沿科技，想要见证人类科学的飞跃","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}}}