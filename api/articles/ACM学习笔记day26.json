{"title":"ACM学习笔记day26 (高斯消元解线性方程组和异或方程组)","uid":"1a520a07ea86cfe9d127f0b6811d1363","slug":"ACM学习笔记day26","date":"2023-02-04T13:00:01.000Z","updated":"2023-04-08T10:52:31.322Z","comments":true,"path":"api/articles/ACM学习笔记day26.json","keywords":null,"cover":"/img/codeforces.jpg","content":"<p>今天的内容是使用高斯消元解线性方程组和异或方程组。<br>什么是高斯消元，不多说，线代的基本内容。</p>\n<span id=\"more\"></span>\n\n<h1 id=\"高斯消元解线性方程组\"><a href=\"#高斯消元解线性方程组\" class=\"headerlink\" title=\"高斯消元解线性方程组\"></a><a href=\"https://www.acwing.com/problem/content/885/\">高斯消元解线性方程组</a></h1><p>用高斯消元解线性方程组的时候，编程解决其实就是一个模拟的事情。<br>我们写程序去模拟我们的实际进行的步骤。<br>该模板的时间复杂度为O(n^3)。<br>可以看到时间复杂度还是很高的。<br>如果有1k条方程的话，1s铁超时了。<br>接下来就是我们编程模拟高斯消元的步骤。</p>\n<p>消元的最终目的是把增广矩阵消成阶梯型矩阵，因为是n条方程n个未知数，所以也就是化成上三角的形式。<br>这里我们使用c和r来表示我们消到了第r行，第c列，r行往上的，c列往左的都是已经完事的了。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>step1: 在第c列，r行及以下的地方寻找绝对值最大一个数。<br>step2: 找到那个数字之后，将他这一行和第r行交换数据。<br>step3: 将现在的第r行，第c列的数据化成1，当然第r行的所有数据都要改变的。<br>step4: 用第r行的数据，去消r行往下的数据，将r+1，r+2,….n-1行的第c列的数据都消成零。<br>step5: r++，代表解决了一行，for循环中也会有c++，代表解决了一列。</p></blockquote>\n<p>Note：</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><ol>\n<li>实际上，我们进行的过程是一列一列的去消的，所以我们要枚举这个列。</li>\n<li>在step1之后，如果发现这个最大数的值是0，说明这一列都是零，直接continue去下一行就可以了。</li>\n<li>在消完了n列之后，如果r的值小于n，说明有零行，这个时候要判断一下时候会是无穷解或者是无解的情况了。</li>\n<li>事实上，这个r有点像是这个矩阵的秩的。可以辅助你的理解。为什么r&lt;n就一定不是只有唯一解了。</li>\n</ol></blockquote>\n<p>结果上来看，我们使用0来代表有唯一解，-1代表无解，1,代表无穷多解。</p>\n<p>下面为题目的ac code:</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nconst int N &#x3D; 110;\nconst double eps&#x3D;1e-8;\ndouble a[N][N];\nint n;\n\nint gauss()&#123;\n    int r,c;\n    for(c&#x3D;0,r&#x3D;0;c&lt;n;c++)&#123;\n        int maxi&#x3D;r;\n        for(int i&#x3D;r;i&lt;n;i++)&#123;\n            if(abs(a[i][c])&gt;abs(a[maxi][c]))&#123;\n                maxi&#x3D;i;\n            &#125;\n        &#125;\n        if(abs(a[maxi][c])&lt;eps)&#123;\n            continue;\n        &#125;\n        for(int i&#x3D;c;i&lt;n+1;i++) swap(a[maxi][i],a[r][i]);\n        for(int i&#x3D;n;i&gt;&#x3D;c;i--) a[r][i]&#x2F;&#x3D;a[r][c];\n        for(int i&#x3D;r+1;i&lt;n;i++)&#123;\n            if(abs(a[i][c])&gt;eps)&#123;\n                for(int j&#x3D;n;j&gt;&#x3D;c;j--)&#123;\n                    a[i][j]-&#x3D;a[r][j]*a[i][c];\n                &#125;\n            &#125;\n        &#125;\n        r++;\n    &#125;\n    if(r&lt;n)&#123;\n        for(int i&#x3D;r;i&lt;n;i++)&#123;\n            if(abs(a[i][n])&gt;eps)&#123;\n                return -1;\n            &#125;\n        &#125;\n        return 1;\n    &#125;\n    for(int i&#x3D;n-1;i&gt;&#x3D;0;i--)&#123;\n        for(int j&#x3D;n-1;j&gt;i;j--)&#123;\n            a[i][n]-&#x3D;a[i][j]*a[j][n];\n        &#125;\n    &#125;\n    \n    return 0;\n&#125;\nint main()&#123;\n    cin&gt;&gt;n;\n    for(int i&#x3D;0;i&lt;n;i++)&#123;\n        for(int j&#x3D;0;j&lt;&#x3D;n;j++)&#123;\n            cin&gt;&gt;a[i][j];\n        &#125;\n    &#125;\n    int res&#x3D;gauss();\n    if(res&#x3D;&#x3D;-1) cout&lt;&lt;&quot;No solution&quot;&lt;&lt;endl;\n    else if(res&#x3D;&#x3D;1) cout&lt;&lt;&quot;Infinite group solutions&quot;&lt;&lt;endl;\n    else&#123;\n        for(int i&#x3D;0;i&lt;n;i++)&#123;\n            if(abs(a[i][n])&lt;eps) a[i][n]&#x3D;0;\n            cout&lt;&lt;setiosflags(ios::fixed)&lt;&lt;setprecision(2)&lt;&lt;a[i][n]&lt;&lt;endl;\n        &#125;\n    &#125;\n    return 0;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n<h1 id=\"高斯消元解异或方程组\"><a href=\"#高斯消元解异或方程组\" class=\"headerlink\" title=\"高斯消元解异或方程组\"></a><a href=\"https://www.acwing.com/problem/content/886/\">高斯消元解异或方程组</a></h1><p>什么是异或方程组?</p>\n<p>形如下面的方程我们称之为异或方程：</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>1^0^1^x&#x3D;3</p></blockquote>\n<p>这题中，已经明确说明了数据只会是0和1。<br>那么解这样的异或方程组，我们同理也是使用高斯消元法来解决。<br>这里因为系数已经是1了，所以没有将系数化为1的做法。<br>并且，由于异或有结合律和交换律，所以我们对进行两条方程的异或是完全可以的。<br>也就是可以做到消参的过程。这也就是为什么异或方程组也可以用高斯消元来解。<br>步骤和上面类似，甚至少了几步。</p>\n<p>下面为ac code:</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nconst int N &#x3D; 110;\nint a[N][N];\nint n;\nint gauss()&#123;\n    int c,r;\n    for(c&#x3D;0,r&#x3D;0;c&lt;n;c++)&#123;\n        int t&#x3D;r;\n        for(int i&#x3D;r;i&lt;n;i++)&#123;\n            if(a[i][c]&#x3D;&#x3D;1)&#123;\n                t&#x3D;i;\n                break;\n            &#125;\n        &#125;\n        if(a[t][c]&#x3D;&#x3D;0)&#123;\n            continue;\n        &#125;\n        for(int i&#x3D;c;i&lt;&#x3D;n;i++) swap(a[t][i],a[r][i]);\n        &#x2F;&#x2F;这里没有了系数化为1的操作。因为没必要。肯定为1.\n        for(int i&#x3D;r+1;i&lt;n;i++)&#123;\n            if(a[i][c]&#x3D;&#x3D;1)&#123;\n                for(int j&#x3D;c;j&lt;&#x3D;n;j++)&#123;\n                    a[i][j]^&#x3D;a[r][j];\n                &#125;\n            &#125;\n        &#125;\n        r++;\n    &#125;\n    if(r&lt;n)&#123;\n        for(int i&#x3D;r;i&lt;n;i++)&#123;\n            if(a[i][n]!&#x3D;0)&#123;\n                return -1;\n            &#125;\n        &#125;\n        return 1;\n    &#125;\n    for(int i&#x3D;n-1;i&gt;&#x3D;0;i--)&#123;\n        for(int j&#x3D;i+1;j&lt;n;j++)&#123;\n            a[i][n]^&#x3D;a[i][j]*a[j][n];\n        &#125;\n    &#125;\n    return 0;\n&#125;\n\nint main()&#123;\n    cin&gt;&gt;n;\n    for(int i&#x3D;0;i&lt;n;i++)&#123;\n        for(int j&#x3D;0;j&lt;&#x3D;n;j++)&#123;\n            cin&gt;&gt;a[i][j];\n        &#125;\n    &#125;\n    int res&#x3D;gauss();\n    if(res&#x3D;&#x3D;0)&#123;\n        for(int i&#x3D;0;i&lt;n;i++)&#123;\n            cout&lt;&lt;a[i][n]&lt;&lt;endl;\n        &#125;\n    &#125;\n    else if(res&#x3D;&#x3D;1)&#123;\n        cout&lt;&lt;&quot;Multiple sets of solutions&quot;&lt;&lt;endl;\n    &#125;\n    else&#123;\n        cout&lt;&lt;&quot;No solution&quot;&lt;&lt;endl;\n    &#125;\n    \n    return 0;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>OK。那么这就是这天的全部内容了。<br>Bye~</p>\n","text":"今天的内容是使用高斯消元解线性方程组和异或方程组。什么是高斯消元，不多说，线代的基本内容。 高斯消元解线性方程组用高斯消元解线性方程组的时候，编程解决其实就是一个模拟的事情。我们写程序去模拟我们的实际进行的步骤。该模板的时间复杂度为O(n^3)。可以看到时间复杂度还是很高的。如果...","link":"","photos":[],"count_time":{"symbolsCount":"4.7k","symbolsTime":"4 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":39,"path":"api/tags/ACM.json"},{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"学习","slug":"学习","count":42,"path":"api/tags/学习.json"},{"name":"数学","slug":"数学","count":7,"path":"api/tags/数学.json"},{"name":"高斯消元","slug":"高斯消元","count":1,"path":"api/tags/高斯消元.json"},{"name":"解方程组","slug":"解方程组","count":1,"path":"api/tags/解方程组.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83%E8%A7%A3%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84\"><span class=\"toc-text\">高斯消元解线性方程组</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83%E8%A7%A3%E5%BC%82%E6%88%96%E6%96%B9%E7%A8%8B%E7%BB%84\"><span class=\"toc-text\">高斯消元解异或方程组</span></a></li></ol>","author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"喜欢前沿科技，想要见证人类科学的飞跃","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}},"mapped":true,"prev_post":{"title":"ACM学习笔记day27(求组合数的四种办法)","uid":"ee586e84b57b3261ae39e785bb3a8c62","slug":"ACM学习笔记day27","date":"2023-02-05T09:20:05.000Z","updated":"2023-04-08T10:52:38.582Z","comments":true,"path":"api/articles/ACM学习笔记day27.json","keywords":null,"cover":"/img/codeforces.jpg","text":"今天的内容是求组合数の四种办法。前三种是逐渐应对给的数据量变大的情况的。第四种是应对得到的结果太大会把longlong都爆掉的情况的。 注意：本篇中，涉及C[a][b]的均是以下组合数表达式。 因为这个blog主题不支持latex语言，所以也没办法现敲公式。 求组合数I这种求组合...","link":"","photos":[],"count_time":{"symbolsCount":"6.2k","symbolsTime":"6 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":39,"path":"api/tags/ACM.json"},{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"学习","slug":"学习","count":42,"path":"api/tags/学习.json"},{"name":"数学","slug":"数学","count":7,"path":"api/tags/数学.json"},{"name":"组合数","slug":"组合数","count":2,"path":"api/tags/组合数.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"喜欢前沿科技，想要见证人类科学的飞跃","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}},"next_post":{"title":"ACM学习笔记day25(扩展中国剩余定理)","uid":"3f5d2f03fa2075448efe1519bfee1297","slug":"ACM学习笔记day25","date":"2023-02-03T10:09:28.000Z","updated":"2023-04-08T10:52:24.226Z","comments":true,"path":"api/articles/ACM学习笔记day25.json","keywords":null,"cover":"/img/codeforces.jpg","text":"大标题就是题目链接。这节的内容是扩展CRT。其实就是在原来的基础上去掉了模数两两互质的条件。这样的话CRT就不能用了，得用扩展中国剩余定理。虽然说是扩展CRT，但是其实和CRT没什么关系，是一种解决这类问题的方法罢了 CRT解决的是什么问题，可以看我的上一篇博客，就在上面一篇。这...","link":"","photos":[],"count_time":{"symbolsCount":"1.6k","symbolsTime":"1 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"学习","slug":"学习","count":42,"path":"api/tags/学习.json"},{"name":"数论","slug":"数论","count":5,"path":"api/tags/数论.json"},{"name":"扩展中国剩余定理","slug":"扩展中国剩余定理","count":1,"path":"api/tags/扩展中国剩余定理.json"},{"name":"数学","slug":"数学","count":7,"path":"api/tags/数学.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"喜欢前沿科技，想要见证人类科学的飞跃","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}}}