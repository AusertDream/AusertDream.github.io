{"title":"ACM学习笔记day3(高精度四则运算)","uid":"ffffeb1fbf512f768ee4d72750569670","slug":"ACM学习笔记day3","date":"2022-11-08T14:01:59.000Z","updated":"2023-04-08T10:49:48.429Z","comments":true,"path":"api/articles/ACM学习笔记day3.json","keywords":null,"cover":"/img/codeforces.jpg","content":"<p>学习ACM有关东西的第四天。<br><br>今天用晚上时间稍微学了点高精度加减乘除的运算。<br><br>感觉是在模拟人类的运算过程，除了乘法(<del>这不废话</del>)<br><br>So,Here we go!<br></p>\n<span id=\"more\"></span>\n\n\n\n<h2 id=\"总述\"><a href=\"#总述\" class=\"headerlink\" title=\"总述\"></a>总述</h2><h2 id=\"有必要说明一下，对于高精度的四则运算，加法和减法是两个高精度的数字，而乘法和除法是一个高精度乘或者除以一个数同时因为数字的位数很大，在C嘎嘎中没有数据类型可以存放，实际上我们是用string接受，然后转存入vector数组当中去的要注意，存放的过程，应该为逆序的过程，就是倒着存放，为了方便之后我们加减法和乘法的运算这个过程不难，不多赘述-高精度加法\"><a href=\"#有必要说明一下，对于高精度的四则运算，加法和减法是两个高精度的数字，而乘法和除法是一个高精度乘或者除以一个数同时因为数字的位数很大，在C嘎嘎中没有数据类型可以存放，实际上我们是用string接受，然后转存入vector数组当中去的要注意，存放的过程，应该为逆序的过程，就是倒着存放，为了方便之后我们加减法和乘法的运算这个过程不难，不多赘述-高精度加法\" class=\"headerlink\" title=\"有必要说明一下，对于高精度的四则运算，加法和减法是两个高精度的数字，而乘法和除法是一个高精度乘或者除以一个数同时因为数字的位数很大，在C嘎嘎中没有数据类型可以存放，实际上我们是用string接受，然后转存入vector数组当中去的要注意，存放的过程，应该为逆序的过程，就是倒着存放，为了方便之后我们加减法和乘法的运算这个过程不难，不多赘述***高精度加法\"></a>有必要说明一下，对于高精度的四则运算，加法和减法是两个高精度的数字，而乘法和除法是一个高精度乘或者除以一个数<br><br>同时因为数字的位数很大，在C嘎嘎中没有数据类型可以存放，实际上我们是用string接受，然后转存入vector数组当中去的<br><br>要注意，存放的过程，应该为逆序的过程，就是倒着存放，为了方便之后我们加减法和乘法的运算<bn><br>这个过程不难，不多赘述<br><br>***<br>高精度加法</h2><p>对于高精度加法，我们采用的方式，模拟正常的加法运算，同时采用一个t来记录进位。<br>For example：</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>123+22<br><br>123<br><br>&amp;ensp;22<br><br>——————<br></p></blockquote>\n<p>我们对于这里，个位3和2加，等于5存入res数组，这里进位t&#x3D;0<br><br>如果有进位，这里的t&#x3D;1,else t&#x3D;0<br><br>就这样一次进行下去<br><br>因为vector是倒序存储的，而运算是低位开始的，所以函数中我们就从零开始<br><br>最后要附加一个，如果t不为零的话，要再pushback进res数组里面<br><br>下面为一个模板<br></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nconstexpr auto INF &#x3D; 2100000000;\nconstexpr auto INF64 &#x3D; 1e18;\n\nvector&lt;int&gt; add(vector&lt;int&gt;&amp; a, vector&lt;int&gt;&amp; b) &#123;\n    vector&lt;int&gt; res;\n    int t &#x3D; 0;\n    for (int i &#x3D; 0;i&lt;a.size()||i&lt;b.size(); i++) &#123;\n        if (i &lt; a.size()) t +&#x3D; a[i];\n        if (i &lt; b.size()) t +&#x3D; b[i];\n        res.push_back(t % 10);\n        t &#x2F;&#x3D; 10;\n    &#125;\n    if (t) res.push_back(1); &#x2F;&#x2F;注意这里，最后的时候t可能是1的，这个时候要记得把这个进位的1加入到res数组里面\n    return res;\n&#125;\n\nint main()\n&#123;\n    string a,b;\n    cin &gt;&gt; a&gt;&gt;b;\n    vector&lt;int&gt; c,d;\n    for (int i &#x3D; a.size()-1; i &gt;&#x3D; 0; i--) &#123;\n        c.push_back(a[i] - &#39;0&#39;);\n    &#125;\n    for (int i &#x3D; b.size() - 1; i &gt;&#x3D; 0; i--) &#123;\n        d.push_back(b[i] - &#39;0&#39;);\n    &#125;\n    vector&lt;int&gt; e;\n    e &#x3D; add(c, d);\n    for (int i &#x3D; e.size() - 1; i &gt;&#x3D; 0; i--) &#123;\n        cout &lt;&lt; e[i];\n    &#125;\n    cout &lt;&lt; endl;\n    return 0;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<hr>\n<h2 id=\"高精度减法\"><a href=\"#高精度减法\" class=\"headerlink\" title=\"高精度减法\"></a>高精度减法</h2><p>高精度减法的思路和正常做减法其实差不多。<br><br>当然，这里要注意，为了方便处理，我们采用的是大的那个数去减小的那个数，如果输入的是小的减大的，那就交换一下，然后结果加个负号就可以了<br><br>减法中，我们对于其中的一个数字，同样使用一个t作为借位。<br><br>那么其实，对于每一位，他的运算就是a[i]-t-b[i].当然，如果此时的i超过了b数组的边界，那么就减掉t就可以了<br><br>这里我们处理一下，加个条件即可。<br><br>下面为一个可用模板：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nconstexpr auto INF &#x3D; 2100000000;\nconstexpr auto INF64 &#x3D; 1e18;\n\n&#x2F;&#x2F;用来比较两个数字的大小的函数，如果a大于b则返回true\nbool cmp(vector&lt;int&gt; a, vector&lt;int&gt; b) &#123;\n    if (a.size() !&#x3D; b.size()) return a.size() &gt; b.size();\n    else &#123;\n        for (int i &#x3D; a.size()-1; i &gt;&#x3D; 0; i--) &#123;\n            if (a[i] - b[i] &gt; 0) &#123;\n                return true;\n            &#125;\n            else if (a[i] - b[i] &lt; 0) &#123;\n                return false;\n            &#125;\n        &#125;\n    &#125;\n    return true;\n&#125;\n\nvector&lt;int&gt; _minus(vector&lt;int&gt;&amp; a, vector&lt;int&gt;&amp; b) &#123;\n    int t &#x3D; 0;\n    vector&lt;int&gt; c;\n    for (int i &#x3D; 0; i &lt; a.size(); i++) &#123;\n        t &#x3D; a[i] - t; &#x2F;&#x2F;先运算a[i]-t,因为a肯定是大的那个.\n        if (i &lt; b.size()) t -&#x3D; b[i];\n        c.push_back((t+10)%10); &#x2F;&#x2F;注意，这里因为从上一位可能借了一个10过来，所以要加个10再取余\n        if (t &lt; 0) &#123;\n            t &#x3D; 1;\n        &#125;\n        else &#123;\n            t &#x3D; 0;\n        &#125;\n    &#125;\n    &#x2F;&#x2F;也是很关键的一步，记得要把高位的前导零给去除。\n    while (c.size() &gt; 1 &amp;&amp; c.back() &#x3D;&#x3D; 0) &#123; \n        c.pop_back();\n    &#125;\n    return c;\n&#125;\n\nint main()\n&#123;\n    string a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n    vector&lt;int&gt; c, d;\n    for (int i &#x3D; a.size()-1; i &gt;&#x3D; 0; i--) &#123;\n        c.push_back(a[i] - &#39;0&#39;);\n    &#125;\n    for (int i &#x3D; b.size()-1; i &gt;&#x3D; 0; i--) &#123;\n        d.push_back(b[i] - &#39;0&#39;);\n    &#125;\n    vector&lt;int&gt; e;\n    if (cmp(c, d)) &#123;\n        e &#x3D; _minus(c, d);\n        for (int i &#x3D; e.size() - 1; i &gt;&#x3D; 0; i--) &#123;\n            cout &lt;&lt; e[i];\n        &#125;\n        cout &lt;&lt; endl;\n    &#125;\n    else &#123;\n        e &#x3D; _minus(d,c);\n        cout &lt;&lt; &#39;-&#39;;\n        for (int i &#x3D; e.size() - 1; i &gt;&#x3D; 0; i--) &#123;\n            cout &lt;&lt; e[i];\n        &#125;\n        cout &lt;&lt; endl;\n    &#125;\n    return 0;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<hr>\n<h2 id=\"高精度乘法\"><a href=\"#高精度乘法\" class=\"headerlink\" title=\"高精度乘法\"></a>高精度乘法</h2><p>高精度乘法的算法其实和我们一般的计算方法不太一样<br><br>我们一般计算乘法是一位一位乘的，但在这里是把那个较小的数字b看成一个整体<br><br>然后把a[i]*b的值去赋给t<br><br>同时让t&#x2F;10作为进位，让t%10作为push进res数组里面的数字<br><br>最后不要忘了清理掉前导零<br><br>下面为一个可用模板:</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nconstexpr auto INF &#x3D; 2100000000;\nconstexpr auto INF64 &#x3D; 1e18;\n\n\n\nvector&lt;int&gt; multiple(vector&lt;int&gt;&amp; a, int b) &#123;\n    long long  t &#x3D; 0;\n    vector&lt;int&gt; ans;\n    for (int i &#x3D; 0; i &lt; a.size(); i++) &#123;\n        t +&#x3D; a[i] * b;\n        ans.push_back(t % 10);\n        t &#x3D; t &#x2F; 10; &#x2F;&#x2F;这里t要自除一个10，因为如果有进位的话，是被用掉了\n    &#125;\n    &#x2F;&#x2F;这里要不断的将t多出来的进位push进ans里面，说实话\n    &#x2F;&#x2F;这里我也不是很懂，因为采用的算法不是一般的算法，暂时先当模板记住好了\n    while (t) &#123;\n     ans.push_back(t % 10);\n     t &#x2F;&#x3D; 10;\n    &#125;\n    &#x2F;&#x2F;清楚前导零\n    while (ans.size() &gt; 1&amp;&amp;ans.back()&#x3D;&#x3D;0) &#123;\n        ans.pop_back();\n    &#125;\n    return ans;\n&#125;\n\nint main()\n&#123;\n    string a;\n    cin &gt;&gt; a;\n    int b;\n    cin &gt;&gt; b;\n    vector&lt;int&gt; c;\n    for (int i &#x3D; a.size()-1; i &gt;&#x3D; 0; i--) &#123;\n        c.push_back(a[i] - &#39;0&#39;);\n    &#125;\n    vector&lt;int&gt; e;\n    e &#x3D; multiple(c, b);\n    for (int i &#x3D; e.size() - 1; i &gt;&#x3D; 0; i--) &#123;\n        cout &lt;&lt; e[i];\n    &#125;\n    cout &lt;&lt; endl;\n    return 0;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<hr>\n<h2 id=\"高精度除法\"><a href=\"#高精度除法\" class=\"headerlink\" title=\"高精度除法\"></a>高精度除法</h2><p>高精度除法的算法，和上面的有点不同，不同的地方在于，他是从高位开始看的。<br><br>当然实际运算和我们正常算是差不多的<br><br>只不过我们要用一个r来代表余数<br><br>下面为一个可用的模板：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nconstexpr auto INF &#x3D; 2100000000;\nconstexpr auto INF64 &#x3D; 1e18;\n\nvector&lt;int&gt; divide(vector&lt;int&gt;&amp; a, int b,int&amp; r) &#123;\n    vector&lt;int&gt; res;\n    for (int i &#x3D; a.size() - 1; i &gt;&#x3D; 0; i--) &#123;\n        r &#x3D; r * 10 + a[i]; &#x2F;&#x2F;每次的余数都是上一个余数乘10，加上当前的数字这个是还没用于计算的\n        res.push_back(r &#x2F; b); &#x2F;&#x2F;相当于实际进行一个除法运算\n        r %&#x3D; b;&#x2F;&#x2F;除完了，剩下的就是余数，让r自等\n    &#125;\n    reverse(res.begin(), res.end()); &#x2F;&#x2F;反转数组，因为我们这里是从高位开始运算的，而输出的以为是倒序的数组\n    while (res.size() &gt; 1 &amp;&amp; res.back() &#x3D;&#x3D; 0) &#123;\n        res.pop_back();&#x2F;&#x2F;清除掉前导零\n    &#125;\n    return res;\n&#125;\nint main()\n&#123;\n    string a;\n    cin &gt;&gt; a;\n    int b;\n    cin &gt;&gt; b;\n    vector&lt;int&gt; c;\n    for (int i &#x3D; a.size()-1; i &gt;&#x3D; 0; i--) &#123;\n        c.push_back(a[i] - &#39;0&#39;);\n    &#125;\n    vector&lt;int&gt; e;\n    int r &#x3D; 0;\n    e &#x3D; divide(c, b, r);\n    for (int i &#x3D; e.size() - 1; i &gt;&#x3D; 0; i--) &#123;\n        cout &lt;&lt; e[i];\n    &#125;\n    cout &lt;&lt; endl &lt;&lt; r &lt;&lt; endl;\n    return 0;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>emmm<br>That’s all!<br>Bye~</p>\n","text":"学习ACM有关东西的第四天。今天用晚上时间稍微学了点高精度加减乘除的运算。感觉是在模拟人类的运算过程，除了乘法(这不废话)So,Here we go! 总述有必要说明一下，对于高精度的四则运算，加法和减法是两个高精度的数字，而乘法和除法是一个高精度乘或者除以一个数同时因为数字的位...","link":"","photos":[],"count_time":{"symbolsCount":"6.6k","symbolsTime":"6 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"学习","slug":"学习","count":42,"path":"api/tags/学习.json"},{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"ACM","slug":"ACM","count":39,"path":"api/tags/ACM.json"},{"name":"数据结构","slug":"数据结构","count":23,"path":"api/tags/数据结构.json"},{"name":"算法","slug":"算法","count":20,"path":"api/tags/算法.json"},{"name":"蒟蒻","slug":"蒟蒻","count":4,"path":"api/tags/蒟蒻.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%80%BB%E8%BF%B0\"><span class=\"toc-text\">总述</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%9C%89%E5%BF%85%E8%A6%81%E8%AF%B4%E6%98%8E%E4%B8%80%E4%B8%8B%EF%BC%8C%E5%AF%B9%E4%BA%8E%E9%AB%98%E7%B2%BE%E5%BA%A6%E7%9A%84%E5%9B%9B%E5%88%99%E8%BF%90%E7%AE%97%EF%BC%8C%E5%8A%A0%E6%B3%95%E5%92%8C%E5%87%8F%E6%B3%95%E6%98%AF%E4%B8%A4%E4%B8%AA%E9%AB%98%E7%B2%BE%E5%BA%A6%E7%9A%84%E6%95%B0%E5%AD%97%EF%BC%8C%E8%80%8C%E4%B9%98%E6%B3%95%E5%92%8C%E9%99%A4%E6%B3%95%E6%98%AF%E4%B8%80%E4%B8%AA%E9%AB%98%E7%B2%BE%E5%BA%A6%E4%B9%98%E6%88%96%E8%80%85%E9%99%A4%E4%BB%A5%E4%B8%80%E4%B8%AA%E6%95%B0%E5%90%8C%E6%97%B6%E5%9B%A0%E4%B8%BA%E6%95%B0%E5%AD%97%E7%9A%84%E4%BD%8D%E6%95%B0%E5%BE%88%E5%A4%A7%EF%BC%8C%E5%9C%A8C%E5%98%8E%E5%98%8E%E4%B8%AD%E6%B2%A1%E6%9C%89%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%AF%E4%BB%A5%E5%AD%98%E6%94%BE%EF%BC%8C%E5%AE%9E%E9%99%85%E4%B8%8A%E6%88%91%E4%BB%AC%E6%98%AF%E7%94%A8string%E6%8E%A5%E5%8F%97%EF%BC%8C%E7%84%B6%E5%90%8E%E8%BD%AC%E5%AD%98%E5%85%A5vector%E6%95%B0%E7%BB%84%E5%BD%93%E4%B8%AD%E5%8E%BB%E7%9A%84%E8%A6%81%E6%B3%A8%E6%84%8F%EF%BC%8C%E5%AD%98%E6%94%BE%E7%9A%84%E8%BF%87%E7%A8%8B%EF%BC%8C%E5%BA%94%E8%AF%A5%E4%B8%BA%E9%80%86%E5%BA%8F%E7%9A%84%E8%BF%87%E7%A8%8B%EF%BC%8C%E5%B0%B1%E6%98%AF%E5%80%92%E7%9D%80%E5%AD%98%E6%94%BE%EF%BC%8C%E4%B8%BA%E4%BA%86%E6%96%B9%E4%BE%BF%E4%B9%8B%E5%90%8E%E6%88%91%E4%BB%AC%E5%8A%A0%E5%87%8F%E6%B3%95%E5%92%8C%E4%B9%98%E6%B3%95%E7%9A%84%E8%BF%90%E7%AE%97%E8%BF%99%E4%B8%AA%E8%BF%87%E7%A8%8B%E4%B8%8D%E9%9A%BE%EF%BC%8C%E4%B8%8D%E5%A4%9A%E8%B5%98%E8%BF%B0-%E9%AB%98%E7%B2%BE%E5%BA%A6%E5%8A%A0%E6%B3%95\"><span class=\"toc-text\">有必要说明一下，对于高精度的四则运算，加法和减法是两个高精度的数字，而乘法和除法是一个高精度乘或者除以一个数同时因为数字的位数很大，在C嘎嘎中没有数据类型可以存放，实际上我们是用string接受，然后转存入vector数组当中去的要注意，存放的过程，应该为逆序的过程，就是倒着存放，为了方便之后我们加减法和乘法的运算这个过程不难，不多赘述***高精度加法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%AB%98%E7%B2%BE%E5%BA%A6%E5%87%8F%E6%B3%95\"><span class=\"toc-text\">高精度减法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%AB%98%E7%B2%BE%E5%BA%A6%E4%B9%98%E6%B3%95\"><span class=\"toc-text\">高精度乘法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%AB%98%E7%B2%BE%E5%BA%A6%E9%99%A4%E6%B3%95\"><span class=\"toc-text\">高精度除法</span></a></li></ol>","author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"喜欢前沿科技，想要见证人类科学的飞跃","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}},"mapped":true,"prev_post":{"title":"ACM学习笔记day4(前缀和和差分)","uid":"4143f6a2444e4122fe8da477a7a2d540","slug":"ACM学习笔记day4","date":"2022-11-09T14:02:19.000Z","updated":"2023-04-08T10:49:05.915Z","comments":true,"path":"api/articles/ACM学习笔记day4.json","keywords":null,"cover":"/img/codeforces.jpg","text":"今天学了前缀和和差分，及其数组。前缀和不多说了，比较好理解，主要还是差分，这个比较抽象 前缀和主要注意一下，前缀和数组从1开始，0的位置就归零，这样就不用地方越界问题了。 差分至于差分。emmmm差分数组不需要构建，~~~当然也可以构建~~~二位差分同理 int a[N],B[N...","link":"","photos":[],"count_time":{"symbolsCount":875,"symbolsTime":"1 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"学习","slug":"学习","count":42,"path":"api/tags/学习.json"},{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"ACM","slug":"ACM","count":39,"path":"api/tags/ACM.json"},{"name":"数据结构","slug":"数据结构","count":23,"path":"api/tags/数据结构.json"},{"name":"算法","slug":"算法","count":20,"path":"api/tags/算法.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"喜欢前沿科技，想要见证人类科学的飞跃","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}},"next_post":{"title":"ACM学习笔记day2","uid":"a8b932df9b747ba9300a0aa8e66533aa","slug":"ACM学习笔记day2","date":"2022-11-07T02:41:28.000Z","updated":"2023-04-08T10:50:24.513Z","comments":true,"path":"api/articles/ACM学习笔记day2.json","keywords":null,"cover":"/img/codeforces.jpg","text":"hello guys！这里是Ausert！这里是我学习ACM相关知识打卡的地方，当然，不会是一些学习笔记啥的(后面被打脸了QAQ)只是一些小的注意点，或者心得啥的不要问我为什么没有day1的打卡博客。因为那个时候网站还没有搭建起来&#x3D; &#x3D;So here we g...","link":"","photos":[],"count_time":{"symbolsCount":579,"symbolsTime":"1 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"学习","slug":"学习","count":42,"path":"api/tags/学习.json"},{"name":"ACM","slug":"ACM","count":39,"path":"api/tags/ACM.json"},{"name":"数据结构","slug":"数据结构","count":23,"path":"api/tags/数据结构.json"},{"name":"算法","slug":"算法","count":20,"path":"api/tags/算法.json"},{"name":"打卡（大概）","slug":"打卡（大概）","count":1,"path":"api/tags/打卡（大概）.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"喜欢前沿科技，想要见证人类科学的飞跃","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}}}