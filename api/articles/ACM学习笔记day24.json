{"title":"ACM学习笔记day24(扩展欧几里得算法，线性同余方程，中国剩余定理)","uid":"e8f352fc1ae41c272b21fc150a45992f","slug":"ACM学习笔记day24","date":"2023-02-02T14:25:04.000Z","updated":"2023-04-08T10:52:17.703Z","comments":true,"path":"api/articles/ACM学习笔记day24.json","keywords":null,"cover":"/img/codeforces.jpg","content":"<p>emm，好像距离上次写博客好像是很久以前了呢(<del>懒狗，摆烂王是吧</del>)<br>话不多说，直接进入正题，今天的内容是扩展欧几里得算法和CRT，也就是中国剩余定理，或者也叫孙子定理。</p>\n<span id=\"more\"></span>\n\n<h1 id=\"扩展欧几里得算法\"><a href=\"#扩展欧几里得算法\" class=\"headerlink\" title=\"扩展欧几里得算法\"></a><a href=\"https://www.acwing.com/problem/content/879/\">扩展欧几里得算法</a></h1><p>这个算法其实和欧几里得算法很像，都是用到了辗转相除法。<br>只不过在辗转相除的同时，一边算了一个GCD，一边又解决了一个解二元一次方程的问题。<br>我们使用扩展欧几里得算法，想要解决的是这样一个方程。<br>其中只有x和y是未知数。<br><img src=\"https://raw.githubusercontent.com/AusertDream/MyblogImags/main/2023%E5%B9%B42%E6%9C%882%E6%97%A5223501.png\" alt=\"1\"></p>\n<p>其中我们要涉及到一个裴蜀定理。<br>对于方程</p>\n<p><img src=\"https://raw.githubusercontent.com/AusertDream/MyblogImags/main/2023%E5%B9%B42%E6%9C%882%E6%97%A5223656.png\" alt=\"11\"></p>\n<p>该方程，x和y是一定有解的，那么对于上面一条方程而言，当且仅当c能够正好被gcd(a,b)整除的时候，才有解。<br>也就是说：</p>\n<p><img src=\"https://raw.githubusercontent.com/AusertDream/MyblogImags/main/2023%E5%B9%B42%E6%9C%882%E6%97%A5224609.png\" alt=\"22\"></p>\n<p>我们接下来给出扩欧的代码，结合代码来讲解。<br>注意，讲解只是辅助理解的，具体的原理以及严格的数学证明，这里不多赘述(<del>其实是我不会</del>)</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">int exgcd(int a,int b,int&amp; x,int&amp; y)&#123;\n    if(b&#x3D;&#x3D;0)&#123;\n        x&#x3D;1,y&#x3D;0;\n        return a;\n    &#125;\n    int t &#x3D; exgcd(b,a%b,y,x);\n    y-&#x3D;a&#x2F;b*x;\n    return t;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n<p>代码中，四个参数对应的方程就是a*x+b*y记住这个关系。<br>我们每次辗转相除的时候，会交换a，b的位置，所以这里x和y也要交换。<br>不交换也可以的，不过下面x和y更改的数值就要麻烦点了。<br>这里讲解交换位置的，不交换位置的不讲解。<br>首先我们对于辗转相除到最后一步的时候，这个时候，a是a，b是0，很明显，有一组解，x&#x3D;1,y&#x3D;0。<br>这个当然是一个解。然后我们来到中间步骤，我们发现，此时的表达式为</p>\n<p><img src=\"https://raw.githubusercontent.com/AusertDream/MyblogImags/main/2023%E5%B9%B42%E6%9C%882%E6%97%A5225625.png\" alt=\"111\"></p>\n<p>不难发现，a%b可以写成a-a&#x2F;b*b(这里a&#x2F;b是计算机中的除法，也就是向下取整)<br>那么原式子化为：</p>\n<p><img src=\"https://raw.githubusercontent.com/AusertDream/MyblogImags/main/2023%E5%B9%B42%E6%9C%882%E6%97%A5225736.png\" alt=\"121\"></p>\n<p>将式子对于a和b合并一下同类项。</p>\n<p><img src=\"https://raw.githubusercontent.com/AusertDream/MyblogImags/main/2023%E5%B9%B42%E6%9C%882%E6%97%A5225800.png\" alt=\"11211\"></p>\n<p>让我们再回想一下，原式子的关系，是a*x+b*y对吧。<br>所以我们发现，在每次辗转的过程中，x没有变，y每次都要减去a&#x2F;b*x。<br>因此模板中，return上面一句是y-&#x3D;a&#x2F;b*x;</p>\n<p>综上就是对于这个模板的辅助理解内容了。<br>注意这个只是辅助理解，同时帮助记忆这个公式。<br>非原理，别杠。</p>\n<p>下面为acwing上这题的ac code：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\n\nint exgcd(int a,int b,int&amp; x,int&amp; y)&#123;\n    if(b&#x3D;&#x3D;0)&#123;\n        x&#x3D;1,y&#x3D;0;\n        return a;\n    &#125;\n    int t &#x3D; exgcd(b,a%b,y,x);\n    y-&#x3D;a&#x2F;b*x;\n    return t;\n&#125;\n\nint main()&#123;\n    int n;\n    cin&gt;&gt;n;\n    while(n--)&#123;\n        int a,b;\n        cin&gt;&gt;a&gt;&gt;b;\n        int x,y;\n        exgcd(a,b,x,y);\n        cout&lt;&lt;x&lt;&lt;&quot; &quot;&lt;&lt;y&lt;&lt;endl;\n    &#125;\n    return 0;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n<h1 id=\"线性同余方程\"><a href=\"#线性同余方程\" class=\"headerlink\" title=\"线性同余方程\"></a><a href=\"https://www.acwing.com/problem/content/880/\">线性同余方程</a></h1><p>这个其实是扩欧的一个应用。<br>题目让你求这个</p>\n<p><img src=\"https://raw.githubusercontent.com/AusertDream/MyblogImags/main/2023%E5%B9%B42%E6%9C%882%E6%97%A5230026.png\" alt=\"2312\"></p>\n<p>我们对于取mod来说是什么<br>比如a%b&#x3D;c。<br>我们可以改写成a&#x3D;b*k+c (k&#x3D;….-2,-1,0,1,2….)<br>所以我们可以改写一下这个方程式。也就是下面这个。</p>\n<p><img src=\"https://raw.githubusercontent.com/AusertDream/MyblogImags/main/2023%E5%B9%B42%E6%9C%882%E6%97%A5230335.png\" alt=\"212\"></p>\n<p>注意这里的k可以为负数的，我左边如果乘积是个很小的负数，那右边不自然得是负数的k吗？</p>\n<p>然后我们移项。</p>\n<p><img src=\"https://raw.githubusercontent.com/AusertDream/MyblogImags/main/2023%E5%B9%B42%E6%9C%882%E6%97%A5230519.png\" alt=\"22222\"></p>\n<p>观察我们这个式子，我们发现，未知数只有xi和k，那这一看，不就是扩欧的标准形式吗，只不过k多了个负号。<br>这里作一个k&#x3D;-k的换元，就是加法了。<br>因为这题我们只要求x，对于这个k没有要求，所以不用管他的正负。<br>接下来只要对这个式子套exgcd的模板就可以了。<br>exgcd(ai,mi,xi,k)<br>当然要注意是否有解的情况，bi得是gcd(ai,mi)的倍数。</p>\n<p>ac code:</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\n\nll exgcd(ll a,ll b,ll&amp; x,ll&amp; y)&#123;\n    if(b&#x3D;&#x3D;0)&#123;\n        x&#x3D;1,y&#x3D;0;\n        return a;\n    &#125;\n    ll t&#x3D;exgcd(b,a%b,y,x);\n    y-&#x3D;a&#x2F;b*x;\n    return t;\n&#125;\n\nint main()&#123;\n    int n;\n    cin&gt;&gt;n;\n    while(n--)&#123;\n        ll a,b,m;\n        cin&gt;&gt;a&gt;&gt;b&gt;&gt;m;\n        ll  x,y;\n        ll t&#x3D; exgcd(a,m,x,y);\n        if(b%t!&#x3D;0)&#123;\n            cout&lt;&lt;&quot;imposssible&quot;&lt;&lt;endl;\n        &#125;\n        else&#123;\n            cout&lt;&lt;x*(b&#x2F;t)%m&lt;&lt;endl;\n        &#125;\n    &#125;\n    \n    return 0;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n<h1 id=\"中国剩余定理\"><a href=\"#中国剩余定理\" class=\"headerlink\" title=\"中国剩余定理\"></a><a href=\"https://www.acwing.com/problem/content/1300/\">中国剩余定理</a></h1><p>什么是中国剩余定理？<br>其实中国剩余定理就是一个公式，他解决的是以下的这个问题。</p>\n<p>对于以下的方程组，求解x。<br></p>\n<p><img src=\"https://raw.githubusercontent.com/AusertDream/MyblogImags/main/2023%E5%B9%B42%E6%9C%883%E6%97%A5170104.png\" alt=\"121\"></p>\n<p>其中模数mi全部两两互质。(这是一个很关键的条件。)<br>那么这里中国剩余定理给出了一个x的公式解。<br>如下：</p>\n<p>我们定义</p>\n<p><img src=\"https://raw.githubusercontent.com/AusertDream/MyblogImags/main/2023%E5%B9%B42%E6%9C%883%E6%97%A5170843.png\" alt=\"8485\"></p>\n<p>注意：为什么要强调mi两两互质，因为Mi存在mod mi的逆元的前提是Mi和mi互质，因为所有的mi都是两两互质的，那么Mi和mi也一定是互质的。如此，这个Mi的逆元才一定会存在。<br><br>那么我们的x的一个解就可以表示为：</p>\n<p><img src=\"https://raw.githubusercontent.com/AusertDream/MyblogImags/main/11.png\" alt=\"12312313123\"></p>\n<p>这个x的值就是中国剩余定理的结果。<br>为什么这里说是x的一个解，因为方程组完全有可能是有其他的解的。<br>接下来我们简单理解一下这个公式。<br>我们对于方程组中第i个方程，不难发现。<br>x求和中第i个数字，因为是mod mi下的所以Mi和Mi的逆元自然为1，那么结果也就自然为ai<br>对于求和中的非第i个数字，比如第j个数字，因为Mj中肯定包含了mi，所以乘积式子中也一定包含了mi，所以mod mi的结果一定为零。<br>这样我们就验证了这个结果的正确性。<br>所以求解这个方程组就变成了，求解Mi和他的逆元的问题了。<br>Mi好求的，对于Mi的逆元。<br>这里不能使用费马小定理，用快速幂求解，因为我们不能确保我们的模数一定是质数。<br>所以我们就按照逆元的定义就可以了。<br>对于一个x mod a下的逆元，满足以下的式子。</p>\n<p><img src=\"https://raw.githubusercontent.com/AusertDream/MyblogImags/main/202323.jpg\" alt=\"563\"></p>\n<p>而对于这个式子，我们可以类比线性同余方程的办法，采用扩欧来做。<br>问题应该是不大的。</p>\n<p>下面为acwing上曹冲养猪的ac code：<br>这题就是纯CRT没啥技术含量的。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\n\nll exgcd(ll a,ll b , ll&amp; x,ll&amp; y)&#123;\n    if(b&#x3D;&#x3D;0)&#123;\n        x&#x3D;1,y&#x3D;0;\n        return a;\n    &#125;\n    ll d&#x3D; exgcd(b,a%b,y,x);\n    y-&#x3D;a&#x2F;b*x;\n    return d;\n&#125;\n\nint main()&#123;\n    int n;\n    cin&gt;&gt;n;\n    vector&lt;ll&gt; a(n),b(n);\n    ll product&#x3D;1;\n    for(int i&#x3D;0;i&lt;n;i++)&#123;\n        cin&gt;&gt;a[i]&gt;&gt;b[i];\n        product*&#x3D;a[i];\n    &#125;\n    ll res&#x3D;0;\n    for(int i&#x3D;0;i&lt;n;i++)&#123;\n        ll mi&#x3D;product&#x2F;a[i];\n        ll mi_,y;\n        exgcd(mi,a[i],mi_,y);\n        res+&#x3D;b[i]*mi*mi_;\n    &#125;\n    cout&lt;&lt;(res%product+product)%product&lt;&lt;endl;\n    return 0;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>OK，那么这里就是这次的全部内容了。<br>我们下次再见。<br>bye~ qwq</p>\n","text":"emm，好像距离上次写博客好像是很久以前了呢(懒狗，摆烂王是吧)话不多说，直接进入正题，今天的内容是扩展欧几里得算法和CRT，也就是中国剩余定理，或者也叫孙子定理。 扩展欧几里得算法这个算法其实和欧几里得算法很像，都是用到了辗转相除法。只不过在辗转相除的同时，一边算了一个GCD，...","link":"","photos":[],"count_time":{"symbolsCount":"4.1k","symbolsTime":"4 mins."},"categories":[{"name":"ACM","slug":"ACM","count":38,"path":"api/categories/ACM.json"}],"tags":[{"name":"打卡","slug":"打卡","count":34,"path":"api/tags/打卡.json"},{"name":"学习","slug":"学习","count":41,"path":"api/tags/学习.json"},{"name":"蒟蒻","slug":"蒟蒻","count":4,"path":"api/tags/蒟蒻.json"},{"name":"数论","slug":"数论","count":5,"path":"api/tags/数论.json"},{"name":"扩展欧几里得","slug":"扩展欧几里得","count":1,"path":"api/tags/扩展欧几里得.json"},{"name":"CRT","slug":"CRT","count":1,"path":"api/tags/CRT.json"},{"name":"中国剩余定理","slug":"中国剩余定理","count":1,"path":"api/tags/中国剩余定理.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">扩展欧几里得算法</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%BA%BF%E6%80%A7%E5%90%8C%E4%BD%99%E6%96%B9%E7%A8%8B\"><span class=\"toc-text\">线性同余方程</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86\"><span class=\"toc-text\">中国剩余定理</span></a></li></ol>","author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"喜欢前沿科技，想要见证人类科学的飞跃","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}},"mapped":true,"prev_post":{"title":"ACM学习笔记day25(扩展中国剩余定理)","uid":"3f5d2f03fa2075448efe1519bfee1297","slug":"ACM学习笔记day25","date":"2023-02-03T10:09:28.000Z","updated":"2023-04-08T10:52:24.226Z","comments":true,"path":"api/articles/ACM学习笔记day25.json","keywords":null,"cover":"/img/codeforces.jpg","text":"大标题就是题目链接。这节的内容是扩展CRT。其实就是在原来的基础上去掉了模数两两互质的条件。这样的话CRT就不能用了，得用扩展中国剩余定理。虽然说是扩展CRT，但是其实和CRT没什么关系，是一种解决这类问题的方法罢了 CRT解决的是什么问题，可以看我的上一篇博客，就在上面一篇。这...","link":"","photos":[],"count_time":{"symbolsCount":"1.6k","symbolsTime":"1 mins."},"categories":[{"name":"ACM","slug":"ACM","count":38,"path":"api/categories/ACM.json"}],"tags":[{"name":"打卡","slug":"打卡","count":34,"path":"api/tags/打卡.json"},{"name":"学习","slug":"学习","count":41,"path":"api/tags/学习.json"},{"name":"数论","slug":"数论","count":5,"path":"api/tags/数论.json"},{"name":"数学","slug":"数学","count":7,"path":"api/tags/数学.json"},{"name":"扩展中国剩余定理","slug":"扩展中国剩余定理","count":1,"path":"api/tags/扩展中国剩余定理.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"喜欢前沿科技，想要见证人类科学的飞跃","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}},"next_post":{"title":"ACM学习笔记day23(欧拉函数，筛法求欧拉函数，快速幂，快速幂求逆元)","uid":"ead55ceebbb5da582503c01cc4b636b6","slug":"ACM学习笔记day23","date":"2023-01-24T13:07:47.000Z","updated":"2023-04-08T10:52:11.128Z","comments":true,"path":"api/articles/ACM学习笔记day23.json","keywords":null,"cover":"/img/codeforces.jpg","text":"今天的内容是欧拉函数和快速幂，主要是这两个。其中最后那个逆元，emm感觉好难理解QAQ 欧拉函数欧拉函数的定义： 由定义我们容易得出，对于求一个数字N的欧拉函数的值，我们按照定义来就可以了。时间复杂度是O(sqrt(N))。因为分解质因数要根号n，然后乘法乘上去也是根号n。所以时...","link":"","photos":[],"count_time":{"symbolsCount":"5.8k","symbolsTime":"5 mins."},"categories":[{"name":"ACM","slug":"ACM","count":38,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":36,"path":"api/tags/ACM.json"},{"name":"打卡","slug":"打卡","count":34,"path":"api/tags/打卡.json"},{"name":"学习","slug":"学习","count":41,"path":"api/tags/学习.json"},{"name":"数论","slug":"数论","count":5,"path":"api/tags/数论.json"},{"name":"数学","slug":"数学","count":7,"path":"api/tags/数学.json"},{"name":"快速幂","slug":"快速幂","count":1,"path":"api/tags/快速幂.json"},{"name":"欧拉函数","slug":"欧拉函数","count":1,"path":"api/tags/欧拉函数.json"},{"name":"逆元","slug":"逆元","count":1,"path":"api/tags/逆元.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"喜欢前沿科技，想要见证人类科学的飞跃","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}}}