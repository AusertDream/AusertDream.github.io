{"title":"ACM学习笔记day40(无懒标记线段树)","uid":"f730cb1c16c6cae11f6020e8c15e8535","slug":"ACM学习笔记day40","date":"2023-08-26T14:16:45.000Z","updated":"2023-08-27T09:15:54.897Z","comments":true,"path":"api/articles/ACM学习笔记day40.json","keywords":null,"cover":"/img/codeforces.jpg","content":"<p>不带懒标记的线段树的板子。<br>注意代码中节点属性是区间的最大值。<br>下面为代码：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">struct node&#123;\n    int l,r;\n    int maxnum; \n&#125;;\nnode tree[N*4];\n\nvoid pushup(int u)&#123;\n    tree[u].maxnum&#x3D;max(tree[u*2].maxnum,tree[u*2+1].maxnum);\n&#125;\n\nvoid build(int u,int l,int r)&#123;\n    tree[u].l&#x3D;l,tree[u].r&#x3D;r;\n    if(l&#x3D;&#x3D;r) return;\n    else&#123;\n        int mid&#x3D;(l+r)&#x2F;2;\n        build(u*2,l,mid),build(u*2+1,mid+1,r); \n    &#125; \n&#125;\n\nvoid modify(int u,int x,int v)&#123;\n    if(x&#x3D;&#x3D;tree[u].l&amp;&amp;x&#x3D;&#x3D;tree[u].r)&#123;\n        tree[u].maxnum&#x3D;v;\n    &#125;  \n    else&#123;\n        int mid&#x3D;tree[u].l+tree[u].r&gt;&gt;1;\n        if(x&lt;&#x3D;mid)&#123;\n            modify(u*2,x,v);\n        &#125;\n        else&#123;\n            modify(u*2+1,x,v);\n        &#125;\n        pushup(u);\n    &#125;\n&#125;\n\nint query(int u,int l,int r)&#123;\n    if(tree[u].l&gt;&#x3D;l&amp;&amp;tree[u].r&lt;&#x3D;r)&#123;\n        return tree[u].maxnum;\n    &#125;\n    else&#123;\n        int res&#x3D;0;\n        int mid&#x3D;(tree[u].l+tree[u].r)&#x2F;2;\n        if(l&lt;&#x3D;mid)&#123;\n            res&#x3D;query(u*2,l,r);\n        &#125;\n        if(r&gt;mid)&#123;\n            res&#x3D;max(res,query(u*2+1,l,r));\n        &#125;\n        return res;\n    &#125;\n&#125;\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>以下是对于代码的一些解释。来辅助回忆和复习。</p>\n<p>线段树构造了如下的一个二叉树结构，节点上的值由题目需要会任意改变。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20200212110613475.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTY5Nzc3NA==,size_16,color_FFFFFF,t_70\" alt=\"11\"></p>\n<p>其实就是将一个数组按照区间分成了很多段，然后构建成了二叉树的形式。<br>节点在编号的时候是按照完全二叉树去编号的，而且除了最后一层，这个树就是一个完全二叉树，所以假设一个节点是u，那么他的左孩子节点就是2*u，右孩子就是2*u+1。<br>普通的线段树一共有四种操作。<br>分别是build——构建操作，pushup——用子节点去更新父节点的操作，modify——单点修改，query——区间查询。<br>因为不涉及区间修改，所以他不是懒标记线段树。</p>\n<p>一些注意事项：</p>\n<ol>\n<li>线段树的数组长度一般要开4*n的长度，n为输入的数据量。</li>\n<li>线段树的查询，修改操作都是logn级别的，不过会带一个常数4，也就是说时间复杂度是O(4logn)。</li>\n</ol>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F;build操作是将一个数组构建成一个线段树的过程。\nvoid build(int u,int l,int r)&#123; &#x2F;&#x2F;u是当前在哪个节点，l和r是在数据数组中的区间左右边界。\n    tree[u].l&#x3D;l,tree[u].r&#x3D;r; &#x2F;&#x2F;将当前节点的左右边界更改为l和r\n    if(l&#x3D;&#x3D;r) return; &#x2F;&#x2F;如果r已经等于l了，相当于就一个元素了，那就直接返回。\n    else&#123;\n        int mid&#x3D;(l+r)&#x2F;2;\n        build(u*2,l,mid),build(u*2+1,mid+1,r);  &#x2F;&#x2F;递归的处理左孩子和右孩子。分别分给他们一半的区间长度。\n    &#125; \n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F;pushup操作是根据孩子节点的信息来更新一下父节点的信息的操作。\nvoid pushup(int u)&#123;\n    tree[u].maxnum&#x3D;max(tree[u*2].maxnum,tree[u*2+1].maxnum); &#x2F;&#x2F;u代表当前节点，根据实际的含义进行更新即可。\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F;单点修改的操作的关键就在于找到我们修改的这个点，在线段树上的位置在哪里，修改完值之后，回溯的过程中用pushup更新父节点的值就可以了。\nvoid modify(int u,int x,int v)&#123; &#x2F;&#x2F;u代表是当前在哪个节点上，x代表修改值的这个点在数据数组中的位置，v代表修改后的值。\n    if(x&#x3D;&#x3D;tree[u].l&amp;&amp;x&#x3D;&#x3D;tree[u].r)&#123; &#x2F;&#x2F;如果已经找到了，直接修改就可以了。\n        tree[u].maxnum&#x3D;v;\n    &#125;  \n    else&#123;\n        int mid&#x3D;tree[u].l+tree[u].r&gt;&gt;1; &#x2F;&#x2F;去左右孩子分别查找，x是不是在左右孩子的区间里面，如果是就递归到对应孩子里面去。\n        if(x&lt;&#x3D;mid)&#123;\n            modify(u*2,x,v);\n        &#125;\n        else&#123;\n            modify(u*2+1,x,v);\n        &#125;\n        pushup(u); &#x2F;&#x2F;递归完之后要记得用pushup操作更新一下父节点的信息。\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F;查询操作就是查询任意区间的他的value值。\nint query(int u,int l,int r)&#123; &#x2F;&#x2F;u代表当前的节点，l和r代表查询的数据数组的区间。\n    if(tree[u].l&gt;&#x3D;l&amp;&amp;tree[u].r&lt;&#x3D;r)&#123;\n        return tree[u].maxnum; &#x2F;&#x2F;如果当前节点的区间已经完全在l和r之间的话，直接返回当前节点的值就可以了。\n    &#125;\n    else&#123;\n        &#x2F;&#x2F;不然的话，那就是l和r和当前节点的区间是部分有交集的。我们就要判断是否和左右孩子还有交集。\n        &#x2F;&#x2F;如果还有交集，那么就递归的query左孩子这个区间，对于右孩子同理，如果没有交集，那就不用处理了已经，最终将结果整合即可。\n        int res&#x3D;0;\n        int mid&#x3D;(tree[u].l+tree[u].r)&#x2F;2; \n        if(l&lt;&#x3D;mid)&#123;\n            res&#x3D;query(u*2,l,r);\n        &#125;\n        if(r&gt;mid)&#123;\n            res&#x3D;max(res,query(u*2+1,l,r));\n        &#125;\n        return res;\n    &#125;\n&#125;\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>线段树的使用并不局限于板子中的提供的区间最大值，题目中根据题目的需要需要自己设计线段树各节点的属性。无论如何，需要确保的是，设计的属性，一定得是父节点的属性可以由孩子节点得出来的。也就是说pushup操作是能实现的。<br>下一篇就是懒标记的线段树了，支持区间修改的线段树，多了一个pushdown的操作。</p>\n","text":"不带懒标记的线段树的板子。注意代码中节点属性是区间的最大值。下面为代码： struct node&#123; int l,r; int maxnum; &#125;; node tree[N*4]; void pushup(int u)&#123; tree[u].maxnum&...","link":"","photos":[],"count_time":{"symbolsCount":"3.8k","symbolsTime":"3 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":39,"path":"api/tags/ACM.json"},{"name":"数据结构","slug":"数据结构","count":23,"path":"api/tags/数据结构.json"},{"name":"线段树","slug":"线段树","count":2,"path":"api/tags/线段树.json"},{"name":"板子","slug":"板子","count":2,"path":"api/tags/板子.json"}],"toc":"","author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"喜欢前沿科技，想要见证人类科学的飞跃","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}},"mapped":true,"prev_post":{"title":"ACM学习笔记day41(懒标记线段树)","uid":"5a6c29c310d82ce99bfc421188b80faf","slug":"ACM学习笔记day41","date":"2023-08-27T07:57:57.000Z","updated":"2023-08-27T15:02:56.921Z","comments":true,"path":"api/articles/ACM学习笔记day41.json","keywords":null,"cover":"/img/codeforces.jpg","text":"带懒标记的线段树实际上的函数就多了一个，pushdown操作。以下为板子：板子题目链接板子中线段树维护的是一段区间的数组的和。懒标记表示的是该节点的子树要加上去的值，不包括他自己。 struct node&#123; int l,r; ll sum&#x3D;0; ll add&...","link":"","photos":[],"count_time":{"symbolsCount":"5.2k","symbolsTime":"5 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":39,"path":"api/tags/ACM.json"},{"name":"数据结构","slug":"数据结构","count":23,"path":"api/tags/数据结构.json"},{"name":"线段树","slug":"线段树","count":2,"path":"api/tags/线段树.json"},{"name":"板子","slug":"板子","count":2,"path":"api/tags/板子.json"},{"name":"懒标记","slug":"懒标记","count":1,"path":"api/tags/懒标记.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"喜欢前沿科技，想要见证人类科学的飞跃","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}},"next_post":{"title":"扩展欧几里得2（exgcd的最小正整数解，通解）","uid":"f37560f9bc1b5fea2432f5534d910cca","slug":"扩展欧几里得2","date":"2023-07-19T13:53:28.000Z","updated":"2023-08-27T09:17:18.821Z","comments":true,"path":"api/articles/扩展欧几里得2.json","keywords":null,"cover":"/img/codeforces.jpg","text":"由exgcd我们可以得到如下式子的一对解，前提是有解。ax+by&#x3D;c; (c%gcd(a,b)&#x3D;&#x3D;0)设一组解为x1,y1;即ax1+by1&#x3D;c; 记 u &#x3D; a*b&#x2F;gcd(a,b); 通解为:x&#x3D;x1+u&...","link":"","photos":[],"count_time":{"symbolsCount":398,"symbolsTime":"1 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":39,"path":"api/tags/ACM.json"},{"name":"exgcd","slug":"exgcd","count":1,"path":"api/tags/exgcd.json"},{"name":"最小正整数解","slug":"最小正整数解","count":1,"path":"api/tags/最小正整数解.json"},{"name":"通解","slug":"通解","count":1,"path":"api/tags/通解.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"喜欢前沿科技，想要见证人类科学的飞跃","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}}}