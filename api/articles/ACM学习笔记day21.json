{"title":"ACM学习笔记day21(试除法判定质数，分解质因数，质数筛（朴素筛，埃氏筛，线性筛）,试除法求约数)","uid":"a894f3fb49a6e9d5b26247e277bba209","slug":"ACM学习笔记day21","date":"2023-01-17T15:01:09.000Z","updated":"2023-04-08T10:51:54.252Z","comments":true,"path":"api/articles/ACM学习笔记day21.json","keywords":null,"cover":"/img/codeforces.jpg","content":"<p>emmmm，距离上次写blog好像已经是很久以前的事情了XD(<del>其实就是自己摆</del>)<br>那么今天的内容是试除法判定质数，分解质因数，还有三个质数筛。</p>\n<span id=\"more\"></span>\n\n<h1 id=\"试除法判定质数-题目\"><a href=\"#试除法判定质数-题目\" class=\"headerlink\" title=\"试除法判定质数 题目\"></a>试除法判定质数 <a href=\"https://www.acwing.com/problem/content/868/\">题目</a></h1><p>这个很好理解，就是一个一个数去取余所给的数，如果存在一个数正好取余的话，那就说明这个数不是质数。<br>同时有一个结论，那就是如果出现约数，一定是成对出现的。<br>比如i是n的约数，那么n&#x2F;i也是他的约数。这个很好理解的<br>因为i是n的约数，那么很显然i乘一个数字就等于n，也就是说</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>$$i*\\frac{n}{i}&#x3D;n$$</p></blockquote>\n<p>i是n的约数，自然$\\frac{n}{i}$也是n的约数。<br>所以我们发现约数总是成对出现的。<br>那么我们就可以不用一个一个的去找，相反，只要找$\\sqrt{n}$个数字就可以了。<br>也就是说时间复杂度是$O(\\sqrt{n})$。<br>下面为题目代码:</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\n\nbool isPrime(int x)&#123;\n    for(int i&#x3D;2;i&lt;&#x3D;x&#x2F;i;i++)&#123;\n        if(x%i&#x3D;&#x3D;0)&#123;\n            return false;\n        &#125;\n    &#125;\n&#125;\n\nint main()&#123;\n    int n;\n    cin&gt;&gt;n;\n    while(n--)&#123;\n        int x;\n        cin&gt;&gt;x;\n        if(isPrime(x))&#123;\n            cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl;\n        &#125;\n        else&#123;\n            cout&lt;&lt;&quot;No&quot;&lt;&lt;endl;\n        &#125;\n    &#125;\n    return 0;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h1 id=\"分解质因数-题目\"><a href=\"#分解质因数-题目\" class=\"headerlink\" title=\"分解质因数 题目\"></a>分解质因数 <a href=\"https://www.acwing.com/problem/content/869/\">题目</a></h1><p>分解质因数也是试除法来进行的。<br>我们不难发现，给定任何一个数，我们总能够将其拆分成若干个质数的幂的乘积的形式。如下</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>$n&#x3D;p_1^a<em>p_2^b</em>p_3^c…..$</p></blockquote>\n<p>其中，$p_1,p_2,p_3$，为他的质因数,abc为一个固定的常数。<br>那么我们分解质因数的过程是和这个类似的。<br>倒不如说也就是模拟这个的过程。<br>同理，我们这里只要进行$\\sqrt{n}$次就可以了。为什么呢？<br>我们不难发现，对于一个数字n，他大于$\\sqrt{n}$的质因数至多就一个。<br>很好证明，反证法，如果大于一个了，说明至少两个是吧，那么质因数乘起来明显是大于n的，显然不成立。<br>所以n大于$\\sqrt{n}$的质因数至多只会有一个。<br>那么我们就先做小于等于$\\sqrt{n}$的部分，然后我们每次找到一个质因数之后，不断的去除掉给的数里面的这个质因数<br>如果最后结果不是1（因为一直除，除到最小就是1嘛）说明是存在大于$\\sqrt{n}$的质因数的<br>那么我们就把当前这个数也作为一个结果。<br>该算法的时间复杂度为$O(\\sqrt{n})$。<br>不同于上面那个是严格的$\\sqrt{n}$，这里这个是小于$\\sqrt{n}$的，极端下才会是$\\sqrt{n}$<br>下面为代码</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\n\nvoid Prime(int x)&#123;\n    for(int i&#x3D;2;i&lt;&#x3D;x&#x2F;i;i++)&#123; &#x2F;&#x2F;从2开始到sqrt(x)一个一个去找\n        if(x%i&#x3D;&#x3D;0)&#123; &#x2F;&#x2F;如果是因数，这里一定是质因数，因为我们找到了之后会不断的用他去除所给的x，有关i的倍数的值全部被\n                    &#x2F;&#x2F;除掉了\n            int cnt&#x3D;0; &#x2F;&#x2F;计数质因数的幂次\n            while(x%i&#x3D;&#x3D;0)&#123;\n                x&#x2F;&#x3D;i; &#x2F;&#x2F;如果x里面还有当前i这个因数的话，就不断的去除去，然后计数器加一\n                cnt++;\n            &#125;\n            cout&lt;&lt;i&lt;&lt;&#39; &#39;&lt;&lt;cnt&lt;&lt;endl; \n        &#125;\n    &#125;\n    if(x&gt;1)&#123; &#x2F;&#x2F;如果x大于了1，说明存在大于根号x的质因数，那么这个数就是其中的一个质因数，并且幂次一定为1.\n        cout&lt;&lt;x&lt;&lt;&#39; &#39;&lt;&lt;1&lt;&lt;endl;\n    &#125;\n&#125;\n\nint main()&#123;\n    int n;\n    cin&gt;&gt;n;\n    while(n--)&#123;\n        int x;\n        cin&gt;&gt;x;\n        Prime(x);\n        cout&lt;&lt;endl;\n    &#125;\n    return 0;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h1 id=\"质数筛-题目\"><a href=\"#质数筛-题目\" class=\"headerlink\" title=\"质数筛 题目\"></a>质数筛 <a href=\"https://www.acwing.com/problem/content/870/\">题目</a></h1><p>质数筛，顾名思义，就是在给定的范围内，将其中所有的质数全面筛选出来。<br>一般的方法是把合数去掉，剩下的就是质数了。<br>这也是朴素筛和埃氏筛的原理。<br>如图就是筛完之后的样子。<br><img src=\"https://raw.githubusercontent.com/AusertDream/MyblogImags/main/%E7%AD%9B%E8%B4%A8%E6%95%B0.png\" alt=\"筛质数\"></p>\n<h2 id=\"朴素筛\"><a href=\"#朴素筛\" class=\"headerlink\" title=\"朴素筛\"></a>朴素筛</h2><p>朴素筛的思想很简单，就是对于每一个数字，将他的倍数删掉。<br>比如，2，那我们就将4,6,8….这些数字都删掉<br>这样我们迭代到n之后，就删掉了里面所有的因数了。<br>这种筛法的时间复杂度是$O(n\\log_2n)$;<br>下面为简要的证明</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>不难发现，程序的执行次数为<br>$\\frac{n}{2}+\\frac{n}{3}+\\frac{n}{4}…..+\\frac{n}{n}$<br>即为$n*(\\frac{1}{2}+\\frac{1}{3}+\\frac{1}{4}+\\frac{1}{5}+…..\\frac{1}{n})$<br>后面的为一个调和级数，当$n→∞$时，他的值为$\\ln{n}+c$。其中c为欧拉常数<br>因为$\\ln{n}&lt;\\log_2 n$所以我们一般认为这个时间复杂度为$O(n\\log_2n)$</p></blockquote>\n<p>下面为朴素筛的代码：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nint n;\nconst int N  &#x3D; 1e6+10;\nint cnt;\nbool st[N];\n&#x2F;&#x2F;如果要存储结果的话，只要再开一个数组用来存就可以了\nvoid getPrimes()&#123;\n    for(int i&#x3D;2;i&lt;&#x3D;n;i++)&#123;\n        if(!st[i])&#123;\n            cnt++;&#x2F;&#x2F;当cnt++的时候，当前的i存入数组中去就可以了;\n        &#125;\n        for(int j&#x3D;i+i;j&lt;&#x3D;n;j+&#x3D;i)&#123;\n            st[j]&#x3D;1;\n        &#125;\n    &#125;\n&#125;\n\nint main()&#123;\n    cin&gt;&gt;n;\n    getPrimes();\n    cout&lt;&lt;cnt&lt;&lt;endl;\n    return 0;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n<h2 id=\"埃氏筛\"><a href=\"#埃氏筛\" class=\"headerlink\" title=\"埃氏筛\"></a>埃氏筛</h2><p>埃氏筛是朴素筛的优化版本。<br>他和朴素筛的区别就在于，进行删除的时候，仅仅对于之前没被删过的数字。<br>因为如果这个数字被删过，说明他是合数，前面一定存在一个质数，是他的因数，那么这个数字的倍数也一定是他的质因数的倍数<br>那么当然也都是被删过的，所以我们可以跳过这一步。<br>他的时间复杂度为$O(n\\log_2\\log_2n)$<br>很多时候loglog基本上可以看做是一个常数。<br>下面为代码：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nint n;\nconst int N  &#x3D; 1e6+10;\nint cnt;\nbool st[N];\n\nvoid getPrimes()&#123;\n    for(int i&#x3D;2;i&lt;&#x3D;n;i++)&#123;\n        if(!st[i])&#123;\n            cnt++;\n            for(int j&#x3D;i+i;j&lt;&#x3D;n;j+&#x3D;i)&#123; &#x2F;&#x2F;将这一步移动进了条件句里面。\n                st[j]&#x3D;1;\n            &#125;\n        &#125;\n        \n    &#125;\n&#125;\n\nint main()&#123;\n    cin&gt;&gt;n;\n    getPrimes();\n    cout&lt;&lt;cnt&lt;&lt;endl;\n    return 0;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"线性筛-欧拉筛\"><a href=\"#线性筛-欧拉筛\" class=\"headerlink\" title=\"线性筛(欧拉筛)\"></a>线性筛(欧拉筛)</h2><p>欧拉筛为什么是线性筛，原因就在于他不同于埃氏筛，他没有重复筛除的过程。<br>埃氏筛中，我们i遍历到3和7的时候，显然会重复筛除21，而欧拉筛不会这样。<br>因为我们每次筛除的时候都是以primes[i]为最小质因数的数<br>每一个数的最小质因数都是唯一的，那么当然筛除的过程也就没有多余的重复筛除过程。<br>所以欧拉筛也叫线性筛。<br>具体筛除的过程可以看这个<a href=\"https://www.bilibili.com/video/BV1LR4y1Z7pm/?spm_id_from=333.337.search-card.all.click&vd_source=f7f32e566655ee99fdc20a5a909343ec\">视频</a>。<br>这里面有动画演示欧拉筛的过程。</p>\n<p>下面为代码：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nint n;\nconst int N &#x3D; 1e6+10;\nbool st[N];\nint cnt&#x3D;0;\nint primes[N];\n\nvoid getPrimes()&#123;\n    for(int i&#x3D;2;i&lt;&#x3D;n;i++)&#123;\n        if(!st[i])&#123;\n            primes[cnt++]&#x3D;i; &#x2F;&#x2F;如果没被筛掉，说明是质数，那么就将他放入primes数组里面，同时cnt计数++\n        &#125;\n        for(int j&#x3D;0;primes[j]&lt;&#x3D;n&#x2F;i;j++)&#123; &#x2F;&#x2F;遍历整个primes数组，首先要求保证primes[j]*i得是&lt;&#x3D;n的确保合法\n            st[primes[j]*i]&#x3D;true; &#x2F;&#x2F; 让primes[j]*i的值为true，表示被筛过了，因为这个数肯定是约数了。\n            if(i%primes[j]&#x3D;&#x3D;0)&#123;\n                break; &#x2F;&#x2F;如果primes是i的约数的话，那就结束循环，此时primes[j]一定是i的最小质因数，当然也是primes[j]*i的最小质因数。\n                                &#x2F;&#x2F;遵循了欧拉筛的原则，只筛到以primes[j]为最小质因数的数，避免多筛。\n            &#125;\n        &#125;\n    &#125;\n&#125;\nint main()&#123;\n    cin&gt;&gt;n;\n    getPrimes();\n    cout&lt;&lt;cnt&lt;&lt;endl;\n    return 0;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h1 id=\"试除法求约数-题目\"><a href=\"#试除法求约数-题目\" class=\"headerlink\" title=\"试除法求约数 题目\"></a>试除法求约数 <a href=\"https://www.acwing.com/problem/content/871/\">题目</a></h1><p>用试除法求约数，很简单，就一个一个数字除过去看能不能正好取整，如果可以就是约数。<br>同时因为约数是成对出现的，所以可以优化到$O(\\sqrt{n})$的时间复杂度。<br>下面为代码：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nconst int N &#x3D; 1e7;\nint n;\nvector&lt;int&gt; res;\nvoid getdivisor(int x)&#123;\n    for(int i&#x3D;1;i&lt;&#x3D;x&#x2F;i;i++)&#123;\n        if(x%i&#x3D;&#x3D;0)&#123;\n            res.push_back(i);\n            if(i!&#x3D;x&#x2F;i) res.push_back(x&#x2F;i);\n        &#125;\n    &#125;\n&#125;\n\nint main()&#123;\n    cin&gt;&gt;n;\n    while(n--)&#123;\n        int x;\n        cin&gt;&gt;x;\n        res.clear();\n        getdivisor(x);\n        sort(res.begin(),res.end());\n        for(int i&#x3D;0;i&lt;res.size();i++)&#123;\n            cout&lt;&lt;res[i]&lt;&lt;&#39; &#39;;\n        &#125;\n        cout&lt;&lt;endl;\n    &#125;\n    \n    return 0;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>好了，那么这就是这里的全部内容了。<br>感觉欧拉筛还是有点难理解的。<br>我们下次再见<br>Bye~</p>\n","text":"emmmm，距离上次写blog好像已经是很久以前的事情了XD(其实就是自己摆)那么今天的内容是试除法判定质数，分解质因数，还有三个质数筛。 试除法判定质数 题目这个很好理解，就是一个一个数去取余所给的数，如果存在一个数正好取余的话，那就说明这个数不是质数。同时有一个结论，那就是如...","link":"","photos":[],"count_time":{"symbolsCount":"6.1k","symbolsTime":"6 mins."},"categories":[{"name":"ACM","slug":"ACM","count":40,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":38,"path":"api/tags/ACM.json"},{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"笔记","slug":"笔记","count":3,"path":"api/tags/笔记.json"},{"name":"数论","slug":"数论","count":5,"path":"api/tags/数论.json"},{"name":"质数","slug":"质数","count":1,"path":"api/tags/质数.json"},{"name":"约数","slug":"约数","count":2,"path":"api/tags/约数.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E8%AF%95%E9%99%A4%E6%B3%95%E5%88%A4%E5%AE%9A%E8%B4%A8%E6%95%B0-%E9%A2%98%E7%9B%AE\"><span class=\"toc-text\">试除法判定质数 题目</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%88%86%E8%A7%A3%E8%B4%A8%E5%9B%A0%E6%95%B0-%E9%A2%98%E7%9B%AE\"><span class=\"toc-text\">分解质因数 题目</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E8%B4%A8%E6%95%B0%E7%AD%9B-%E9%A2%98%E7%9B%AE\"><span class=\"toc-text\">质数筛 题目</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%9C%B4%E7%B4%A0%E7%AD%9B\"><span class=\"toc-text\">朴素筛</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%9F%83%E6%B0%8F%E7%AD%9B\"><span class=\"toc-text\">埃氏筛</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BA%BF%E6%80%A7%E7%AD%9B-%E6%AC%A7%E6%8B%89%E7%AD%9B\"><span class=\"toc-text\">线性筛(欧拉筛)</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E8%AF%95%E9%99%A4%E6%B3%95%E6%B1%82%E7%BA%A6%E6%95%B0-%E9%A2%98%E7%9B%AE\"><span class=\"toc-text\">试除法求约数 题目</span></a></li></ol>","author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"喜欢前沿科技，想要见证人类科学的飞跃","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}},"mapped":true,"prev_post":{"title":"ACM学习笔记day22 (约数个数，约数之和，最大公约数)","uid":"3438dc43ca9a9de9df433abe2e751c9e","slug":"ACM学习笔记day22","date":"2023-01-23T13:17:12.000Z","updated":"2023-04-08T10:52:01.459Z","comments":true,"path":"api/articles/ACM学习笔记day22.json","keywords":null,"cover":"/img/codeforces.jpg","text":"浅过了个年，差不多了，应该回来念书了XD今天的内容是约数个数，约数之和，最大公约数。 约数个数,约数之和对于这个问题，其实就是两个公式。具体的证明，可以自寻资料查看。这里仅给出结果，和我自己的理解。严格的数学证明我们不多赘述。以下为公式(图中pi为N的质因数)： 好，公式我们给出...","link":"","photos":[],"count_time":{"symbolsCount":"3.2k","symbolsTime":"3 mins."},"categories":[{"name":"ACM","slug":"ACM","count":40,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":38,"path":"api/tags/ACM.json"},{"name":"学习","slug":"学习","count":41,"path":"api/tags/学习.json"},{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"数论","slug":"数论","count":5,"path":"api/tags/数论.json"},{"name":"约数","slug":"约数","count":2,"path":"api/tags/约数.json"},{"name":"公式","slug":"公式","count":1,"path":"api/tags/公式.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"喜欢前沿科技，想要见证人类科学的飞跃","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}},"next_post":{"title":"ACM学习笔记day20(走迷宫bfs)","uid":"955da31dc34cc48d9fa1d8587dc420ff","slug":"ACM学习笔记day20","date":"2022-12-16T13:50:22.000Z","updated":"2023-04-08T10:51:47.380Z","comments":true,"path":"api/articles/ACM学习笔记day20.json","keywords":null,"cover":"/img/codeforces.jpg","text":"hello guys！今天的内容是走迷宫。额，好像叕好久没有更新博客了。呃呃呃。好像确实有点摆（是非常吧。好的，我们来看问题。 走迷宫问题，这个不多说，啥意思很容易理解题源：acwing;所用的思想就是bfs算法。bfs算法其实是有一个固定的算法模板的。 while(queue非...","link":"","photos":[],"count_time":{"symbolsCount":"1.9k","symbolsTime":"2 mins."},"categories":[{"name":"ACM","slug":"ACM","count":40,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":38,"path":"api/tags/ACM.json"},{"name":"学习","slug":"学习","count":41,"path":"api/tags/学习.json"},{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"数据结构","slug":"数据结构","count":21,"path":"api/tags/数据结构.json"},{"name":"算法","slug":"算法","count":20,"path":"api/tags/算法.json"},{"name":"bfs","slug":"bfs","count":3,"path":"api/tags/bfs.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"喜欢前沿科技，想要见证人类科学的飞跃","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}}}