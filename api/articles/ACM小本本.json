{"title":"ACM小本本","uid":"4a9ea142753f2671aa4c5ecbc1f2c491","slug":"ACM小本本","date":"2022-11-09T12:43:41.000Z","updated":"2023-08-25T14:20:11.540Z","comments":true,"path":"api/articles/ACM小本本.json","keywords":null,"cover":"/img/codeforces.jpg","content":"<p>这里是记录ACM知识点中一些零碎的东西，或者一些小的注意点啥的<br></p>\n<span id=\"more\"></span>\n\n<p>1.使用二分模板的时候，当修改left值的时候，注意要让mid&#x3D;left+right+1&gt;&gt;1，不然会出现mid&#x3D;left然后死循环的出现<br><br>2.快排和归并的本质就是分治，快排是先处理数据再分治，归并是先分治再处理数据<br><br>3.浮点数二分的时候，当要求保留4位小数的时候，循环条件应该为r-l&gt;1e-6,当保留六位的时候，应该为r-l&gt;1e-8<br>就是位数要比保留的数字多2，比如4-&gt;6,6-&gt;8<br><br>4.计算机一秒大约可以运算10^8次。<br><br>5.构建前缀和数组的时候，下标从1一开始，零的位置就置成零，这样的话，能直接递推，而不用让第一个对于所给数组的第一个。<br>&amp;ensp;&amp;ensp;同时在求值l到r之间的数字和的时候，能直接Sr-Sl-1，不怕l-1越界。<br><br>6.一种取消C++和C混用的方式，用ios修改，可以提高cincout的速度：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">ios::sync_with_stdio(0);\ncin.tie(0);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>这两行代码，相当于将C++的输入输出流和C的联系分开，加快了输入输出效率。<br><br>7.差分数组不需要构建，把原来的数组看成全是零的输入，然后在i i之间的数加上个a[i]即可。这是个小技巧。<br>二位差分数组同理。<br><br>8.unique函数，vector<int> a,unique(a.begin(),a.end())就是把a数组去重，然后重复的多余的数放在最后<br>返回最后那段第一个元素的迭代器，搭配erase函数，可以直接把数组里面的重复数字全部去掉。<br>e.g: a.erase(unique(a.begin(),a.end()),a.end());如上<br><br>9.用数组模拟单向链表和双向链表的时候，要注意他插入的第k个数据，和我们的index的差别。<br>比如单项链表，我们使用head作为头，但是实际数据index是从0开始的，而k一般从1开始，所以进行操作的时候要把k减一<br>而双向链表，我们已经提前存了一个left和right头，所以实际数据index是从2开始的，k从1开始，所以操作的时候要把k加1<br><br>10.用到Trie树的时候，一般是字符串里面的字符比较简单，全部是小写字母，或者大写字母，或者全是数字，或者全是0和1<br><br>11.关于不同的数据量，在1s的时间内要求的最高时间复杂度，可以看这篇博客。<a href=\"https://www.acwing.com/blog/content/32/\">链接</a><br><br>12.如何把一个杂乱的数组，在O(n)的时间复杂度下快速构建成一个堆？代码如下</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F;n为数组长度，编号从1开始，down是down操作，证明可以模拟一下，然后用级数求和做\nfor(int i&#x3D;n&#x2F;2;i;i--)&#123;\n    down(i);\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<br>\n13.字符串哈希的时候，不要把字母对应的数值映射成0，容易产生哈希冲突。<br>\n14.采用开放寻址法处理哈希冲突的时候，一般要把哈希数组的长度扩大为给定数组长度的2~3倍<br>\n15. 字符串哈希，一般P取131或者13331，Q取2^64，这样绝大多数情况不会发生哈希冲突<br>\n16. 定义unsigned long long变量的时候，如果值溢出了，会自动取余<br>\n17. 关于最短路问题常见的算法框架<br>\n\n<p><img src=\"https://raw.githubusercontent.com/AusertDream/MyblogImags/main/%E5%9B%BE%E8%AE%BA%E6%9C%80%E7%9F%AD%E8%B7%AF%E9%97%AE%E9%A2%98%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6%E5%9B%BE.png\" alt=\"图论最短路问题基本算法框架图.png\"><br><br></p>\n<ol start=\"18\">\n<li><p>Floyd算法不能处理存在负权自环的图，会导致距离为负无穷</p>\n</li>\n<li><p>对于n&#x2F;k向上取整，可以这么写 (n+k-1)&#x2F;k;</p>\n</li>\n<li><p>对于int范围内的数字，约数最多的一个数字，他的约数个数大概为1500,1600个。</p>\n</li>\n<li><p>对于要 求形如这种表达式的值的情况，对于数字特别大的情况下，也就是要求你每一步都要取模的时候，可能会爆pow函数。<br>这个时候要使用<code>秦九韶算法</code>，也就是进行alpha1次循环，令t&#x3D;1，每次循环t&#x3D;t*p+1;这样最终t的值就是我们要求的值了。<br><br><img src=\"https://raw.githubusercontent.com/AusertDream/MyblogImags/main/%E5%A4%9A%E9%A1%B9%E8%A1%A8%E8%BE%BE%E5%BC%8F.png\" alt=\"photo\"></p>\n</li>\n<li><p>在C++中%代表的是取余运算，也就是说，得到的结果可能是负数的，但是我们数学意义上的余数不会是负数的。为了能够保证一定得到正数，可以这样做<br>   设模数为b，原来的数字为a  <code>(a%b+b)%b</code>。这样我们得到的结果一定是正的了。</p>\n</li>\n<li><p>STL优先队列自定义比较方式的写法。和sort函数一样，都需要一个自己写一个cmp比较函数，但是在定义对象的时候必须要这么写。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">class A &#123;&#125;;\npriority_queue&lt;A,vector&lt;A&gt;,decltype(&amp;cmp)&gt; a(cmp); &#x2F;&#x2F;这里第三个位置为固定的比较位，decltype函数参数里面要cmp的地址，定义对象的时候要执行含有cmp的构造函数。<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n</li>\n<li><p>n个数的两两的最小异或对就是排序后最小的相邻异或值。</p>\n</li>\n<li></li>\n</ol>\n","feature":true,"text":"这里是记录ACM知识点中一些零碎的东西，或者一些小的注意点啥的 1.使用二分模板的时候，当修改left值的时候，注意要让mid&#x3D;left+right+1&gt;&gt;1，不然会出现mid&#x3D;left然后死循环的出现2.快排和归并的本质就是分治，快排是先处理数据...","link":"","photos":[],"count_time":{"symbolsCount":"2k","symbolsTime":"2 mins."},"categories":[{"name":"ACM","slug":"ACM","count":40,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":37,"path":"api/tags/ACM.json"},{"name":"学习","slug":"学习","count":41,"path":"api/tags/学习.json"},{"name":"笔记本","slug":"笔记本","count":1,"path":"api/tags/笔记本.json"},{"name":"零碎的","slug":"零碎的","count":1,"path":"api/tags/零碎的.json"},{"name":"知识点","slug":"知识点","count":1,"path":"api/tags/知识点.json"}],"toc":"","author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"喜欢前沿科技，想要见证人类科学的飞跃","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}},"mapped":true,"prev_post":{"title":"ACM学习笔记day4(前缀和和差分)","uid":"4143f6a2444e4122fe8da477a7a2d540","slug":"ACM学习笔记day4","date":"2022-11-09T14:02:19.000Z","updated":"2023-04-08T10:49:05.915Z","comments":true,"path":"api/articles/ACM学习笔记day4.json","keywords":null,"cover":"/img/codeforces.jpg","text":"今天学了前缀和和差分，及其数组。前缀和不多说了，比较好理解，主要还是差分，这个比较抽象 前缀和主要注意一下，前缀和数组从1开始，0的位置就归零，这样就不用地方越界问题了。 差分至于差分。emmmm差分数组不需要构建，~~~当然也可以构建~~~二位差分同理 int a[N],B[N...","link":"","photos":[],"count_time":{"symbolsCount":875,"symbolsTime":"1 mins."},"categories":[{"name":"ACM","slug":"ACM","count":40,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":37,"path":"api/tags/ACM.json"},{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"学习","slug":"学习","count":41,"path":"api/tags/学习.json"},{"name":"算法","slug":"算法","count":20,"path":"api/tags/算法.json"},{"name":"数据结构","slug":"数据结构","count":21,"path":"api/tags/数据结构.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"喜欢前沿科技，想要见证人类科学的飞跃","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}},"next_post":{"title":"ACM学习笔记day3(高精度四则运算)","uid":"ffffeb1fbf512f768ee4d72750569670","slug":"ACM学习笔记day3","date":"2022-11-08T14:01:59.000Z","updated":"2023-04-08T10:49:48.429Z","comments":true,"path":"api/articles/ACM学习笔记day3.json","keywords":null,"cover":"/img/codeforces.jpg","text":"学习ACM有关东西的第四天。今天用晚上时间稍微学了点高精度加减乘除的运算。感觉是在模拟人类的运算过程，除了乘法(这不废话)So,Here we go! 总述有必要说明一下，对于高精度的四则运算，加法和减法是两个高精度的数字，而乘法和除法是一个高精度乘或者除以一个数同时因为数字的位...","link":"","photos":[],"count_time":{"symbolsCount":"6.6k","symbolsTime":"6 mins."},"categories":[{"name":"ACM","slug":"ACM","count":40,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":37,"path":"api/tags/ACM.json"},{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"学习","slug":"学习","count":41,"path":"api/tags/学习.json"},{"name":"算法","slug":"算法","count":20,"path":"api/tags/算法.json"},{"name":"数据结构","slug":"数据结构","count":21,"path":"api/tags/数据结构.json"},{"name":"蒟蒻","slug":"蒟蒻","count":4,"path":"api/tags/蒟蒻.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"喜欢前沿科技，想要见证人类科学的飞跃","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}}}