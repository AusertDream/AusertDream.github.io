{"title":"ACM小本本","uid":"4a9ea142753f2671aa4c5ecbc1f2c491","slug":"ACM小本本","date":"2022-11-09T12:43:41.000Z","updated":"2023-08-19T14:29:03.233Z","comments":true,"path":"api/articles/ACM小本本.json","keywords":null,"cover":"/img/codeforces.jpg","content":"<p>这里是记录ACM知识点中一些零碎的东西，或者一些小的注意点啥的<br></p>\n<span id=\"more\"></span>\n\n<p>1.使用二分模板的时候，当修改left值的时候，注意要让mid&#x3D;left+right+1&gt;&gt;1，不然会出现mid&#x3D;left然后死循环的出现<br><br>2.快排和归并的本质就是分治，快排是先处理数据再分治，归并是先分治再处理数据<br><br>3.浮点数二分的时候，当要求保留4位小数的时候，循环条件应该为r-l&gt;1e-6,当保留六位的时候，应该为r-l&gt;1e-8<br>就是位数要比保留的数字多2，比如4-&gt;6,6-&gt;8<br><br>4.计算机一秒大约可以运算10^8次。<br><br>5.构建前缀和数组的时候，下标从1一开始，零的位置就置成零，这样的话，能直接递推，而不用让第一个对于所给数组的第一个。<br>&amp;ensp;&amp;ensp;同时在求值l到r之间的数字和的时候，能直接Sr-Sl-1，不怕l-1越界。<br><br>6.一种取消C++和C混用的方式，用ios修改，可以提高cincout的速度：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">ios::sync_with_stdio(0);\ncin.tie(0);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>这两行代码，相当于将C++的输入输出流和C的联系分开，加快了输入输出效率。<br><br>7.差分数组不需要构建，把原来的数组看成全是零的输入，然后在i i之间的数加上个a[i]即可。这是个小技巧。<br>二位差分数组同理。<br><br>8.unique函数，vector<int> a,unique(a.begin(),a.end())就是把a数组去重，然后重复的多余的数放在最后<br>返回最后那段第一个元素的迭代器，搭配erase函数，可以直接把数组里面的重复数字全部去掉。<br>e.g: a.erase(unique(a.begin(),a.end()),a.end());如上<br><br>9.用数组模拟单向链表和双向链表的时候，要注意他插入的第k个数据，和我们的index的差别。<br>比如单项链表，我们使用head作为头，但是实际数据index是从0开始的，而k一般从1开始，所以进行操作的时候要把k减一<br>而双向链表，我们已经提前存了一个left和right头，所以实际数据index是从2开始的，k从1开始，所以操作的时候要把k加1<br><br>10.用到Trie树的时候，一般是字符串里面的字符比较简单，全部是小写字母，或者大写字母，或者全是数字，或者全是0和1<br><br>11.关于不同的数据量，在1s的时间内要求的最高时间复杂度，可以看这篇博客。<a href=\"https://www.acwing.com/blog/content/32/\">链接</a><br><br>12.如何把一个杂乱的数组，在O(n)的时间复杂度下快速构建成一个堆？代码如下</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F;n为数组长度，编号从1开始，down是down操作，证明可以模拟一下，然后用级数求和做\nfor(int i&#x3D;n&#x2F;2;i;i--)&#123;\n    down(i);\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<br>\n13.字符串哈希的时候，不要把字母对应的数值映射成0，容易产生哈希冲突。<br>\n14.采用开放寻址法处理哈希冲突的时候，一般要把哈希数组的长度扩大为给定数组长度的2~3倍<br>\n15. 字符串哈希，一般P取131或者13331，Q取2^64，这样绝大多数情况不会发生哈希冲突<br>\n16. 定义unsigned long long变量的时候，如果值溢出了，会自动取余<br>\n17. 关于最短路问题常见的算法框架<br>\n\n<p><img src=\"https://raw.githubusercontent.com/AusertDream/MyblogImags/main/%E5%9B%BE%E8%AE%BA%E6%9C%80%E7%9F%AD%E8%B7%AF%E9%97%AE%E9%A2%98%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6%E5%9B%BE.png\" alt=\"图论最短路问题基本算法框架图.png\"><br><br></p>\n<ol start=\"18\">\n<li><p>Floyd算法不能处理存在负权自环的图，会导致距离为负无穷</p>\n</li>\n<li><p>对于n&#x2F;k向上取整，可以这么写 (n+k-1)&#x2F;k;</p>\n</li>\n<li><p>对于int范围内的数字，约数最多的一个数字，他的约数个数大概为1500,1600个。</p>\n</li>\n<li><p>对于要 求形如这种表达式的值的情况，对于数字特别大的情况下，也就是要求你每一步都要取模的时候，可能会爆pow函数。<br>这个时候要使用<code>秦九韶算法</code>，也就是进行alpha1次循环，令t&#x3D;1，每次循环t&#x3D;t*p+1;这样最终t的值就是我们要求的值了。<br><br><img src=\"https://raw.githubusercontent.com/AusertDream/MyblogImags/main/%E5%A4%9A%E9%A1%B9%E8%A1%A8%E8%BE%BE%E5%BC%8F.png\" alt=\"photo\"></p>\n</li>\n<li><p>在C++中%代表的是取余运算，也就是说，得到的结果可能是负数的，但是我们数学意义上的余数不会是负数的。为了能够保证一定得到正数，可以这样做<br>   设模数为b，原来的数字为a  <code>(a%b+b)%b</code>。这样我们得到的结果一定是正的了。</p>\n</li>\n<li><p>STL优先队列自定义比较方式的写法。和sort函数一样，都需要一个自己写一个cmp比较函数，但是在定义对象的时候必须要这么写。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">class A &#123;&#125;;\npriority_queue&lt;A,vector&lt;A&gt;,decltype(&amp;cmp)&gt; a(cmp); &#x2F;&#x2F;这里第三个位置为固定的比较位，decltype函数参数里面要cmp的地址，定义对象的时候要执行含有cmp的构造函数。<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n</li>\n<li><p>n个数的两两的最小异或对就是排序后最小的相邻异或值。</p>\n</li>\n<li></li>\n</ol>\n","feature":true,"text":"这里是记录ACM知识点中一些零碎的东西，或者一些小的注意点啥的 1.使用二分模板的时候，当修改left值的时候，注意要让mid&#x3D;left+right+1&gt;&gt;1，不然会出现mid&#x3D;left然后死循环的出现2.快排和归并的本质就是分治，快排是先处理数据...","link":"","photos":[],"count_time":{"symbolsCount":"2k","symbolsTime":"2 mins."},"categories":[{"name":"ACM","slug":"ACM","count":40,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":38,"path":"api/tags/ACM.json"},{"name":"学习","slug":"学习","count":41,"path":"api/tags/学习.json"},{"name":"笔记本","slug":"笔记本","count":1,"path":"api/tags/笔记本.json"},{"name":"零碎的","slug":"零碎的","count":1,"path":"api/tags/零碎的.json"},{"name":"知识点","slug":"知识点","count":1,"path":"api/tags/知识点.json"}],"toc":"","author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"喜欢前沿科技，想要见证人类科学的飞跃","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}},"mapped":true,"prev_post":{"title":"ACM学习笔记day34 (DP专题的总结)","uid":"2c328a2145590af1c8c2b559a8951062","slug":"ACM学习笔记day34","date":"2023-03-19T10:29:55.000Z","updated":"2023-04-08T10:53:59.571Z","comments":true,"path":"api/articles/ACM学习笔记day34.json","keywords":null,"cover":"/img/codeforces.jpg","text":"已经很久没有写笔记了。主要是我一方面我摆（bushi,另外一个就是，后面的各种DP其实写笔记也没啥好写的，主要是理解这个DP是啥，然后也没有对应的板子好写的。自然也就不更新笔记了。那么最近是把基础的DP都学完了，作一个总结，大致的讲一下DP到底是个啥。DP的分类有啥怎么分类的。 ...","link":"","photos":[],"count_time":{"symbolsCount":"2.3k","symbolsTime":"2 mins."},"categories":[{"name":"ACM","slug":"ACM","count":40,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":38,"path":"api/tags/ACM.json"},{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"笔记","slug":"笔记","count":3,"path":"api/tags/笔记.json"},{"name":"DP","slug":"DP","count":5,"path":"api/tags/DP.json"},{"name":"动态规划","slug":"动态规划","count":5,"path":"api/tags/动态规划.json"},{"name":"专题总结","slug":"专题总结","count":1,"path":"api/tags/专题总结.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"喜欢前沿科技，想要见证人类科学的飞跃","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}},"feature":true},"next_post":{"title":"扩展欧几里得2（exgcd的最小正整数解，通解）","uid":"f37560f9bc1b5fea2432f5534d910cca","slug":"扩展欧几里得2","date":"2023-07-19T13:53:28.000Z","updated":"2023-07-19T14:29:46.944Z","comments":true,"path":"api/articles/扩展欧几里得2.json","keywords":null,"cover":"/img/codeforces.jpg","text":"由exgcd我们可以得到如下式子的一对解，前提是有解。ax+by&#x3D;c; (c%gcd(a,b)&#x3D;&#x3D;0)设一组解为x1,y1;即ax1+by1&#x3D;c; 记 u &#x3D; a*b&#x2F;gcd(a,b); 通解为:x&#x3D;x1+u&...","link":"","photos":[],"count_time":{"symbolsCount":398,"symbolsTime":"1 mins."},"categories":[{"name":"ACM","slug":"ACM","count":40,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":38,"path":"api/tags/ACM.json"},{"name":"exgcd","slug":"exgcd","count":1,"path":"api/tags/exgcd.json"},{"name":"最小正整数解","slug":"最小正整数解","count":1,"path":"api/tags/最小正整数解.json"},{"name":"通解","slug":"通解","count":1,"path":"api/tags/通解.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"喜欢前沿科技，想要见证人类科学的飞跃","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}}}