{"title":"ACM学习笔记day31 (多重背包(二进制优化)，分组背包)","uid":"c4215acd2eabdb6df78cd852601c9d9a","slug":"ACM学习笔记day31","date":"2023-02-18T08:34:37.000Z","updated":"2023-04-08T10:53:14.362Z","comments":true,"path":"api/articles/ACM学习笔记day31.json","keywords":null,"cover":"/img/codeforces.jpg","content":"<p>今天的内容是多重背包的二进制优化解法和分组背包。</p>\n<p>一开始听多重背包的二进制优化的时候还是蛮难的， 后来知道一个关键点之后就容易了。<br>至于分组背包，其实和多重背包差不多的，只不过选择上稍微变了点。</p>\n<span id=\"more\"></span>\n\n\n<h1 id=\"多重背包（二进制优化）\"><a href=\"#多重背包（二进制优化）\" class=\"headerlink\" title=\"多重背包（二进制优化）\"></a><a href=\"https://www.acwing.com/problem/content/5/\">多重背包（二进制优化）</a></h1><p>关于多重背包的一个二进制优化。<br>我们原来的朴素做法就是，枚举第i个物品是拿几个的。<br>比如一个两个之类的。<br>但是这个算法是n三次方的时间复杂度，时间复杂度太高了。<br>那么我们采取的一个策略就是，将多重背包转化为01背包问题。<br>也就是说我们把si个第i个物品，分成若干个整体，然后拆开后放入物品中去。<br>就是说我们原来有n个物品，每个物品有si个，我们将这个si拆开来，也放入这n个物品中去，那么物品就显然不止n个了，会更多。<br>问题在于怎么拆？<br>要既能确保最后选来选去不会超过他本来的si，又要保证选来选取能够涵盖0<del>si这所有的取第i个物品的数量。<br>当然我们可以拆成1 1 1 1 1 1 ….<br>这种做法无论如何肯定可以，但是这样的话，物品的个数就会变得特别多，根据给定的数据来看，<br>n的大小会变成2e6，这样再当01背包做，显然也是会超时的。<br>那么我们怎么拆？<br>采用的办法是二进制拆法。<br>比如对于si&#x3D;7；<br>我们把7拆成1 2 4 这样，我们就可以用这三个数字去表示0</del>7之间的任意一个数字。<br>因为7的二进制表示为111，而显然100,10,1这三个二进制数字能够表示0~7之间的任意一个数字.<br>那么我们就相当于对于每一种物品，我们拆分出了logsi个物品<br>最终的物品数量就是所有logsi相加，log向上取整。<br>比如11<br>拆到1 2 4 如果选择总的和会超过11，为了确保和是正确的，所以我们最后要加上个4<br>我们拆完之后，得到一个新的物品组，然后按照01背包做就可以了。</p>\n<p>ac code:</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nconst int N &#x3D; 2e6+10;\nint n,m;\n\nint f[N];\n\nstruct Good&#123;\n    int v,w;\n&#125;;\nvector&lt;Good&gt; goods;\n\nint main()&#123;\n    cin&gt;&gt;n&gt;&gt;m;\n    goods.push_back(&#123;0,0&#125;);\n    for(int i&#x3D;0;i&lt;n;i++)&#123;\n        int v,w,s;\n        cin&gt;&gt;v&gt;&gt;w&gt;&gt;s;\n        for(int k&#x3D;1;k&lt;&#x3D;s;k&lt;&lt;&#x3D;1)&#123;\n            s-&#x3D;k;\n            goods.push_back(&#123;k*v,k*w&#125;);\n        &#125;\n        if(s&gt;0)&#123;\n            goods.push_back(&#123;s*v,s*w&#125;);\n        &#125;\n    &#125;\n    for(int i&#x3D;1;i&lt;&#x3D;goods.size();i++)&#123;\n        for(int j&#x3D;m;j&gt;&#x3D;goods[i].v;j--)&#123;\n           \n            f[j]&#x3D;max(f[j],f[j-goods[i].v]+goods[i].w);\n            \n        &#125;\n    &#125;\n    cout&lt;&lt;f[m]&lt;&lt;endl;\n    return 0;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<h1 id=\"分组背包\"><a href=\"#分组背包\" class=\"headerlink\" title=\"分组背包\"></a><a href=\"https://www.acwing.com/problem/content/9/\">分组背包</a></h1><p>分组背包就是，给你n组物品，每一组物品有s个，然后每一组物品里面只能拿一个。<br>那么我们其实发现，这个问题和多重背包是类似的。<br>只不过多重背包枚举的是一个物品拿多少个，而分组背包是每个组里面拿哪一个。<br>拿的时候判断一下就可以了。</p>\n<p>ac code:</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nint n,m;\nconst int N &#x3D; 1000+10;\nstruct Good &#123;\n    int v,w;\n&#125;;\n\nvector&lt;vector&lt;Good&gt;&gt; a(n);\nint f[N];\n\nint main()&#123;\n    cin&gt;&gt;n&gt;&gt;m;\n    a.resize(n+1);\n    for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;\n        int s;\n        cin&gt;&gt;s;\n        while(s--)&#123;\n            int v,w;\n            cin&gt;&gt;v&gt;&gt;w;\n            a[i].push_back(&#123;v,w&#125;);\n        &#125;\n    &#125;\n    for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;\n        for(int j&#x3D;m;j&gt;&#x3D;0;j--)&#123;\n            f[j]&#x3D;f[j];\n            for(int k&#x3D;0;k&lt;a[i].size();k++)&#123;\n                if(j-a[i][k].v&gt;&#x3D;0) f[j]&#x3D;max(f[j],f[j-a[i][k].v]+a[i][k].w);\n            &#125;\n        &#125;\n    &#125;\n    cout&lt;&lt;f[m]&lt;&lt;endl;\n    return 0;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n<p>那么这个就是今天的全部内容了。<br>下次再见捏<br>Bye~~~</p>\n","text":"今天的内容是多重背包的二进制优化解法和分组背包。 一开始听多重背包的二进制优化的时候还是蛮难的， 后来知道一个关键点之后就容易了。至于分组背包，其实和多重背包差不多的，只不过选择上稍微变了点。 多重背包（二进制优化）关于多重背包的一个二进制优化。我们原来的朴素做法就是，枚举第i个...","link":"","photos":[],"count_time":{"symbolsCount":"2.6k","symbolsTime":"2 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"学习","slug":"学习","count":42,"path":"api/tags/学习.json"},{"name":"DP","slug":"DP","count":5,"path":"api/tags/DP.json"},{"name":"动态规划","slug":"动态规划","count":5,"path":"api/tags/动态规划.json"},{"name":"背包问题","slug":"背包问题","count":1,"path":"api/tags/背包问题.json"},{"name":"背包","slug":"背包","count":1,"path":"api/tags/背包.json"},{"name":"多重背包","slug":"多重背包","count":1,"path":"api/tags/多重背包.json"},{"name":"分组背包","slug":"分组背包","count":1,"path":"api/tags/分组背包.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85%EF%BC%88%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BC%98%E5%8C%96%EF%BC%89\"><span class=\"toc-text\">多重背包（二进制优化）</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%88%86%E7%BB%84%E8%83%8C%E5%8C%85\"><span class=\"toc-text\">分组背包</span></a></li></ol>","author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"喜欢前沿科技，想要见证人类科学的飞跃","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}},"mapped":true,"prev_post":{"title":"ACM学习笔记day32 (数字三角形，最长上升子序列)","uid":"0c3e2aa6872231e13fd503f7a08ea40b","slug":"ACM学习笔记day32","date":"2023-02-20T14:18:20.000Z","updated":"2023-04-08T10:53:21.330Z","comments":true,"path":"api/articles/ACM学习笔记day32.json","keywords":null,"cover":"/img/codeforces.jpg","text":"今天的内容是数字三角形，和最长上升子序列。其中最长上升子序列可以说是dp问题里面非常经典的问题了。 数字三角形对于这个题，我们的dp思路其实很简单。当然在此之前，我们需要定义一下这个三角形的行和列。给的三角形是这样的: 7 3 8 8 1 0 2 7 4 4 4 5 2 6 5 ...","link":"","photos":[],"count_time":{"symbolsCount":"3.8k","symbolsTime":"3 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":39,"path":"api/tags/ACM.json"},{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"学习","slug":"学习","count":42,"path":"api/tags/学习.json"},{"name":"DP","slug":"DP","count":5,"path":"api/tags/DP.json"},{"name":"动态规划","slug":"动态规划","count":5,"path":"api/tags/动态规划.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"喜欢前沿科技，想要见证人类科学的飞跃","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}},"next_post":{"title":"ACM学习笔记day30 (01背包，完全背包,多重背包(朴素解法))","uid":"26c83eef7dc2b42905d68bf63d792926","slug":"ACM学习笔记day30","date":"2023-02-11T11:53:11.000Z","updated":"2023-04-08T10:53:02.760Z","comments":true,"path":"api/articles/ACM学习笔记day30.json","keywords":null,"cover":"/img/codeforces.jpg","text":"今天的内容是01背包多重背包完全背包。算是开启DP专题了。01背包是作为最关键的一个题目。其他完全背包和多重背包其实就是他的扩展。理解了01背包，理解其他的背包其实不难。 01背包01背包问题的解法，先从朴素开始。我们定义一个二维数组作为我们dp的数组。f[i][j]的意义为从前...","link":"","photos":[],"count_time":{"symbolsCount":"4.8k","symbolsTime":"4 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":39,"path":"api/tags/ACM.json"},{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"学习","slug":"学习","count":42,"path":"api/tags/学习.json"},{"name":"蒟蒻","slug":"蒟蒻","count":4,"path":"api/tags/蒟蒻.json"},{"name":"DP","slug":"DP","count":5,"path":"api/tags/DP.json"},{"name":"动态规划","slug":"动态规划","count":5,"path":"api/tags/动态规划.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"喜欢前沿科技，想要见证人类科学的飞跃","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}}}