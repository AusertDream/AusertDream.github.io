{"title":"ACM学习笔记day41(懒标记线段树)","uid":"5a6c29c310d82ce99bfc421188b80faf","slug":"ACM学习笔记day41","date":"2023-08-27T07:57:57.000Z","updated":"2023-08-27T15:02:56.921Z","comments":true,"path":"api/articles/ACM学习笔记day41.json","keywords":null,"cover":"/img/codeforces.jpg","content":"<p>带懒标记的线段树实际上的函数就多了一个，pushdown操作。<br>以下为板子：<br><a href=\"https://www.acwing.com/problem/content/244/\">板子题目链接</a><br>板子中线段树维护的是一段区间的数组的和。<br>懒标记表示的是该节点的子树要加上去的值，不包括他自己。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">struct node&#123;\n    int l,r;\n    ll sum&#x3D;0;\n    ll add&#x3D;0;\n&#125;;\n\nnode tr[N * 4];\nint a[N];\nint n,m;\n\nvoid pushup(int u)&#123;\n    tr[u].sum&#x3D;tr[u*2].sum+tr[u*2+1ll].sum;    \n&#125;\n\nvoid pushdown(int u)&#123;\n    auto &amp;root &#x3D; tr[u],&amp;left &#x3D; tr[u*2],&amp;right &#x3D; tr[u*2+1ll];\n    if(root.add)&#123;\n        left.add+&#x3D;root.add,left.sum+&#x3D;(ll(left.r-left.l+1))*root.add;\n        right.add+&#x3D;root.add,right.sum+&#x3D;(ll(right.r-right.l+1))*root.add;\n        root.add&#x3D;0;\n    &#125;\n&#125;\n\nvoid build(int u,int l,int r)&#123;\n    tr[u].l&#x3D;l;\n    tr[u].r&#x3D;r;\n    if(l&#x3D;&#x3D;r) return;\n    else&#123;\n        int mid&#x3D;l+r&gt;&gt;1;\n        build(u*2,l,mid);\n        build(u*2+1,mid+1,r);\n    &#125;\n&#125;\n\nvoid modify(int u,int l,int r ,int v)&#123;\n    if(tr[u].l&gt;&#x3D;l&amp;&amp;tr[u].r&lt;&#x3D;r)&#123;\n        tr[u].sum+&#x3D;(ll(tr[u].r-tr[u].l+1))*v;\n        tr[u].add+&#x3D;v;\n    &#125;\n    else&#123;\n        pushdown(u);\n        int mid&#x3D;tr[u].l+tr[u].r&gt;&gt;1;\n        if(l&lt;&#x3D;mid)&#123;\n            modify(u*2,l,r,v);\n        &#125;\n        if(r&gt;mid)&#123;\n            modify(u*2+1,l,r,v);\n        &#125;\n        pushup(u);\n    &#125;\n&#125;\n\nll query(int u,int l,int r)&#123;\n    if(tr[u].l&gt;&#x3D;l&amp;&amp;tr[u].r&lt;&#x3D;r)&#123;\n        return tr[u].sum;\n    &#125;\n    else&#123;\n        pushdown(u);\n        ll res&#x3D;0;\n        int mid&#x3D;tr[u].l+tr[u].r&gt;&gt;1;\n        if(l&lt;&#x3D;mid)&#123;\n            res+&#x3D;query(u*2,l,r);\n        &#125;\n        if(r&gt;mid)&#123;\n            res+&#x3D;query(u*2+1,l,r);\n        &#125;\n        return res;\n    &#125;\n&#125;\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>以下是关于代码的一些解释。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F;pushup操作和没有懒标记的线段树一样，都是用孩子节点的信息去更新一下父节点的信息。没有任何变化。\nvoid pushup(int u)&#123;\n    tr[u].sum&#x3D;tr[u*2].sum+tr[u*2+1ll].sum;    \n&#125;\n&#x2F;&#x2F;pushdown操作是懒标记线段树的核心操作。\n&#x2F;&#x2F;他是将父节点的懒标记信息传递下去，传递给他的两个孩子节点，然后自己的当前的懒标记信息清空。\n&#x2F;&#x2F;这里add表示的含义的就是当前节点的子树应该要加上的值。注意这里是所有的值。\n&#x2F;&#x2F;所以之后我们要进行modify和query操作的时候要记得将add信息传递下去。\nvoid pushdown(int u)&#123;\n    auto &amp;root &#x3D; tr[u],&amp;left &#x3D; tr[u*2],&amp;right &#x3D; tr[u*2+1ll]; &#x2F;&#x2F;这里为了方便起见，用root表示当前u的这个节点，left表示他的左孩子，right表示他的右孩子。\n    if(root.add)&#123; &#x2F;&#x2F;如果当前这个节点的add不为零，也就是有需要传递下去的信息，那就进行传递操作。\n        left.add+&#x3D;root.add,left.sum+&#x3D;(ll(left.r-left.l+1))*root.add; &#x2F;&#x2F;在这题求区间和的情景下，左右孩子的add要加上传递下的信息add，然后他自己要每一个都要加上add值，因为是区间中每一个元素。\n        right.add+&#x3D;root.add,right.sum+&#x3D;(ll(right.r-right.l+1))*root.add;\n        root.add&#x3D;0; &#x2F;&#x2F;别忘了让root的add值清零。\n    &#125;\n&#125;\n&#x2F;&#x2F;线段树的构建过程。可以和无懒标记的构建过程一样，也可以在有初始值的时候，稍微做一下修改就可以了。这里板子放的是初始化全部为零的，线段树。\nvoid build(int u,int l,int r)&#123;\n    tr[u].l&#x3D;l;\n    tr[u].r&#x3D;r;\n    if(l&#x3D;&#x3D;r) return;\n    else&#123;\n        int mid&#x3D;l+r&gt;&gt;1;\n        build(u*2,l,mid);\n        build(u*2+1,mid+1,r);\n    &#125;\n&#125;\n&#x2F;&#x2F;自带初始化值的线段树的构建过程。\nvoid build2(int u,int l,int r)&#123;\n    tr[u].l&#x3D;l;\n    tr[u].r&#x3D;r;\n    if(l&#x3D;&#x3D;r)&#123;\n        tr[u].sum&#x3D;a[r]; &#x2F;&#x2F;实际上就是在区间长度为1的时候，初始化一下tr的值\n        &#x2F;&#x2F;这里其实要记得让tr[u].add都为零的，但是因为在结构体中我已经写了，所以这里就不需要写了。\n        return;\n    &#125;\n    else&#123;\n        int mid&#x3D;l+r&gt;&gt;1;\n        build(u*2,l,mid);\n        build(u*2+1,mid+1,r); \n        pushup(u);&#x2F;&#x2F;然后利用pushup操作，根据孩子节点的值，去计算父节点的值。\n    &#125;\n&#125;\n&#x2F;&#x2F;修改操作，支持区间修改。\nvoid modify(int u,int l,int r ,int v)&#123;\n    if(tr[u].l&gt;&#x3D;l&amp;&amp;tr[u].r&lt;&#x3D;r)&#123; &#x2F;&#x2F;如果要修改的区间已经完全包含了当前segment的区间，那么直接改这个节点的值就可以了。\n        tr[u].sum+&#x3D;(ll(tr[u].r-tr[u].l+1))*v; &#x2F;&#x2F;当前节点的值可以直接修改，但是要记住add也要加上这个v，因为我们修改的是当前节点的sum值，理论上他的子树的sum都要修改的。\n        tr[u].add+&#x3D;v;\n    &#125;\n    else&#123;\n        &#x2F;&#x2F;因为当前节点的区间和l，r只是部分相交，那么就要涉及讨论是哪一部分相交了，从而递归下去。\n        &#x2F;&#x2F;这里一定要记得在分裂之前，也就是要分开递归之前，一定要将当前节点的懒标记信息传递下去，也就是pushdown一次。\n        &#x2F;&#x2F;因为当前add 表示的是当前节点的所有值都要加上一个add，如果不传递下去，此时要修改的l到r区间只是和当前segment部分相交，那么也就是部分元素要加上v值，会和add表达的意思冲突，所以我们必须先将add信息传递给两个孩子\n        &#x2F;&#x2F;传递完之后，在进行分裂的操作，看是否和左孩子有交集，看是否和右孩子有交集，如果有，那就修改左孩子，右孩子。\n        pushdown(u);\n        int mid&#x3D;tr[u].l+tr[u].r&gt;&gt;1;\n        if(l&lt;&#x3D;mid)&#123;\n            modify(u*2,l,r,v);\n        &#125;\n        if(r&gt;mid)&#123;\n            modify(u*2+1,l,r,v);\n        &#125;\n        pushup(u); &#x2F;&#x2F;结束的时候别忘了要pushup一下，因为更新了最下面节点的值，要更新一下他父节点的值。\n    &#125;\n&#125;\n &#x2F;&#x2F;询问操作其实和没有懒标记的差不多，只不过就多了一个要记得将add信息传递下去就是了。\nll query(int u,int l,int r)&#123;\n    if(tr[u].l&gt;&#x3D;l&amp;&amp;tr[u].r&lt;&#x3D;r)&#123; &#x2F;&#x2F;如果已经包含了当前节点的区间，那么直接返回sum值就可以了。\n        return tr[u].sum;\n    &#125;\n    else&#123;\n        pushdown(u); &#x2F;&#x2F;分裂前要记得将懒标记信息传递下去，所以要pushdown一次。\n        ll res&#x3D;0;\n        int mid&#x3D;tr[u].l+tr[u].r&gt;&gt;1; &#x2F;&#x2F;和之前的类似，分开讨论，左右区间。\n        if(l&lt;&#x3D;mid)&#123;\n            res+&#x3D;query(u*2,l,r);\n        &#125;\n        if(r&gt;mid)&#123;\n            res+&#x3D;query(u*2+1,l,r);\n        &#125;\n        return res;\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>这就是懒标记线段树的一个板子，实际题目中，还是得根据题目要求，自己选择懒标记所带的信息。</p>\n","text":"带懒标记的线段树实际上的函数就多了一个，pushdown操作。以下为板子：板子题目链接板子中线段树维护的是一段区间的数组的和。懒标记表示的是该节点的子树要加上去的值，不包括他自己。 struct node&#123; int l,r; ll sum&#x3D;0; ll add&...","link":"","photos":[],"count_time":{"symbolsCount":"5.2k","symbolsTime":"5 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":39,"path":"api/tags/ACM.json"},{"name":"数据结构","slug":"数据结构","count":23,"path":"api/tags/数据结构.json"},{"name":"线段树","slug":"线段树","count":2,"path":"api/tags/线段树.json"},{"name":"板子","slug":"板子","count":2,"path":"api/tags/板子.json"},{"name":"懒标记","slug":"懒标记","count":1,"path":"api/tags/懒标记.json"}],"toc":"","author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"喜欢前沿科技，想要见证人类科学的飞跃","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}},"mapped":true,"prev_post":{"title":"ACM小本本","uid":"4a9ea142753f2671aa4c5ecbc1f2c491","slug":"ACM小本本","date":"2022-11-09T12:43:41.000Z","updated":"2023-08-25T14:20:11.540Z","comments":true,"path":"api/articles/ACM小本本.json","keywords":null,"cover":"/img/codeforces.jpg","text":"这里是记录ACM知识点中一些零碎的东西，或者一些小的注意点啥的 1.使用二分模板的时候，当修改left值的时候，注意要让mid&#x3D;left+right+1&gt;&gt;1，不然会出现mid&#x3D;left然后死循环的出现2.快排和归并的本质就是分治，快排是先处理数据...","link":"","photos":[],"count_time":{"symbolsCount":"2k","symbolsTime":"2 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":39,"path":"api/tags/ACM.json"},{"name":"学习","slug":"学习","count":41,"path":"api/tags/学习.json"},{"name":"笔记本","slug":"笔记本","count":1,"path":"api/tags/笔记本.json"},{"name":"零碎的","slug":"零碎的","count":1,"path":"api/tags/零碎的.json"},{"name":"知识点","slug":"知识点","count":1,"path":"api/tags/知识点.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"喜欢前沿科技，想要见证人类科学的飞跃","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}},"feature":true},"next_post":{"title":"ACM学习笔记day40(无懒标记线段树)","uid":"f730cb1c16c6cae11f6020e8c15e8535","slug":"ACM学习笔记day40","date":"2023-08-26T14:16:45.000Z","updated":"2023-08-27T09:15:54.897Z","comments":true,"path":"api/articles/ACM学习笔记day40.json","keywords":null,"cover":"/img/codeforces.jpg","text":"不带懒标记的线段树的板子。注意代码中节点属性是区间的最大值。下面为代码： struct node&#123; int l,r; int maxnum; &#125;; node tree[N*4]; void pushup(int u)&#123; tree[u].maxnum&...","link":"","photos":[],"count_time":{"symbolsCount":"3.8k","symbolsTime":"3 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":39,"path":"api/tags/ACM.json"},{"name":"数据结构","slug":"数据结构","count":23,"path":"api/tags/数据结构.json"},{"name":"线段树","slug":"线段树","count":2,"path":"api/tags/线段树.json"},{"name":"板子","slug":"板子","count":2,"path":"api/tags/板子.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"喜欢前沿科技，想要见证人类科学的飞跃","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}}}