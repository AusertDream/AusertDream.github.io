{"title":"ACM学习笔记day22 (约数个数，约数之和，最大公约数)","uid":"3438dc43ca9a9de9df433abe2e751c9e","slug":"ACM学习笔记day22","date":"2023-01-23T13:17:12.000Z","updated":"2023-04-08T10:52:01.459Z","comments":true,"path":"api/articles/ACM学习笔记day22.json","keywords":null,"cover":"/img/codeforces.jpg","content":"<p>浅过了个年，差不多了，应该回来念书了XD<br>今天的内容是约数个数，约数之和，最大公约数。</p>\n<span id=\"more\"></span>\n\n\n\n<h1 id=\"约数个数-约数之和\"><a href=\"#约数个数-约数之和\" class=\"headerlink\" title=\"约数个数,约数之和\"></a><a href=\"https://www.acwing.com/problem/content/872/\">约数个数</a>,<a href=\"https://www.acwing.com/problem/content/description/873/\">约数之和</a></h1><p>对于这个问题，其实就是两个公式。<br>具体的证明，可以自寻资料查看。<br>这里仅给出结果，和我自己的理解。<br>严格的数学证明我们不多赘述。<br>以下为公式(图中pi为N的质因数)：<br><img src=\"https://raw.githubusercontent.com/AusertDream/MyblogImags/main/%E7%BA%A6%E6%95%B0%E4%B8%AA%E6%95%B0%E5%85%AC%E5%BC%8F%E5%92%8C%E7%BA%A6%E6%95%B0%E5%92%8C%E5%85%AC%E5%BC%8F.png\" alt=\"约数\"></p>\n<p>好，公式我们给出来了。<br>我们应该怎么理解这个公式呢？<br>首先我们去观察一下约数之和这个公式，看最后一个表达式。<br>如果我们把这个乘积表达式展开，我们会发现<br>其中的每一个数字，都是N的所有质因数的幂之积，也就是说，<br>一个数N的任何一个约数都可以用他的质因数的幂之积来表示。<br>这个其实不难理解，因为由算数基本定理，任何一个数都可以用他的质因数的幂之积来表示。<br>那么约数是能够整除N的数字，也就相当于他是N的质因数的幂之积的一部分。<br>那么为了表示出所有的约数，每一个质因数的幂的部分从0到alpha1都是需要枚举到的<br>这里面一共有alpha1+1个，那么自然约数的个数就是(alpha1+1)<em>(alpha2+1)</em>…..(alphak+1)。<br>理解完约数的个数为什么是这么多之后，我们再来看约数之和这个公式。<br>我们也会更好的去记忆这个公式了，毕竟他是所有约数和的合并式。</p>\n<p>注意这里求约数个数的时候方便的，但是求约数之和的时候，可能有些人想要用等比数列求和公式(<del>就是我</del>)<br>可以是可以，但是不能用pow函数，因为pow函数返回的是double类型的，而不是longlong类型的，可能最终的结果会爆double<br>自己写pow函数的话，别忘了要每次取整。<br>那么如果不用等比数列求和公式的话，<br>我们可以采用秦九昭算法。<br>也就是进行alpha1次循环，令t&#x3D;1，每次循环t&#x3D;t*p1+1;这样最终t的值就是我们要求的值了。</p>\n<p><img src=\"https://raw.githubusercontent.com/AusertDream/MyblogImags/main/%E5%A4%9A%E9%A1%B9%E8%A1%A8%E8%BE%BE%E5%BC%8F.png\"></p>\n<p>下面为两题的代码：<br>约数个数:</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nint n;\ntypedef long long  ll;\nconst int mod &#x3D; 1e9+7;\nint main()&#123;\n    map&lt;int,int&gt; isprimes;\n    cin&gt;&gt;n;\n    while(n--)&#123;\n        int x;\n        cin&gt;&gt;x;\n        for(int i&#x3D;2;i&lt;&#x3D;x&#x2F;i;i++)&#123;\n            if(x%i&#x3D;&#x3D;0)&#123;\n                while(x%i&#x3D;&#x3D;0)&#123;\n                    x&#x2F;&#x3D;i;\n                    isprimes[i]++;\n                &#125;\n            &#125;\n        &#125;\n        if(x&gt;1)&#123;\n            isprimes[x]++;\n        &#125;\n    &#125;\n    ll res&#x3D;1;\n    for(auto prime:isprimes)&#123;\n        res&#x3D;res*(prime.second+1)%mod;\n    &#125;\n    cout&lt;&lt;res&lt;&lt;endl;\n    return 0;\n&#125;</code></pre>\n<p>约数之和:</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nint n;\ntypedef long long ll;\nconst int mod &#x3D; 1e9+7;\n\n\nint main()&#123;\n    map&lt;ll,ll&gt; primes;\n    cin&gt;&gt;n;\n    while(n--)&#123;\n        int x;\n        cin&gt;&gt;x;\n        for(int i&#x3D;2;i&lt;&#x3D;x&#x2F;i;i++)&#123;\n            while(x%i&#x3D;&#x3D;0)&#123;\n                x&#x2F;&#x3D;i;\n                primes[i]++;\n            &#125;\n        &#125;\n        if(x&gt;1)&#123;\n            primes[x]++;\n        &#125;\n    &#125;\n    ll res&#x3D;1;\n    for(auto prime: primes)&#123;\n        ll p &#x3D; prime.first;\n        ll a&#x3D;prime.second;\n        ll t&#x3D;1;\n        for(int i&#x3D;0;i&lt;a;i++)&#123;\n            t&#x3D;(t*p%mod+1)%mod;\n        &#125;\n        res&#x3D;res*t%mod;\n    &#125;\n    cout&lt;&lt;res&lt;&lt;endl;\n    return 0;\n&#125;</code></pre>\n<h1 id=\"最大公约数\"><a href=\"#最大公约数\" class=\"headerlink\" title=\"最大公约数\"></a><a href=\"https://www.acwing.com/problem/content/874/\">最大公约数</a></h1><p>求两个数的最大公约数，这个很简单，就是一个公式，辗转相除法。<br>这里要理解一下为啥</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>gcd(a,b)&#x3D;&#x3D;gcd(b,a%b);<br>首先我们知道，a能整除b，a能整除c，那么a一定能够整除(a+b)<br>那么我们来看一下a,b的所有公约数，还有b，a%b的所有公约数，如果这两个公约数都一样的话，那么最大公约数也肯定是一样的对吧<br>假设c是a和b的任意一个公约数，那么可以得到c能整除a，c能整除b，对于等式右边，c能整除b。<br>而对于a%b我们可以表示为a-(a&#x2F;b)*b的值，也就是说a-k*b,k为一个常数(是的表达式的值大于零的最大常数)<br>因为c能整除a，c能整除b，那么自然c能整除a-k*b。<br>同理，设c是b和a%b的一个任意公约数，<br>c能整除a-k*b，并且因为c能整除b，所以c能整除k*b,所以c能整除a-k*b+k*b 也就是c能整除a。<br>综上两边的公约数是一模一样的，所以等式成立。<br>下面为代码：</p></blockquote>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\n\nint gcd(int a,int b)&#123;\n    if(b&#x3D;&#x3D;0) return a;\n    else&#123;\n        return gcd(b,a%b);\n    &#125;\n&#125;\n\nint main()&#123;\n    int n;\n    cin&gt;&gt;n;\n    while(n--)&#123;\n        int a,b;\n        cin&gt;&gt;a&gt;&gt;b;\n        cout&lt;&lt;gcd(a,b)&lt;&lt;endl;\n    &#125;\n    return 0;\n&#125;</code></pre>\n\n<p>OK，那么就那么多东西了。<br>我们下次再见<br>Bye~~~</p>\n","text":"浅过了个年，差不多了，应该回来念书了XD今天的内容是约数个数，约数之和，最大公约数。 约数个数,约数之和对于这个问题，其实就是两个公式。具体的证明，可以自寻资料查看。这里仅给出结果，和我自己的理解。严格的数学证明我们不多赘述。以下为公式(图中pi为N的质因数)： 好，公式我们给出...","link":"","photos":[],"count_time":{"symbolsCount":"3.2k","symbolsTime":"3 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":39,"path":"api/tags/ACM.json"},{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"学习","slug":"学习","count":43,"path":"api/tags/学习.json"},{"name":"数论","slug":"数论","count":5,"path":"api/tags/数论.json"},{"name":"约数","slug":"约数","count":2,"path":"api/tags/约数.json"},{"name":"公式","slug":"公式","count":1,"path":"api/tags/公式.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%BA%A6%E6%95%B0%E4%B8%AA%E6%95%B0-%E7%BA%A6%E6%95%B0%E4%B9%8B%E5%92%8C\"><span class=\"toc-text\">约数个数,约数之和</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0\"><span class=\"toc-text\">最大公约数</span></a></li></ol>","author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"tech otakus save the world","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}},"mapped":true,"prev_post":{"title":"ACM学习笔记day23(欧拉函数，筛法求欧拉函数，快速幂，快速幂求逆元)","uid":"ead55ceebbb5da582503c01cc4b636b6","slug":"ACM学习笔记day23","date":"2023-01-24T13:07:47.000Z","updated":"2023-04-08T10:52:11.128Z","comments":true,"path":"api/articles/ACM学习笔记day23.json","keywords":null,"cover":"/img/codeforces.jpg","text":"今天的内容是欧拉函数和快速幂，主要是这两个。其中最后那个逆元，emm感觉好难理解QAQ 欧拉函数欧拉函数的定义： 由定义我们容易得出，对于求一个数字N的欧拉函数的值，我们按照定义来就可以了。时间复杂度是O(sqrt(N))。因为分解质因数要根号n，然后乘法乘上去也是根号n。所以时...","link":"","photos":[],"count_time":{"symbolsCount":"5.8k","symbolsTime":"5 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":39,"path":"api/tags/ACM.json"},{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"学习","slug":"学习","count":43,"path":"api/tags/学习.json"},{"name":"数论","slug":"数论","count":5,"path":"api/tags/数论.json"},{"name":"数学","slug":"数学","count":7,"path":"api/tags/数学.json"},{"name":"快速幂","slug":"快速幂","count":1,"path":"api/tags/快速幂.json"},{"name":"欧拉函数","slug":"欧拉函数","count":1,"path":"api/tags/欧拉函数.json"},{"name":"逆元","slug":"逆元","count":1,"path":"api/tags/逆元.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"tech otakus save the world","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}},"next_post":{"title":"ACM学习笔记day21(试除法判定质数，分解质因数，质数筛（朴素筛，埃氏筛，线性筛）,试除法求约数)","uid":"a894f3fb49a6e9d5b26247e277bba209","slug":"ACM学习笔记day21","date":"2023-01-17T15:01:09.000Z","updated":"2023-04-08T10:51:54.252Z","comments":true,"path":"api/articles/ACM学习笔记day21.json","keywords":null,"cover":"/img/codeforces.jpg","text":"emmmm，距离上次写blog好像已经是很久以前的事情了XD(其实就是自己摆)那么今天的内容是试除法判定质数，分解质因数，还有三个质数筛。 试除法判定质数 题目这个很好理解，就是一个一个数去取余所给的数，如果存在一个数正好取余的话，那就说明这个数不是质数。同时有一个结论，那就是如...","link":"","photos":[],"count_time":{"symbolsCount":"6.1k","symbolsTime":"6 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":39,"path":"api/tags/ACM.json"},{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"笔记","slug":"笔记","count":3,"path":"api/tags/笔记.json"},{"name":"数论","slug":"数论","count":5,"path":"api/tags/数论.json"},{"name":"质数","slug":"质数","count":1,"path":"api/tags/质数.json"},{"name":"约数","slug":"约数","count":2,"path":"api/tags/约数.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"tech otakus save the world","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}}}