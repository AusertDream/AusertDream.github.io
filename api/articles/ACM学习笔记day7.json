{"title":"ACM学习笔记day7(区间合并，静态单链表，静态双向链表)","uid":"6626baeb85b77ff2abeecddea4b9b43b","slug":"ACM学习笔记day7","date":"2022-11-12T15:20:17.000Z","updated":"2023-04-08T10:49:14.216Z","comments":true,"path":"api/articles/ACM学习笔记day7.json","keywords":null,"cover":"/img/codeforces.jpg","content":"<p>emm今天搞了点区间合并和静态链表。<br>感觉静态链表的写法还是比较繁琐的。<br>逻辑上感觉有点绕<br>可能是我写习惯动态链表的原因吧（</p>\n<span id=\"more\"></span>\n\n\n<h2 id=\"区间合并\"><a href=\"#区间合并\" class=\"headerlink\" title=\"区间合并\"></a>区间合并</h2><p>题目来源Acwing<a href=\"https://www.acwing.com/problem/content/805/\">链接</a><br>题目不难，贪心就能做。<br>当时不讲，直接做出来了。<br>不多赘述。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nconstexpr auto INF &#x3D; 2100000000;\nconstexpr auto INF64 &#x3D; 1e18;\nconst int N &#x3D; 100010;\ntypedef pair&lt;int, int&gt; PII;\n\nbool cmp(PII a, PII b) &#123;\n    return a.second &lt; b.second;\n&#125;\n\nint main()\n&#123;\n    int n;\n    cin &gt;&gt; n;\n    vector&lt;PII&gt; a(n);\n    for (int i &#x3D; 0; i &lt; n; i++) &#123;\n        PII temp;\n        cin &gt;&gt; temp.first &gt;&gt; temp.second;\n        a[i] &#x3D; temp;\n    &#125;\n    sort(a.begin(), a.end(), cmp);\n    int l, cnt &#x3D; 1;\n    l &#x3D; a[n - 1].first;\n    for (int i &#x3D; n - 2; i &gt;&#x3D; 0; i--) &#123;\n        if (l &lt;&#x3D; a[i].second) &#123;\n            l &#x3D; min(a[i].first,l);\n        &#125;\n        else &#123;\n            cnt++;\n            l &#x3D; a[i].first;\n        &#125;\n    &#125;\n    cout &lt;&lt; cnt &lt;&lt; endl;\n    return 0;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"静态链表\"><a href=\"#静态链表\" class=\"headerlink\" title=\"静态链表\"></a>静态链表</h2><p>这里的话我就把单链表和双链表的内容合并在一起好了。<br>在实际的算法比赛中，我们一般采用的链表都是静态链表<br>也就是依托数组作为存储结构的链表。<br>对于一个数组，我们使用一个idx指向一个新的空位置。<br>就比如说，一个数组index为0 1 2 3 的地方都已经有数据了，此时idx为4,<br>表示如果你要再插入一个链表的话，就放在idx的地方。<br>所以，逻辑上是链表，但其实存储方式是线性的。<br>这也就是为什么叫他静态链表，或者是用数组去模拟链表。<br><br><br><br>单链表中，通常使用一个head初始化为-1，来表示头结点<br>而双向链表中，不会使用head，而是left和right，来表示链表的两头<br>初始化的时候，我们让left是第零个，right是第一个，然后idx自然就是2了。<br>再进行操作。<br><br><br>下为acwing<a href=\"https://www.acwing.com/problem/content/828/\">单链表练习题</a></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nconstexpr auto INF &#x3D; 2100000000;\nconstexpr auto INF64 &#x3D; 1e18;\nconst int N &#x3D; 100010;\ntypedef pair&lt;int, int&gt; PII;\nint elem[N],ne[N]&#x3D;&#123;-1&#125;, idx &#x3D; 0;\nint head &#x3D; -1;\n\nvoid headAdd(int x) &#123;\n    elem[idx] &#x3D; x;\n    ne[idx] &#x3D; head;\n    head &#x3D; idx;\n    idx++;\n&#125;\n\nvoid Add(int k, int x) &#123;\n    elem[idx] &#x3D; x;\n    ne[idx] &#x3D; ne[k];\n    ne[k] &#x3D; idx;\n    idx++;\n&#125;\n\nvoid del(int k) &#123;\n    ne[k] &#x3D; ne[ne[k]];\n&#125;\n\n\nint main()\n&#123;\n    int m;\n    cin &gt;&gt; m;\n    head &#x3D; -1;\n    while (m--) &#123;\n        char a;\n        cin &gt;&gt; a;\n        if (a &#x3D;&#x3D; &#39;H&#39;) &#123;\n            int x;\n            cin &gt;&gt; x;\n            headAdd(x);\n        &#125;\n        else if (a &#x3D;&#x3D; &#39;D&#39;) &#123;\n            int k;\n            cin &gt;&gt; k;\n            if(k&#x3D;&#x3D;0)&#123;\n                head&#x3D;ne[head];\n            &#125;\n            else del(k-1);\n        &#125;\n        else &#123;\n            int k, x;\n            cin &gt;&gt; k &gt;&gt; x;\n            Add(k-1, x);\n        &#125;\n    &#125;\n    for (int i &#x3D; head; i !&#x3D; -1; i &#x3D; ne[i]) &#123;\n        cout &lt;&lt; elem[i] &lt;&lt; &#39; &#39;;\n    &#125;\n    cout &lt;&lt; endl;\n    return 0;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>这里要注意一个地方捏。<br>对于第k个插入的节点，下标他是从1，开始的<br>而我们存储数据是从零开始的，所以有关的地方要注意k-1.<br><br><br></p>\n<h2 id=\"下为acwing双向链表练习题同样需要注意的是这里因为我们初始化的时候，index0-和1已经被用掉了idx-x3D-2-与他的第k个插入，多了个1-所以进行有关操作的时候需要注意是k-1。这两节的话，感觉比较重要的就是这个知识点了。\"><a href=\"#下为acwing双向链表练习题同样需要注意的是这里因为我们初始化的时候，index0-和1已经被用掉了idx-x3D-2-与他的第k个插入，多了个1-所以进行有关操作的时候需要注意是k-1。这两节的话，感觉比较重要的就是这个知识点了。\" class=\"headerlink\" title=\"下为acwing双向链表练习题同样需要注意的是这里因为我们初始化的时候，index0 和1已经被用掉了idx&#x3D;2,与他的第k个插入，多了个1,所以进行有关操作的时候需要注意是k+1。这两节的话，感觉比较重要的就是这个知识点了。\"></a>下为acwing<a href=\"https://www.acwing.com/problem/content/829/\">双向链表练习题</a><br><pre class=\"line-numbers language-none\"><code class=\"language-none\">#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nconstexpr auto INF &#x3D; 2100000000;\nconstexpr long long INF64 &#x3D; 1e18;\nconst int N &#x3D; 100010;\ntypedef pair&lt;int, int&gt; PII;\nint elem[N],l[N],r[N], idx &#x3D; 0;\n\nvoid Add(int k, int x) &#123;\n    elem[idx] &#x3D; x;\n    r[idx] &#x3D; r[k];\n    l[idx] &#x3D; k;\n    l[r[k]] &#x3D; idx;\n    r[k] &#x3D; idx;\n    idx++;\n&#125;\n\nvoid del(int k) &#123;\n    r[l[k]] &#x3D; r[k];\n    l[r[k]] &#x3D; l[k];\n&#125;\n\n\nint main()\n&#123;\n    int m;\n    cin &gt;&gt; m;\n    r[0] &#x3D; 1;\n    l[1] &#x3D; 0;\n    idx &#x3D; 2;\n    while (m--) &#123;\n        string a;\n        int k,x;\n        cin &gt;&gt; a;\n        if (a[0] &#x3D;&#x3D; &#39;L&#39;) &#123;\n            cin &gt;&gt; x;\n            Add(0, x);\n        &#125;\n        else if (a[0] &#x3D;&#x3D; &#39;R&#39;) &#123;\n            cin &gt;&gt; x;\n            Add(l[1], x);\n        &#125;\n        else if (a[0] &#x3D;&#x3D; &#39;D&#39;) &#123;\n            cin &gt;&gt; k;\n            del(k+1);\n        &#125;\n        else if (a &#x3D;&#x3D; &quot;IL&quot;) &#123;\n            cin &gt;&gt; k &gt;&gt; x;\n            Add(l[k+1], x);\n        &#125;\n        else &#123;\n            cin &gt;&gt; k &gt;&gt; x;\n            Add(k+1, x);\n        &#125;\n    &#125;\n    for (int i &#x3D; r[0];i!&#x3D;1; i &#x3D; r[i]) &#123;\n        cout &lt;&lt; elem[i] &lt;&lt; &#39; &#39;;\n    &#125;\n    cout &lt;&lt; endl;\n    return 0;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>同样需要注意的是<br>这里因为我们初始化的时候，index0 和1已经被用掉了<br>idx&#x3D;2,<br>与他的第k个插入，多了个1,<br>所以进行有关操作的时候<br>需要注意是k+1。<br>这两节的话，感觉比较重要的就是这个知识点了。</h2><p>That’s all<br>bye~</p>\n","text":"emm今天搞了点区间合并和静态链表。感觉静态链表的写法还是比较繁琐的。逻辑上感觉有点绕可能是我写习惯动态链表的原因吧（ 区间合并题目来源Acwing链接题目不难，贪心就能做。当时不讲，直接做出来了。不多赘述。 #include&lt;bits&#x2F;stdc++.h&gt; ...","link":"","photos":[],"count_time":{"symbolsCount":"4.3k","symbolsTime":"4 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":39,"path":"api/tags/ACM.json"},{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"学习","slug":"学习","count":41,"path":"api/tags/学习.json"},{"name":"算法","slug":"算法","count":20,"path":"api/tags/算法.json"},{"name":"数据结构","slug":"数据结构","count":23,"path":"api/tags/数据结构.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6\"><span class=\"toc-text\">区间合并</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%9D%99%E6%80%81%E9%93%BE%E8%A1%A8\"><span class=\"toc-text\">静态链表</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%8B%E4%B8%BAacwing%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E7%BB%83%E4%B9%A0%E9%A2%98%E5%90%8C%E6%A0%B7%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E6%98%AF%E8%BF%99%E9%87%8C%E5%9B%A0%E4%B8%BA%E6%88%91%E4%BB%AC%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8Cindex0-%E5%92%8C1%E5%B7%B2%E7%BB%8F%E8%A2%AB%E7%94%A8%E6%8E%89%E4%BA%86idx-x3D-2-%E4%B8%8E%E4%BB%96%E7%9A%84%E7%AC%ACk%E4%B8%AA%E6%8F%92%E5%85%A5%EF%BC%8C%E5%A4%9A%E4%BA%86%E4%B8%AA1-%E6%89%80%E4%BB%A5%E8%BF%9B%E8%A1%8C%E6%9C%89%E5%85%B3%E6%93%8D%E4%BD%9C%E7%9A%84%E6%97%B6%E5%80%99%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E6%98%AFk-1%E3%80%82%E8%BF%99%E4%B8%A4%E8%8A%82%E7%9A%84%E8%AF%9D%EF%BC%8C%E6%84%9F%E8%A7%89%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E5%B0%B1%E6%98%AF%E8%BF%99%E4%B8%AA%E7%9F%A5%E8%AF%86%E7%82%B9%E4%BA%86%E3%80%82\"><span class=\"toc-text\">下为acwing双向链表练习题#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nconstexpr auto INF &#x3D; 2100000000;\nconstexpr long long INF64 &#x3D; 1e18;\nconst int N &#x3D; 100010;\ntypedef pair&lt;int, int&gt; PII;\nint elem[N],l[N],r[N], idx &#x3D; 0;\n\nvoid Add(int k, int x) {\n    elem[idx] &#x3D; x;\n    r[idx] &#x3D; r[k];\n    l[idx] &#x3D; k;\n    l[r[k]] &#x3D; idx;\n    r[k] &#x3D; idx;\n    idx++;\n}\n\nvoid del(int k) {\n    r[l[k]] &#x3D; r[k];\n    l[r[k]] &#x3D; l[k];\n}\n\n\nint main()\n{\n    int m;\n    cin &gt;&gt; m;\n    r[0] &#x3D; 1;\n    l[1] &#x3D; 0;\n    idx &#x3D; 2;\n    while (m--) {\n        string a;\n        int k,x;\n        cin &gt;&gt; a;\n        if (a[0] &#x3D;&#x3D; &#39;L&#39;) {\n            cin &gt;&gt; x;\n            Add(0, x);\n        }\n        else if (a[0] &#x3D;&#x3D; &#39;R&#39;) {\n            cin &gt;&gt; x;\n            Add(l[1], x);\n        }\n        else if (a[0] &#x3D;&#x3D; &#39;D&#39;) {\n            cin &gt;&gt; k;\n            del(k+1);\n        }\n        else if (a &#x3D;&#x3D; &quot;IL&quot;) {\n            cin &gt;&gt; k &gt;&gt; x;\n            Add(l[k+1], x);\n        }\n        else {\n            cin &gt;&gt; k &gt;&gt; x;\n            Add(k+1, x);\n        }\n    }\n    for (int i &#x3D; r[0];i!&#x3D;1; i &#x3D; r[i]) {\n        cout &lt;&lt; elem[i] &lt;&lt; &#39; &#39;;\n    }\n    cout &lt;&lt; endl;\n    return 0;\n}同样需要注意的是这里因为我们初始化的时候，index0 和1已经被用掉了idx&#x3D;2,与他的第k个插入，多了个1,所以进行有关操作的时候需要注意是k+1。这两节的话，感觉比较重要的就是这个知识点了。</span></a></li></ol>","author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"喜欢前沿科技，想要见证人类科学的飞跃","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}},"mapped":true,"prev_post":{"title":"ACM学习笔记day8(模拟栈，表达式求值，模拟队列，单调栈)","uid":"0bde88ed9132d2dd0ee34fc3f801dfcc","slug":"ACM学习笔记day8","date":"2022-11-15T13:52:59.000Z","updated":"2023-04-08T10:49:21.906Z","comments":true,"path":"api/articles/ACM学习笔记day8.json","keywords":null,"cover":"/img/codeforces.jpg","text":"wdnmd,受不了了，一拳把地球打爆。今天的内容原本应该是11月13号的因为当晚是有个讲座要听，没空写博客想着明天写，结果昨天忙的要死，今天还是忙的要死今天晚上终于稍微有点空了，赶紧把博客给补了，顺便也隔了几天复习一下东西。今天主要学的是 模拟栈，表达式求值，模拟队列和单调栈。 ...","link":"","photos":[],"count_time":{"symbolsCount":"2.9k","symbolsTime":"3 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":39,"path":"api/tags/ACM.json"},{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"学习","slug":"学习","count":41,"path":"api/tags/学习.json"},{"name":"算法","slug":"算法","count":20,"path":"api/tags/算法.json"},{"name":"数据结构","slug":"数据结构","count":23,"path":"api/tags/数据结构.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"喜欢前沿科技，想要见证人类科学的飞跃","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}},"next_post":{"title":"ACM学习笔记day6(离散化)","uid":"1e7a8acd61656fdbe512e6f88b5aff86","slug":"ACM学习笔记day6","date":"2022-11-10T13:57:48.000Z","updated":"2023-04-08T10:49:10.497Z","comments":true,"path":"api/articles/ACM学习笔记day6.json","keywords":null,"cover":"/img/codeforces.jpg","text":"其实这一节，应该是day5里面的，因为呃呃呃我看到这一节acwing里面的视频长度比较长，所以我就分割出来作为单独的一个blog来写了。算法的思想比较重要。 离散化 题目acwing区间和说实话，离散化的概念不难理解但是实际运用起来，发现诶，用不来了 首先，什么是离散化？离散化一...","link":"","photos":[],"count_time":{"symbolsCount":"3k","symbolsTime":"3 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":39,"path":"api/tags/ACM.json"},{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"学习","slug":"学习","count":41,"path":"api/tags/学习.json"},{"name":"算法","slug":"算法","count":20,"path":"api/tags/算法.json"},{"name":"数据结构","slug":"数据结构","count":23,"path":"api/tags/数据结构.json"},{"name":"离散化","slug":"离散化","count":1,"path":"api/tags/离散化.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"喜欢前沿科技，想要见证人类科学的飞跃","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}}}