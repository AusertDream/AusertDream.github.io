{"title":"ACM学习笔记day29 (Nim游戏，台阶-Nim游戏)","uid":"8af78f8e46bb9ac28caa93ffafd43362","slug":"ACM学习笔记day29","date":"2023-02-08T08:10:48.000Z","updated":"2023-04-08T10:52:54.992Z","comments":true,"path":"api/articles/ACM学习笔记day29.json","keywords":null,"cover":"/img/codeforces.jpg","content":"<p>今天的内容是博弈论的一部分（<br>后面有涉及到SG函数和MEX函数的额，还没听懂（<br>所以只有这两个了。<br>两个一个是Nim游戏是最基础的模型，台阶-Nim游戏是Nim游戏的进阶版本。</p>\n<span id=\"more\"></span>\n\n\n<h1 id=\"Nim游戏\"><a href=\"#Nim游戏\" class=\"headerlink\" title=\"Nim游戏\"></a><a href=\"https://www.acwing.com/problem/content/893/\">Nim游戏</a></h1><p>就是两个人轮流拿，随便拿几个，随便拿哪一堆的，拿到最后谁不能操作了，谁就输了。<br>这里我们要讲两个概念，一个是先手必胜状态，一个是先手必败状态。<br>什么意思呢？<br>就是先手必胜的状态下，先手是必胜的（这不废话。<br>必败同理。然后这个先后手不是绝对的，是相对的。<br>比如说A和B Van游戏一开始的时候A是先手必败的，然后A做了一堆nb的操作。<br>然后turn转到了B这里，这个时候B就可以看成是先手的，因为A做了很多nb的操作，导致了轮到B的时候B进入了先手必败的状态。<br>这就是这两个概念。</p>\n<p>知道了这两个概念，我们看这个问题。<br>首先我们抛出个结论。<br>a1^a2^a3^a4…..^an&#x3D;0 先手必败。<br>a1^a2^a3^a4…..^an!&#x3D;0 先手必胜。</p>\n<p>为什么？</p>\n<ol>\n<li>首先我们来看0^0^0^…..^0&#x3D;0的状态，因为石子啥都没有，所以先手是必败的。没法操作了。</li>\n<li>然后我们设a1^a2^a3^a4…..^an&#x3D;x!&#x3D;0。<br> 对于x的二进制表达式中，我们令k为最左边的那个1的位置，那么对于所有的ai，一定存在某个ai他的第k为是1的。不然第k位的结果肯定是零。<br> 那么我们就可以得到ai^x&lt;ai 为什么？其实很简单，因为第k位变成零了，前面的位数最小就是全是零，不然的话肯定会变大的。<br> 那么我们这个时候先手的这个人，就可以通过把这个ai变成ai^x，因为ai^x&lt;ai的所以是肯定合法的。<br> 此时的异或结果为a1^a2….^ai^x^…..an&#x3D;x^x&#x3D;0。此时因为先手人操作完了，此时留给后手的那个人是后手必败状态，那么也就说明了。<br> 为什么异或结果不为零先手一定必胜。<br> 因为先手一定有办法可以把结果变成0然后交给后手的那个人。</li>\n<li>然后我们再来看a1^a2^a3^a4…..^an&#x3D;0的情况，这个时候因为先手是必败的。那么先手 有没有什么办法操作一下，可以使得传给后手的时候异或值还是零呢？<br> 答案是没有的。<br> 我们用反证法来证明。<br> 如果存在一个ai，使得我们把ai的值变成ai’，并且结果还是零的。<br> 也就是说<br> a1^a2….^ai…..an&#x3D;0。<br> a1^a2….^ai’…..an&#x3D;0。<br> 我们将两式一起异或一下。<br> 因为除了ai其他都是有一样的，所以结果就是<br> ai^ai’&#x3D;0。<br> 而要让这个式子等于0，只有让ai等于ai’，而因为不能不进行操作，所以这个式子是不成立的。<br> 所以我们没有把饭把这个先手必败的状态传递下去。</li>\n</ol>\n<p>综上就是这个结论的证明了。<br>知道了证明之后，代码是很简单的。</p>\n<p>ac code:</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\n\n\nint main()&#123;\n    int n;\n    cin&gt;&gt;n;\n    int res&#x3D;0;\n    for(int i&#x3D;0;i&lt;n;i++)&#123;\n        int x;\n        cin&gt;&gt;x;\n        res^&#x3D;x;\n    &#125;\n    if(!res)&#123;\n        cout&lt;&lt;&quot;No&quot;&lt;&lt;endl;\n    &#125;\n    else&#123;\n        cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl;\n    &#125;\n    return 0;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h1 id=\"台阶-Nim游戏\"><a href=\"#台阶-Nim游戏\" class=\"headerlink\" title=\"台阶-Nim游戏\"></a><a href=\"https://www.acwing.com/problem/content/894/\">台阶-Nim游戏</a></h1><p>这个是上面Nim游戏的一个变体。<br>石子还是可以随便拿多少个的，只不过不是拿掉了，而是放到下面一个台阶上，地面上的就不允许碰了。<br>其实我们发现，只要石子还在台阶上，那么其实不管在哪个台阶上都是没关系的。<br>只有第一个台阶，才会把石子真正带出去。<br>所以我们其实发现，偶数台阶是无关结果的。<br>因为当一个人将偶数台阶的部分石子带到奇数台阶上的时候，另外一个是可以做这样的镜像操作。<br>相当于啥都没干，而奇数台阶的话就不一定了，我们一个人把第一层的拿到了地板上，那么另外一个人显然不能做镜像操作了。</p>\n<p>接下来抛出结论:<br>a1^a3^a5….a2n-1&#x3D;0 先手必败。<br>a1^a3^a5….a2n-1!&#x3D;0 先手必胜。</p>\n<p>关于为什么只看奇数的，不看偶数的，前面已经讲了，偶数的话，另外一个人就可以做镜像操作，从而让这个异或值保持不变。<br>然后其他的部分的话，和Nim游戏是一样的，异或值不等于零的话，总有办法可以让异或值为零，然后让对手必败。<br>证明方法是类似的。</p>\n<p>下面为<br>ac code:</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\n\n\nint main()&#123;\n    int n;\n    cin&gt;&gt;n;\n    int res&#x3D;0;\n    for(int i&#x3D;0;i&lt;n;i++)&#123;\n        int x;\n        cin&gt;&gt;x;\n        if(i%2&#x3D;&#x3D;0)&#123;\n            res^&#x3D;x;\n        &#125;\n    &#125;\n    if(res&#x3D;&#x3D;0)&#123;\n        cout&lt;&lt;&quot;No&quot;&lt;&lt;endl;\n    &#125;\n    else&#123;\n        cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl;\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n<p>好的 ，那么这些就是这个blog的全部内容了。<br>实际上博弈论的重要内容还没出来。<br>鳖问，问就是我没看懂（<br>之后懂了再写吧。<br>Bye~</p>\n","text":"今天的内容是博弈论的一部分（后面有涉及到SG函数和MEX函数的额，还没听懂（所以只有这两个了。两个一个是Nim游戏是最基础的模型，台阶-Nim游戏是Nim游戏的进阶版本。 Nim游戏就是两个人轮流拿，随便拿几个，随便拿哪一堆的，拿到最后谁不能操作了，谁就输了。这里我们要讲两个概念...","link":"","photos":[],"count_time":{"symbolsCount":"2.6k","symbolsTime":"2 mins."},"categories":[{"name":"ACM","slug":"ACM","count":40,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":38,"path":"api/tags/ACM.json"},{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"学习","slug":"学习","count":41,"path":"api/tags/学习.json"},{"name":"数学","slug":"数学","count":7,"path":"api/tags/数学.json"},{"name":"博弈论","slug":"博弈论","count":1,"path":"api/tags/博弈论.json"},{"name":"Nim游戏","slug":"Nim游戏","count":1,"path":"api/tags/Nim游戏.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Nim%E6%B8%B8%E6%88%8F\"><span class=\"toc-text\">Nim游戏</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%8F%B0%E9%98%B6-Nim%E6%B8%B8%E6%88%8F\"><span class=\"toc-text\">台阶-Nim游戏</span></a></li></ol>","author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"喜欢前沿科技，想要见证人类科学的飞跃","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}},"mapped":true,"prev_post":{"title":"Chicken McNugget Theorem","uid":"de8de93bec780c9d57906902a53cb751","slug":"Chicken-McNugget-Theorem","date":"2023-02-09T07:50:47.000Z","updated":"2023-04-08T11:00:45.932Z","comments":true,"path":"api/articles/Chicken-McNugget-Theorem.json","keywords":null,"cover":"/img/二次元の图/1.jpg","text":"麦乐鸡定理(bushi)链接 The Chicken McNugget Theorem (or Postage Stamp Problem or Frobenius Coin Problem) states that for any two relatively prime po...","link":"","photos":[],"count_time":{"symbolsCount":366,"symbolsTime":"1 mins."},"categories":[{"name":"数学","slug":"数学","count":1,"path":"api/categories/数学.json"}],"tags":[{"name":"数学","slug":"数学","count":7,"path":"api/tags/数学.json"},{"name":"定理","slug":"定理","count":1,"path":"api/tags/定理.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"喜欢前沿科技，想要见证人类科学的飞跃","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}},"next_post":{"title":"ACM学习笔记day28 (组合数的应用——满足条件的01序列，容斥原理)","uid":"cd92aa8f26118d15f6c9920aff860d6f","slug":"ACM学习笔记day28","date":"2023-02-07T09:31:39.000Z","updated":"2023-04-08T10:52:45.948Z","comments":true,"path":"api/articles/ACM学习笔记day28.json","keywords":null,"cover":"/img/codeforces.jpg","text":"今天的内容是组合数的应用——满足条件的01序列和容斥原理。关于这个满足条件的01序列，其实涉及到了一个特殊的数字卡特兰数。这个我们等会会讲这个。 满足条件的01序列题目意思就是给你n个0，n个1，让你排出来一个序列，使得对于任意的前缀，0的数量是大于等于1的数量的。问你这样的序列...","link":"","photos":[],"count_time":{"symbolsCount":"3.2k","symbolsTime":"3 mins."},"categories":[{"name":"ACM","slug":"ACM","count":40,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":38,"path":"api/tags/ACM.json"},{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"学习","slug":"学习","count":41,"path":"api/tags/学习.json"},{"name":"数学","slug":"数学","count":7,"path":"api/tags/数学.json"},{"name":"组合数","slug":"组合数","count":2,"path":"api/tags/组合数.json"},{"name":"容斥原理","slug":"容斥原理","count":1,"path":"api/tags/容斥原理.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"喜欢前沿科技，想要见证人类科学的飞跃","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}}}