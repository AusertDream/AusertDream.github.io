{"title":"ACM学习笔记day12(最大异或对，并查集)","uid":"5299e436ed1961fa0cb39dca432850d2","slug":"ACM学习笔记day12","date":"2022-11-24T14:50:04.000Z","updated":"2023-04-08T10:50:43.082Z","comments":true,"path":"api/articles/ACM学习笔记day12.json","keywords":null,"cover":"/img/codeforces.jpg","content":"<p>今天的内容是Trie树的应用和并查集的学习。<br>这个<a href=\"https://www.acwing.com/problem/content/145/\">最大异或对</a>的话，就是Trie树的应用，然后有别于之前那个Trie树<br>存的数据不一样，之前那个存的是char，现在这个存的是0和1。<br>然后<a href=\"https://www.acwing.com/problem/content/838/\">并查集</a>的话<br>感觉就是构建了一个森林，然后每一颗树代表了一定的信息。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"最大异或对\"><a href=\"#最大异或对\" class=\"headerlink\" title=\"最大异或对\"></a>最大异或对</h2><p>最大异或对。题目是啥呢，emmm<br>给你n个数字，然后从中任意选两个，作异或操作，问最大的结果是什么<br>我们先来暴力做法，i遍历一边数组，然后j遍历一边数组，然后让i和j指向的数字取异或，每次维护res值<br>暴力的思想很简单，但是因为是n方的算法，所有是肯定会超时的<br>然后我们想怎么优化，要想让异或取最大，如果我们给定一个数，那么我们对应位上的0和1，要和给定的数字尽可能的不同<br>这样异或出来的结果是最大的，其实是贪心的思想。<br>那我们让i去遍历数组，然后建立Trie树，在树上寻找尽可能和给定的数字对应位上的0和1不同的数字<br>如果有那最好，如果没有那只能取相同的。<br>根据给定的数据范围，Trie树的深度最大就为30，所以这个算法的时间复杂度是30*n，最大也就是10^6，使满足在1s内结束工作的<br>思路就是这样，然后我们结合代码来看</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nconst int N &#x3D; 100010,M &#x3D; 3000010; \nint son[M][2],idx; &#x2F;&#x2F;这里M是代表总的节点数最大为多少 (为什么是300w，因为一共就100000个数据，然后一个数据最多就30个结点，一乘不就是300w了?)\nint a[N],n; &#x2F;&#x2F;存n个数据\n\n&#x2F;&#x2F;插入函数，把数据以01的形式插入到我们的Trie树中去  \nvoid insert(int x)&#123;\n    int p&#x3D;0;&#x2F;&#x2F;p代表指向当前节点的指针\n    &#x2F;&#x2F;因为数字化为01之后，最大长度就是30位，我们从最高位开始把01存入我们Trie树中去\n    for(int i&#x3D;30;i&gt;&#x3D;0;i--)&#123;\n        int&amp; s&#x3D;son[p][x&gt;&gt;i&amp;1]; &#x2F;&#x2F;这里s代表第p个节点的子节点，x&gt;&gt;i&amp;1表示取x第i位的值，是0还是1\n        if(!s)&#123; &#x2F;&#x2F;如果没有s这个节点，则创建一个。\n            s&#x3D;++idx; \n        &#125;\n        p&#x3D;s;&#x2F;&#x2F;让p指向这个s\n    &#125;\n&#125;\n&#x2F;&#x2F;这个query操作呢，是给你一个数，然后在Trie树里面寻找最优解，将结果返回\nint query(int x)&#123;\n    int res&#x3D;0;\n    int p&#x3D;0;\n    for(int i&#x3D;30;i&gt;&#x3D;0;i--)&#123;\n        int s&#x3D;x&gt;&gt;i&amp;1; &#x2F;&#x2F;取x的第i位，从尾巴开始计数的\n        if(son[p][!s])&#123; &#x2F;&#x2F;判断存不存在与当前位不同的\n            res+&#x3D;1&lt;&lt;i; &#x2F;&#x2F;存在，也就是给结果贡献一个1，从高位开始的\n            p&#x3D;son[p][!s];&#x2F;&#x2F;让p指向那边\n        &#125;\n        else&#123;\n            p&#x3D;son[p][s]; &#x2F;&#x2F;不存在，那结果里面那位就是零，等于没操作\n        &#125;\n    &#125;\n    return res;&#x2F;&#x2F;最后返回res\n&#125;\n&#x2F;&#x2F;main函数里面的操作就非常简单了\nint main()&#123;\n    cin&gt;&gt;n;\n    for(int i&#x3D;0;i&lt;n;i++)&#123;\n        cin&gt;&gt;a[i];\n        insert(a[i]);\n    &#125;\n    int res&#x3D;0;\n    for(int i&#x3D;0;i&lt;n;i++)&#123;\n        res&#x3D;max(res,query(a[i]));\n    &#125;\n    cout&lt;&lt;res&lt;&lt;endl;\n    return 0;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n<h2 id=\"并查集\"><a href=\"#并查集\" class=\"headerlink\" title=\"并查集\"></a>并查集</h2><p><a href=\"https://www.acwing.com/problem/content/838/\">题目链接-合并集合</a><br>题目是这样的：给你n个数字，他们构成了一个permutation，起初他们都各自在一个集合中<br>然后以下给出m个操作，M a b表示将编号为a和b的数字合并集合，如果已经在一个集合里面了，等于没做<br>Q a b询问a和b在同一个集合里面吗？</p>\n<p>我们先来思考暴力做法<br>一共就是两个操作对吧，一个是合并两个集合，一个是查询两个数字是否在同一个集合。<br>如果我们给每个数字标上一个标号，标号表示他是哪个集合的。<br>初始状态，我们规定，第i个数字，标号为i表示他的是第i个集合的<br>如何合并两个数字？很简单，把标号改一下就可以了<br>如何查询两个，很简单，查询一下他们的标号是否一样就可以了<br>看似这两步的时间复杂度不是很大<br>但其实有问题<br>就是在合并两个集合的时候<br>比如我已经有了一个集合了，然后要让一个数并入到这个集合中去，把这个数的标号记成他们的标号就可以了<br>可是实际的操作的时候，我们并不知道这个标准，你怎么知道a和b那个是单独的一个数字，那个是一个集合<br>甚至两个都在一个集合中，然后要求你合并呢？<br>就算真的做到了<br>也会变成n方的复杂度<br>所以，这里我们就使用并查集<br>存储的逻辑其实和上面差不多，不过是结合树的结构的，同时要运用路劲压缩，不然复杂度也会很大<br>下面结合代码来看</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">#include&lt;bits&#x2F;stdc++.h&gt;;\nusing namespace std;\nconst int N  &#x3D; 100010;\nint p[N]; &#x2F;&#x2F;p数组，表示第i个数字的双亲节点是那个，初始化默认p[i]&#x3D;i，同时也表示他是根节点；\n&#x2F;&#x2F;这题的核心函数，find函数，用处是寻找一个节点的根节点\n&#x2F;&#x2F;这个find函数的写法是真的太妙了，\nint find(int x)&#123;\n    if(p[x]!&#x3D;x)&#123;&#x2F;&#x2F;如果当前节点的双亲节点不是他自身，表示他不是根节点，继续find，采用递归的方式\n        p[x]&#x3D;find(p[x]); &#x2F;&#x2F;同时采用路径压缩，直接将这个节点的双亲节点改为根节点，这样之后能够减少递归次数，这一步太妙了\n    &#125;\n    return p[x]; &#x2F;&#x2F;最后返回根节点\n&#125;\n\nint main()&#123;\n    int n,m;\n    cin&gt;&gt;n&gt;&gt;m;\n    for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;\n        p[i]&#x3D;i; &#x2F;&#x2F;初始化p数据\n    &#125;\n    while(m--)&#123;\n        char op;\n        cin&gt;&gt;op;\n        int a,b;\n        cin&gt;&gt;a&gt;&gt;b;\n        if(op&#x3D;&#x3D;&#39;M&#39;)&#123;\n            p[find(a)]&#x3D;find(b); &#x2F;&#x2F;如果让合并的话，就让a的根节点连到b的根节点上去\n        &#125;\n        else&#123;\n            if(find(a)&#x3D;&#x3D;find(b))&#123; &#x2F;&#x2F;如果根节点一样，那么说明在一个集合中\n                cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl;\n            &#125;\n            else&#123;\n                cout&lt;&lt;&quot;No&quot;&lt;&lt;endl;\n            &#125;\n        &#125;\n    &#125;\n    return 0;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>总结一下这题的话，并查集的思想其实和前面想的建立一个标志数组一样，只不过单纯的用各个数字来表示在一个集合内有他的缺陷。<br>采用树的结构的话，就没有这种缺陷<br>同时这里要进行路径优化，不然也会超时</p>\n<p>That’s all<br>Bye!~</p>\n","text":"今天的内容是Trie树的应用和并查集的学习。这个最大异或对的话，就是Trie树的应用，然后有别于之前那个Trie树存的数据不一样，之前那个存的是char，现在这个存的是0和1。然后并查集的话感觉就是构建了一个森林，然后每一颗树代表了一定的信息。 最大异或对最大异或对。题目是啥呢，...","link":"","photos":[],"count_time":{"symbolsCount":"3.9k","symbolsTime":"4 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":39,"path":"api/tags/ACM.json"},{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"算法","slug":"算法","count":20,"path":"api/tags/算法.json"},{"name":"数据结构","slug":"数据结构","count":23,"path":"api/tags/数据结构.json"},{"name":"并查集","slug":"并查集","count":2,"path":"api/tags/并查集.json"},{"name":"Trie树","slug":"Trie树","count":1,"path":"api/tags/Trie树.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%9C%80%E5%A4%A7%E5%BC%82%E6%88%96%E5%AF%B9\"><span class=\"toc-text\">最大异或对</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%B9%B6%E6%9F%A5%E9%9B%86\"><span class=\"toc-text\">并查集</span></a></li></ol>","author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"tech otakus save the world","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}},"mapped":true,"prev_post":{"title":"ACM学习笔记day13(求连通块中点的数量)","uid":"d45c53bbd2d951bda24bba0bdde79964","slug":"ACM学习笔记day13","date":"2022-11-25T11:42:49.000Z","updated":"2023-04-08T10:50:52.060Z","comments":true,"path":"api/articles/ACM学习笔记day13.json","keywords":null,"cover":"/img/codeforces.jpg","text":"今天的内容是求连通块中点的数量 求连通块中点的数量这题和并查集那道模板题差不多就是多了一个要求让你统计集合中的数量而已 这里我们用到一个cnt数组，同时我们规定，只有根节点的cnt数据是有意义的这样我们就避免了要给多个同连通块的集合重新赋值的麻烦 #include&lt;bits...","link":"","photos":[],"count_time":{"symbolsCount":"1.5k","symbolsTime":"1 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":39,"path":"api/tags/ACM.json"},{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"学习","slug":"学习","count":43,"path":"api/tags/学习.json"},{"name":"算法","slug":"算法","count":20,"path":"api/tags/算法.json"},{"name":"数据结构","slug":"数据结构","count":23,"path":"api/tags/数据结构.json"},{"name":"并查集","slug":"并查集","count":2,"path":"api/tags/并查集.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"tech otakus save the world","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}},"next_post":{"title":"ACM学习笔记day11(Trie树)","uid":"cf4a03b1403b8a8d56d4650e2b121d28","slug":"ACM学习笔记day11","date":"2022-11-20T13:36:27.000Z","updated":"2023-04-08T10:50:36.627Z","comments":true,"path":"api/articles/ACM学习笔记day11.json","keywords":null,"cover":"/img/codeforces.jpg","text":"Hello guys！今天学习的内容是Trie树，应该也是叫字典树题目链接acwing 直接上代码吧理解不难 #include&lt;iostream&gt; #include&lt;string&gt; using namespace std; const int N &#x3...","link":"","photos":[],"count_time":{"symbolsCount":"1.6k","symbolsTime":"1 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":39,"path":"api/tags/ACM.json"},{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"学习","slug":"学习","count":43,"path":"api/tags/学习.json"},{"name":"算法","slug":"算法","count":20,"path":"api/tags/算法.json"},{"name":"数据结构","slug":"数据结构","count":23,"path":"api/tags/数据结构.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"tech otakus save the world","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}}}