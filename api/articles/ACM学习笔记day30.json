{"title":"ACM学习笔记day30 (01背包，完全背包,多重背包(朴素解法))","uid":"26c83eef7dc2b42905d68bf63d792926","slug":"ACM学习笔记day30","date":"2023-02-11T11:53:11.000Z","updated":"2023-04-08T10:53:02.760Z","comments":true,"path":"api/articles/ACM学习笔记day30.json","keywords":null,"cover":"/img/codeforces.jpg","content":"<p>今天的内容是01背包多重背包完全背包。<br>算是开启DP专题了。<br>01背包是作为最关键的一个题目。<br>其他完全背包和多重背包其实就是他的扩展。<br>理解了01背包，理解其他的背包其实不难。</p>\n<span id=\"more\"></span>\n\n<h1 id=\"01背包\"><a href=\"#01背包\" class=\"headerlink\" title=\"01背包\"></a><a href=\"https://www.acwing.com/problem/content/2/\">01背包</a></h1><p>01背包问题的解法，先从朴素开始。<br>我们定义一个二维数组作为我们dp的数组。<br>f[i][j]的意义为从前i个物品中拿，背包容量为j的情况下最大的价值量。<br>那么我们容易得到，对于第i个物品，我们可以拿或者不拿。因为只有一件所以只有这两个选项。<br>如果不拿，那么简单,f[i][j]&#x3D;f[i-1][j]。<br>如果拿，那么f[i][j]&#x3D;f[i-1][j-v[i]]+w[i];<br>当然这里j要大于等于v[i]的。<br>所以我们背包的code也就非常自然的得出来了。</p>\n<p>ac code:</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nconst int N &#x3D;  1010;\nint f[N][N];\nint n,m;\nint w[N],v[N];\n\nint main()&#123;\n    cin&gt;&gt;n&gt;&gt;m;\n    for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;\n        cin&gt;&gt;v[i]&gt;&gt;w[i];\n    &#125;\n    for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;\n        for(int j&#x3D;0;j&lt;&#x3D;m;j++)&#123;\n            f[i][j]&#x3D;f[i-1][j]; &#x2F;&#x2F;这边从0开始和从1开始都是可以的，j&#x3D;0的时候相当于初始化了背包为零的时候所有的值，也就是都是零。\n                               &#x2F;&#x2F;不过这里因为数组开在堆里面，所以都一样的。\n            if(j&gt;&#x3D;v[i])&#123;\n                f[i][j]&#x3D;max(f[i][j],f[i-1][j-v[i]]+w[i]);\n            &#125;\n        &#125;\n    &#125;\n    int res&#x3D;0;\n    for(int i&#x3D;0;i&lt;&#x3D;m;i++)&#123;\n        res&#x3D;max(res,f[n][i]);\n    &#125;\n    cout&lt;&lt;res&lt;&lt;endl;\n    return 0;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n<p>那么我们可不可以将这个二维数组降低一个维度，从而减少空间复杂度呢？<br>答案是可以的。<br>我们可以从递推式中发现，我们需要的只是第i层的数据和第i-1层的数据。<br>所以说我们可以使用滚动数组来做。<br>不断维护第i层和第i-1层就可以了。</p>\n<p>降低维数之后的code为：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nconst int N &#x3D; 1010;\nint w[N],v[N];\nint n,m;\nint dp[N];\n\nint main()&#123;\n    cin&gt;&gt;n&gt;&gt;m;\n    for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;\n        cin&gt;&gt;v[i]&gt;&gt;w[i];\n    &#125;\n    for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;\n        for(int j&#x3D;m;j&gt;&#x3D;0;j--)&#123;\n            dp[j]&#x3D;dp[j];\n            &#x2F;&#x2F;这里原来是dp[i][j]&#x3D;dp[i-1][j];去掉一维之后，dp[j]的值就是没更新前的值。实际上没啥意义（\n            if(j-v[i]&gt;&#x3D;0)&#123;\n                dp[j]&#x3D;max(dp[j],dp[j-v[i]]+w[i]); \n                &#x2F;&#x2F;这里原来是dp[i][j]&#x3D;max(dp[i][j],dp[i-1][j-v[i]]+w[i])。\n                &#x2F;&#x2F;因为我们第二个式子中我们要的是上一行的j-v[i]的值。而如果我们还是按照原来的做法，j从0开始遍历的话，每次访问j-v[i]的时候都是更新之后的，所以我们要倒着遍历。从而确保\n                &#x2F;&#x2F;我们访问的是i-1行的j-v[i]的值而不是i行的。\n            &#125;\n        &#125;\n    &#125;\n    cout&lt;&lt;dp[m]&lt;&lt;endl;\n    return 0;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n<h1 id=\"完全背包问题\"><a href=\"#完全背包问题\" class=\"headerlink\" title=\"完全背包问题\"></a><a href=\"https://www.acwing.com/problem/content/3/\">完全背包问题</a></h1><p>完全背包问题就是使得每一件物品都可以拿无限多个。</p>\n<p>那么其实我们基于01背包的做法，对于第i个物品。<br>我们有若干个选择，<br>可以拿0个，拿1个，2个….直到背包里面放不下了。<br>也就是说<br>那么我们按照思路来做，只需要在01背包的二维实现中在最里面再套一个循环就可以了。<br>但是这样会使得时间复杂度变为O(n^3)。对于1000个数据是会超时的。<br>所以我们要优化。<br>注意到：</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>f[i][j]&#x3D;max(f[i-1][j],f[i-1][j-v[i]]+w[i],f[i-1][j-2<em>v[i]]+2</em>w[i]….)<br>而我们对j进行一个换元。<br>j&#x3D;j-v[i];<br>f[i][j-v[i]]&#x3D;max(f[i-1][j-v[i]],f[i-1][j-2*v[i]]+w[i]…..)</p></blockquote>\n<p>上面那条等式max的除了第一个元素的部分，其实就是f[i][j-v[i]]+w[i]。<br>所以我们不用里面再套一个循环，直接用</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>f[i][j]&#x3D;max(f[i-1][j],f[i][j-v[i]]+w[i])即可。</p></blockquote>\n<p>ac code:</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nconst int N &#x3D; 1010;\nint n,m;\nint v[N],w[N];\nint dp[N][N];\n\nint main()&#123;\n    cin&gt;&gt;n&gt;&gt;m;\n    for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;\n        cin&gt;&gt;v[i]&gt;&gt;w[i];\n    &#125;\n    for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;\n        for(int j&#x3D;0;j&lt;&#x3D;m;j++)&#123;\n            dp[i][j]&#x3D;dp[i-1][j];\n            if(j&gt;&#x3D;v[i])&#123;\n                dp[i][j]&#x3D;max(dp[i][j],dp[i][j-v[i]]+w[i]);\n            &#125;\n        &#125;\n    &#125;\n    cout&lt;&lt;dp[n][m]&lt;&lt;endl;\n    return 0;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>那么对于完全背包我们能不能也优化到一维数组呢？<br>也是可以的。</p>\n<p>注意到：</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>dp[i][j]&#x3D;max(dp[i][j],dp[i][j-v[i]]+w[i]);</p></blockquote>\n<p>和01背包类似，如果我们把i这一维优化了，我们需要使用的是dp[i][j-v[i]]也就是说我们已经更新过的数据。<br>那么和01背包的优化类似，但是相反，我们这里需要从头开始遍历，而不是倒过来遍历j。</p>\n<p>优化的code:</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nconst int N &#x3D; 1010;\nint n,m;\nint v[N],w[N];\nint dp[N];\n\nint main()&#123;\n    cin&gt;&gt;n&gt;&gt;m;\n    for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;\n        cin&gt;&gt;v[i]&gt;&gt;w[i];\n    &#125;\n    for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;\n        for(int j&#x3D;v[i];j&lt;&#x3D;m;j++)&#123;\n            \n                dp[j]&#x3D;max(dp[j],dp[j-v[i]]+w[i]);\n            \n        &#125;\n    &#125;\n    cout&lt;&lt;dp[m]&lt;&lt;endl;\n    return 0;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h1 id=\"多重背包I\"><a href=\"#多重背包I\" class=\"headerlink\" title=\"多重背包I\"></a><a href=\"https://www.acwing.com/problem/content/4/\">多重背包I</a></h1><p>多重背包就是完全背包的基础上，给你限制了每个物品拿的个数。<br>因为这个I是朴素版本的，也就是说给的n和m比较小，n三次方的复杂度可以过。<br>所以按照完全背包的朴素做法去做就可以了。<br>当然要注意，循环的上限是有两个，一个是背包容量，一个是物品件数限制。</p>\n<p>下面为ac code:</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nint n,m;\nconst int N &#x3D; 110;\nint dp[N][N];\nint v[N],w[N],s[N];\n\nint main()&#123;\n    cin&gt;&gt;n&gt;&gt;m;\n    for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123; \n        cin&gt;&gt;v[i]&gt;&gt;w[i]&gt;&gt;s[i];\n    &#125;\n    for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;\n        for(int j&#x3D;0;j&lt;&#x3D;m;j++)&#123;\n            dp[i][j]&#x3D;dp[i-1][j];\n            for(int k&#x3D;1;k&lt;&#x3D;s[i]&amp;&amp;j&gt;&#x3D;k*v[i];k++)&#123;\n              dp[i][j]&#x3D;max(dp[i][j],dp[i-1][j-k*v[i]]+k*w[i]);  \n            &#125;\n        &#125;\n    &#125;\n    cout&lt;&lt;dp[n][m]&lt;&lt;endl;\n    return 0;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>接下来还有一个用二进制优化的多重背包，下次再写XD。<br>我们下次见捏。<br>Bye.</p>\n","text":"今天的内容是01背包多重背包完全背包。算是开启DP专题了。01背包是作为最关键的一个题目。其他完全背包和多重背包其实就是他的扩展。理解了01背包，理解其他的背包其实不难。 01背包01背包问题的解法，先从朴素开始。我们定义一个二维数组作为我们dp的数组。f[i][j]的意义为从前...","link":"","photos":[],"count_time":{"symbolsCount":"4.8k","symbolsTime":"4 mins."},"categories":[{"name":"ACM","slug":"ACM","count":40,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":37,"path":"api/tags/ACM.json"},{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"学习","slug":"学习","count":41,"path":"api/tags/学习.json"},{"name":"蒟蒻","slug":"蒟蒻","count":4,"path":"api/tags/蒟蒻.json"},{"name":"DP","slug":"DP","count":5,"path":"api/tags/DP.json"},{"name":"动态规划","slug":"动态规划","count":5,"path":"api/tags/动态规划.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#01%E8%83%8C%E5%8C%85\"><span class=\"toc-text\">01背包</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">完全背包问题</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85I\"><span class=\"toc-text\">多重背包I</span></a></li></ol>","author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"喜欢前沿科技，想要见证人类科学的飞跃","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}},"mapped":true,"prev_post":{"title":"ACM学习笔记day31 (多重背包(二进制优化)，分组背包)","uid":"c4215acd2eabdb6df78cd852601c9d9a","slug":"ACM学习笔记day31","date":"2023-02-18T08:34:37.000Z","updated":"2023-04-08T10:53:14.362Z","comments":true,"path":"api/articles/ACM学习笔记day31.json","keywords":null,"cover":"/img/codeforces.jpg","text":"今天的内容是多重背包的二进制优化解法和分组背包。 一开始听多重背包的二进制优化的时候还是蛮难的， 后来知道一个关键点之后就容易了。至于分组背包，其实和多重背包差不多的，只不过选择上稍微变了点。 多重背包（二进制优化）关于多重背包的一个二进制优化。我们原来的朴素做法就是，枚举第i个...","link":"","photos":[],"count_time":{"symbolsCount":"2.6k","symbolsTime":"2 mins."},"categories":[{"name":"ACM","slug":"ACM","count":40,"path":"api/categories/ACM.json"}],"tags":[{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"学习","slug":"学习","count":41,"path":"api/tags/学习.json"},{"name":"DP","slug":"DP","count":5,"path":"api/tags/DP.json"},{"name":"动态规划","slug":"动态规划","count":5,"path":"api/tags/动态规划.json"},{"name":"背包问题","slug":"背包问题","count":1,"path":"api/tags/背包问题.json"},{"name":"背包","slug":"背包","count":1,"path":"api/tags/背包.json"},{"name":"多重背包","slug":"多重背包","count":1,"path":"api/tags/多重背包.json"},{"name":"分组背包","slug":"分组背包","count":1,"path":"api/tags/分组背包.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"喜欢前沿科技，想要见证人类科学的飞跃","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}},"next_post":{"title":"Chicken McNugget Theorem","uid":"de8de93bec780c9d57906902a53cb751","slug":"Chicken-McNugget-Theorem","date":"2023-02-09T07:50:47.000Z","updated":"2023-08-25T14:16:54.225Z","comments":true,"path":"api/articles/Chicken-McNugget-Theorem.json","keywords":null,"cover":"/img/二次元の图/1.jpg","text":"麦乐鸡定理(bushi)链接 The Chicken McNugget Theorem (or Postage Stamp Problem or Frobenius Coin Problem) states that for any two relatively prime po...","link":"","photos":[],"count_time":{"symbolsCount":366,"symbolsTime":"1 mins."},"categories":[{"name":"数学","slug":"数学","count":1,"path":"api/categories/数学.json"}],"tags":[{"name":"数学","slug":"数学","count":7,"path":"api/tags/数学.json"},{"name":"定理","slug":"定理","count":1,"path":"api/tags/定理.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"喜欢前沿科技，想要见证人类科学的飞跃","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}},"feature":true}}