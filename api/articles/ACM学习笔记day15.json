{"title":"ACM学习笔记day15(哈希，字符串的哈希)","uid":"5358138299a8ff147d7f561517fe5a1d","slug":"ACM学习笔记day15","date":"2022-12-02T12:15:59.000Z","updated":"2023-04-08T10:51:06.595Z","comments":true,"path":"api/articles/ACM学习笔记day15.json","keywords":null,"cover":"/img/codeforces.jpg","content":"<p>hello guys！<br>今天的学习内容是哈希表，也就是散列表<br>对应acwing上的<a href=\"https://www.acwing.com/problem/content/842/\">模拟散列表</a>和<a href=\"https://www.acwing.com/problem/content/843/\">字符串哈希</a></p>\n<span id=\"more\"></span>\n\n<p>那么问题来了<br>什么是哈希表呢？<br>一句话来总结就是，不保序的离散化<br>离散化其实是哈希化的一种特殊情况<br>我们将数据范围很大的，较少的数字，映射到一个比较小的数组，这就是哈希，不过中间的那个映射值是哈希函数做的事情，也是导致他可能不保序的原因<br>一般的，我们将哈希函数定义为x取余给的数字的总数之后的最小的一个质数<br>比如给定10w个数字，100000之后的最小的一个质数是100003,那我们就将哈希函数定义为<br>x%100003,当然，我们一般讲N就初始化为100003，这样我们直接%N就可以了<br>然后我们接下来如果要找一个数x有没有，只要计算一下他的hash值，然后去哈希数组里面去找就可以了<br>没有就是没有<br>接下来，在计算哈希值的时候，容易产生的一个问题就是哈希冲突的问题<br>什么是哈希冲突？<br>就是明明是不同的两个数字，却存在了同一个地方，这就产生了问题。</p>\n<h2 id=\"哈希冲突\"><a href=\"#哈希冲突\" class=\"headerlink\" title=\"哈希冲突\"></a>哈希冲突</h2><p>防止哈希冲突的方法有两种，一种是拉链法<br>什么是拉链法？<br>但说实话我感觉他更应该叫吊带法，感觉不像拉链，像很多的丝带吊在上面<br>拉链法中，我们使用一个h[N]来作为杆子，h的值是指针，指向等会使用的链表节点<br>然后我们使用一个链表ele[N],和ne[N]来维护杆子上n个口子可能产生的n个链表<br>h[hash[i]],h数组的下标是我们加入进来的数字的hash值，我们加入进来的输入存入链表当中<br>然后我们每插入一个数字，就相当于在以h[hash[i]]为头结点的表头插入一个元素。<br>这样我们就用拉链法解决了hash冲突的问题，在平均情况下，我们可以认为哈希的存储和访问都是O（1）的<br>当然极端情况下，比如每个数字的存入都是冲突的，导致查询一个数字是O(n)的，这种情况太极端了，我们一般不考虑<br>代码如下：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nconst int N &#x3D;100003;\nint ele[N],ne[N],idx;\nvector&lt;int&gt; h(N,-1);\n\nvoid insert(int x)&#123;\n    int k&#x3D;(x%N+N)%N;\n    ele[idx]&#x3D;x;\n    ne[idx]&#x3D;h[k];\n    h[k]&#x3D;idx++;\n&#125;\n\nbool find(int x)&#123;\n    int k&#x3D;(x%N+N)%N;\n    for(int i&#x3D;h[k];i!&#x3D;-1;i&#x3D;ne[i])&#123;\n        if(ele[i]&#x3D;&#x3D;x)&#123;\n            return true;\n        &#125;\n    &#125;\n    return false;\n&#125;\n\nint main()&#123;\n    int n;\n    cin&gt;&gt;n;\n    while(n--)&#123;\n        string s;\n        cin&gt;&gt;s;\n        if(s&#x3D;&#x3D;&quot;I&quot;)&#123;\n            int x;\n            cin&gt;&gt;x;\n            insert(x);\n        &#125;\n        else &#123;\n            int x;\n            cin&gt;&gt;x;\n            if(find(x))&#123;\n                cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl;\n            &#125;\n            else&#123;\n                cout&lt;&lt;&quot;No&quot;&lt;&lt;endl;\n            &#125;\n        &#125;\n    &#125;\n    return 0;\n&#125;</code></pre>\n\n<p>还有一种是开放寻址法<br>什么是开放寻址法呢？<br>感觉就是向你去上厕所，你要上的这个坑位，有人了<br>那就去下一个，如果还是有人了，继续去下一个<br>直到到一个空位，然后数据存进去<br>这就是开放寻址法<br>开放寻址法不像拉链法需要额外开两个数组，作为链表来存储数据<br>但是开放寻址法需要注意的是，存储数据的长度需要大一点，一般是给的数据量最大的两到三倍。<br>同时我们需要的注意的是，我们一开始的时候要初始化数据为null，null为一个极大值，可以取成int的上界<br>我们用null来表示这个位置为空，但是我觉得应该另外开一个数组来表示是否为空应该也可以，不过这样的话<br>开放寻址法也要再开一个数组了，就不能体现出他的一个特点了awa<br>代码如下：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nconst int N &#x3D; 200003, null&#x3D;0x3f3f3f3f;\nint h[N];\n\nint find (int x)&#123;\n    int k&#x3D;(x%N+N)%N;\n    while(h[k]!&#x3D;x&amp;&amp;h[k]!&#x3D;null)&#123;\n        k++;\n        if(k&#x3D;&#x3D;N)&#123;\n            k&#x3D;0;\n        &#125;\n    &#125;\n    return k;\n&#125;\n\nint main()&#123;\n    int n;\n    cin&gt;&gt;n;\n    for(int i&#x3D;0;i&lt;N;i++)&#123;\n        h[i]&#x3D;null;\n    &#125;\n    while(n--)&#123;\n        string str;\n        cin&gt;&gt;str;\n        int x;\n        cin&gt;&gt;x;\n        int t&#x3D;find(x);\n        if(str&#x3D;&#x3D;&quot;I&quot;)&#123;\n            h[t]&#x3D;x;\n        &#125;\n        else&#123;\n            if(h[t]&#x3D;&#x3D;null)&#123;\n                cout&lt;&lt;&quot;No&quot;&lt;&lt;endl;\n            &#125;\n            else&#123;\n                cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl;\n            &#125;\n        &#125;\n    &#125;\n&#125;</code></pre>\n<p>接下来是字符串的哈希<br>这个就有点难理解了<br>比之前那个普通的哈希要稍微难一点<br>但是实际写起来的代码量还是很少的<br>所以关键就在于如何理解字符串哈希</p>\n<h2 id=\"字符串哈希\"><a href=\"#字符串哈希\" class=\"headerlink\" title=\"字符串哈希\"></a>字符串哈希</h2><p>什么是字符串的哈希？<br>顾名思义嗷<br>其实就是让一个字符串对应一个数值，这个数值我们就定义为他的哈希值<br>而这个数值怎么来的，就是我们的哈希函数<br>首先我们为了能够在O(1)的时间内求出一段字符串任意一段子串的哈希值，我们要预处理一下给定字符串<br>也就是求一下给定字符串的前缀的哈希值<br>然后运用前缀和的理论，来快速的求出任意一段的哈希值<br>当然我们要说一个哈希冲突的问题，字符串哈希也是可能哈希冲突的<br>但是这个概率很小，基本上99.99%的时候都不用考虑字符串哈希冲突的问题<br>如果真冲突了，额，那也不是我能做出来的（<br>所以字符串哈希和一般的哈希不太一样，他不用考虑哈希冲突的问题，当然这不是说他不可能发生啊<br>好<br>我们回到刚才那个问题上来，首先我们抛出两个问题<br>怎么求前缀和的哈希值<br>以及怎么通过前缀和去求任意一段字符串的哈希值<br>这里我们的哈希手法是：</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>把字符串看成是一个P进制的数字，位数从左往右越来越低，然后使用每一位字母的ASCII码值作为该位对应的值<br>一般的，我们取P为131或者13331，这样的话，产生哈希冲突的概率最小，<br>同时我们产生了一个新的问题，就是我们按照P进制，把字符串转化为哈希值之后，产生的数字可能会很大，那么我们就取模2^64，将结果限定在longlong的范围内<br>为了避免，我们要写%2^64这样的操作，我们使用unsigned long long，这个类型，当数据越界了之后，他会自动取模，可以让我们省略取模的动作</p></blockquote>\n<p>字符串前缀的哈希值是多少我们解决了，<br>那么如何求任意一段的哈希值呢？<br>比如l~r的这一段的哈希值<br>很简单，我们把h[r]按照P进制写出来，h[l-1]按照P进制写出来<br>不难发现，我们要求的一段的字符串的哈希值，是同样按照P进制转化为10进制化出来的<br>那么我们只要把h[l-1]按照p进制左移直到左对齐，然后h[r]-h[l-1]即可得到结果<br>因为大的那个是r位的<br>小的那个是l-1位的<br>所以要移动的位数为r-l+1位<br>即h[l-1]*p^(r-l+1);<br>综上，我们字符串哈希的很多问题已近解决了<br>代码如下</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\ntypedef unsigned long long ULL;\nconst int N &#x3D; 100010, P &#x3D;131;\nint n,m;\nstring s;\nULL h[N],p[N];\n\nULL get(int l,int r)&#123;\n    return h[r]-h[l-1]*p[r-l+1];\n&#125;\n\nint main()&#123;\n    cin&gt;&gt;n&gt;&gt;m;\n    s+&#x3D;&quot; &quot;;\n    string str;\n    cin&gt;&gt;str;\n    s+&#x3D;str;\n    p[0]&#x3D;1;\n    for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;\n        p[i]&#x3D;p[i-1]*P;\n        h[i]&#x3D;h[i-1]*P+s[i];\n    &#125;\n    while(m--)&#123;\n        int l1,r1,l2,r2;\n        cin&gt;&gt;l1&gt;&gt;r1&gt;&gt;l2&gt;&gt;r2;\n        if(get(l1,r1)&#x3D;&#x3D;get(l2,r2))&#123;\n            cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl;\n        &#125;\n        else&#123;\n            cout&lt;&lt;&quot;No&quot;&lt;&lt;endl;\n        &#125;\n    &#125;\n    return 0;\n&#125;</code></pre>\n\n<p>OK That’s all<br>我们下次再见~<br>Bye~</p>\n","text":"hello guys！今天的学习内容是哈希表，也就是散列表对应acwing上的模拟散列表和字符串哈希 那么问题来了什么是哈希表呢？一句话来总结就是，不保序的离散化离散化其实是哈希化的一种特殊情况我们将数据范围很大的，较少的数字，映射到一个比较小的数组，这就是哈希，不过中间的那个映...","link":"","photos":[],"count_time":{"symbolsCount":"4.8k","symbolsTime":"4 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":39,"path":"api/tags/ACM.json"},{"name":"学习","slug":"学习","count":43,"path":"api/tags/学习.json"},{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"数据结构","slug":"数据结构","count":23,"path":"api/tags/数据结构.json"},{"name":"算法","slug":"算法","count":20,"path":"api/tags/算法.json"},{"name":"笔记","slug":"笔记","count":3,"path":"api/tags/笔记.json"},{"name":"哈希表","slug":"哈希表","count":1,"path":"api/tags/哈希表.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81\"><span class=\"toc-text\">哈希冲突</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C\"><span class=\"toc-text\">字符串哈希</span></a></li></ol>","author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"tech otakus save the world","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}},"mapped":true,"prev_post":{"title":"ACM学习笔记day16(朴素dijkstra求最短路径)","uid":"569c66ff03a6fea9d4ceedb2c072fa60","slug":"ACM学习笔记day16","date":"2022-12-03T13:32:15.000Z","updated":"2023-04-08T10:51:15.100Z","comments":true,"path":"api/articles/ACM学习笔记day16.json","keywords":null,"cover":"/img/codeforces.jpg","text":"Hello，guys！今天我们学习的内容是dijkstra算法求最短路径,题目emm，第一次学这个的话，感觉还是比较抽象的，不过想了一段时间，稍微整理了一下思路，感觉也还可以应该（ 朴素Dijkstra为什么叫朴素dijkstra呢？因为目前这个dijkstra算法的时间复杂度是...","link":"","photos":[],"count_time":{"symbolsCount":"2.8k","symbolsTime":"3 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":39,"path":"api/tags/ACM.json"},{"name":"学习","slug":"学习","count":43,"path":"api/tags/学习.json"},{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"数据结构","slug":"数据结构","count":23,"path":"api/tags/数据结构.json"},{"name":"算法","slug":"算法","count":20,"path":"api/tags/算法.json"},{"name":"蒟蒻","slug":"蒟蒻","count":4,"path":"api/tags/蒟蒻.json"},{"name":"dijkstra","slug":"dijkstra","count":1,"path":"api/tags/dijkstra.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"tech otakus save the world","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}},"next_post":{"title":"ACM学习笔记day14（带权并查集，堆排序，模拟堆）","uid":"baee1de5b96302e6e975d5e11b914928","slug":"ACM学习笔记day14","date":"2022-12-01T14:13:12.000Z","updated":"2023-04-08T10:50:59.395Z","comments":true,"path":"api/articles/ACM学习笔记day14.json","keywords":null,"cover":"/img/codeforces.jpg","text":"Hello guys!感觉好久没有写笔记了，上次写笔记好像是呃呃呃，五天前了吧。要忙学校的好多事情，呜呜呜，我有罪orz好了，不bb了，今天的学习内容是带权并查集（食物链）,堆模拟,堆排序 带权并查集带权并查集就是原来并查集的升级版，plus版本。相较于原来的普通的并查集，带权并...","link":"","photos":[],"count_time":{"symbolsCount":"8.2k","symbolsTime":"7 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":39,"path":"api/tags/ACM.json"},{"name":"学习","slug":"学习","count":43,"path":"api/tags/学习.json"},{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"数据结构","slug":"数据结构","count":23,"path":"api/tags/数据结构.json"},{"name":"算法","slug":"算法","count":20,"path":"api/tags/算法.json"},{"name":"带权并查集","slug":"带权并查集","count":1,"path":"api/tags/带权并查集.json"},{"name":"堆","slug":"堆","count":1,"path":"api/tags/堆.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"tech otakus save the world","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}}}