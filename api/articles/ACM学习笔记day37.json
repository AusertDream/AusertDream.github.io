{"title":"ACM学习笔记day37 (最短路算法总结)","uid":"d62cd488fd25981616571e6226f3871a","slug":"ACM学习笔记day37","date":"2023-03-25T12:51:16.000Z","updated":"2024-12-29T14:18:21.976Z","comments":true,"path":"api/articles/ACM学习笔记day37.json","keywords":null,"cover":"/img/codeforces.jpg","content":"<p>好，我们这一节对最短路算法作一个总结。<br>总的来说基础的最短路算法有四种。<br>分别为 Dijksta,bellman-ford，spfa，floyd算法。<br>不同的算法应对的是不同的情况。</p>\n<span id=\"more\"></span>\n\n<p>什么算法解决什么问题，可以看下面这张图。</p>\n<p><img src=\"https://raw.githubusercontent.com/AusertDream/MyblogImags/main/%E5%9B%BE%E8%AE%BA%E6%9C%80%E7%9F%AD%E8%B7%AF%E9%97%AE%E9%A2%98%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6%E5%9B%BE.png\" alt=\"dfsa\"></p>\n<p>我们最短路问题，可以分为两大类问题，一类是单源最短路，也就是从固定的一个顶点出发到另外一个点的最短距离。<br>另外一类就是多源最短路，这类问题就是我们要求出的最短路，出发点是不固定的。</p>\n<p>我们依次来进行总结。</p>\n<h1 id=\"Dijkstra\"><a href=\"#Dijkstra\" class=\"headerlink\" title=\"Dijkstra\"></a>Dijkstra</h1><p>Dijkstra算法分为两种，一种是朴素版本的，另外一种是堆优化版本的。<br>他们的区别就在于时间复杂度的不同。</p>\n<h2 id=\"朴素Dijkstra\"><a href=\"#朴素Dijkstra\" class=\"headerlink\" title=\"朴素Dijkstra\"></a>朴素Dijkstra</h2><p>Dijkstra求最短路的思想是这样的。<br>我们需要定义两个集合，一个集合是我们已经确定好最短路的节点，另外一个集合就是我们没有确定好最短路的节点。<br>我们进行n次循环，每次循环中我们从没有确定好最短路的节点中选择一个距离源点最近的节点，我们用这个节点去更新所有其他节点的距离值。<br>那么具体来说怎么更新呢？<br>事实上，我们所说的用这个节点去更新所有其他节点的值<br>就是在 他本来的值 和 从源点到这个节点+这个节点到当前节点的距离 中选择距离最小的，来更新他自己的值。<br>说明白点就是我们如果一定要要求从源点到当前这个节点要经过我们所选择的那个节点，看看这样做的距离和他自己本来的距离谁小。<br>这就是他自己更新的过程。<br>n次循环之后，我们就可以得到答案。<br>那么这里我们其实可以发现，Dijkstra每次循环的时候，其实都是确定了一个点的最短距离。<br>所以n次之后，每一个点的最短距离也就被确定了。<br>事实上，我们n-1次就够用了，因为最后一个节点的距离在n-1次的时候已经被确定了，在进行第n次循环的时候，其实做的是冗余操作。<br>因为dist[n]&#x3D;min(dist[n],dist[n]+d[n][n])这一步其实是没有操作的，而对于其他的节点，最短距离已经被确定了，那么min值肯定也是取不到的。<br>这就是朴素Dijkstra的做法。<br><a href=\"https://www.acwing.com/problem/content/851/\">题目</a></p>\n<p>ac code:</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nconst int N &#x3D; 510;\nint d[N][N];\nint n,m;\nint dist[N];\nbool st[N];\nconst int INF &#x3D; 0x3f3f3f3f;\n\nvoid dijkstra()&#123;\n    memset(dist,INF,sizeof dist);\n    dist[1]&#x3D;0;\n    for(int i&#x3D;0;i&lt;n;i++)&#123;\n        int t &#x3D; -1;\n        for(int j&#x3D;1;j&lt;&#x3D;n;j++)&#123;\n            if(st[j]&#x3D;&#x3D;false&amp;&amp;(t&#x3D;&#x3D;-1||dist[j]&lt;dist[t]))&#123;\n                t&#x3D;j;\n            &#125;\n        &#125;\n        st[t]&#x3D;true;\n        for(int j&#x3D;1;j&lt;&#x3D;n;j++)&#123;\n            dist[j]&#x3D;min(dist[j],dist[t]+d[t][j]);\n        &#125;\n    &#125;\n&#125;\n\nint main()&#123;\n    cin&gt;&gt;n&gt;&gt;m;\n    memset(d,INF,sizeof d);\n    for(int i&#x3D;0;i&lt;m;i++)&#123;\n        int x,y,z;\n        cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;\n        if(x!&#x3D;y)&#123;\n            d[x][y]&#x3D;min(d[x][y],z);   \n        &#125;\n    &#125;\n    for(int i&#x3D;0;i&lt;&#x3D;n;i++)&#123;\n        d[i][i]&#x3D;0;\n    &#125;\n    dijkstra();\n    \n    if(dist[n]&lt;INF) cout&lt;&lt;dist[n]&lt;&lt;endl;\n    else cout&lt;&lt;-1&lt;&lt;endl;\n    return 0;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"堆优化的Dijkstra\"><a href=\"#堆优化的Dijkstra\" class=\"headerlink\" title=\"堆优化的Dijkstra\"></a>堆优化的Dijkstra</h2><p>说起优化，那么我们就要思考，哪里可以优化？<br>很显然我们发现，可以优化的地方就是，选择距离源点最近的点<br>这个过程我们可以优化，因为我们需要选择的是dist值最小的点<br>那么为了处理这一类的问题，我们一般会用到什么数据结构？<br>对，就是堆。<br>我们将结果都存入堆中再进行查询，从而能够将时间复杂度从n方降低到logn</p>\n<p><a href=\"https://www.acwing.com/problem/content/852/\">题目</a></p>\n<p>ac code:</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nconst int N &#x3D;  1.5e5+10;\ntypedef pair&lt;int,int&gt; PII;\nint h[N],e[N],ne[N],d[N],idx;\nint n,m;\nconst int INF &#x3D; 0x3f3f3f3f;\nint dist[N];\nbool st[N];\n\nvoid add(int a,int b,int c)&#123;\n    e[idx]&#x3D;b,d[idx]&#x3D;c,ne[idx]&#x3D;h[a],h[a]&#x3D;idx++;\n&#125;\n\nvoid dijkstra()&#123;\n    memset(dist,INF,sizeof dist);\n    priority_queue&lt;PII,vector&lt;PII&gt;,greater&lt;PII&gt;&gt; work;\n    dist[1]&#x3D;0;\n    work.push(&#123;0,1&#125;);\n    while(work.size())&#123;\n        auto t &#x3D; work.top();\n        work.pop();\n        int dd &#x3D; t.first;\n        int node &#x3D; t.second;\n        if(st[node]) continue;\n        st[node]&#x3D;1;\n\n        \n        for(int i &#x3D; h[node];i!&#x3D;-1;i&#x3D;ne[i])&#123;\n            int j &#x3D;e[i];\n            if(dist[j]&gt;dd+d[i])&#123;\n                dist[j]&#x3D;dd+d[i];\n                work.push(&#123;dist[j],j&#125;);\n            &#125;\n        &#125;\n    &#125;\n    \n&#125;\n\nint main()&#123;\n    cin&gt;&gt;n&gt;&gt;m;\n    memset(h,-1,sizeof h);\n    for(int i&#x3D;0;i&lt;m;i++)&#123;\n        int a,b,c;\n        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;\n        add(a,b,c);\n    &#125;\n    \n    \n    \n    dijkstra();\n    if(dist[n]&lt;INF) cout&lt;&lt;dist[n]&lt;&lt;endl;\n    else cout&lt;&lt;-1&lt;&lt;endl;\n    \n    return 0;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>这里堆优化的做法，其实整体的写法和朴素做法是有大不相同的。<br>首先可以看到的是，我们存储表的时候采用了领接表的形式。<br>因为他已经不是稠密图了。<br>其次可以看到的是，dijkstra函数中我们循环的主体是一个while循环，也就是没有确定最短路的集合。<br>我们不但需要记录他的距离，同时还要记录当前这个距离是哪个节点的。<br>所以我们需要用到PII用来存储这样成对的信息。<br>那么这就是堆优化的dijkstra算法，整体的思路还是和朴素做法差不多的，但是写法上还是有很大的差别的。</p>\n<p>做个总结，dijkstra算法能够适用的场景只有图中仅有非负权边的时候，如果存在负环，这个算法是不能正常运作的。<br>因为可能结果会偏大。</p>\n<p>那么针对有负权边的单源最短路问题，我们采用的算法是bellman-ford和SPFA。</p>\n<h1 id=\"bellman-ford\"><a href=\"#bellman-ford\" class=\"headerlink\" title=\"bellman-ford\"></a>bellman-ford</h1><p>bellman-ford算法来求单源最短路的思路就是：</p>\n<p>进行n次循环<br>每次循环去遍历所有的边a-&gt;b 边权为w<br>我们更新dist[b]&#x3D;min(dits[b],dist[a]+w)</p>\n<p>这就是bellman-ford算法。<br>其中我们更新dist数组的值的过程成为松弛操作。<br>而且我们对于bellman-ford算法，我们存储边的方式是随意的，只要能够让我们遍历所有的边即可。</p>\n<p>这里我们需要了解一个东西，那就是我们一开始的n次循环意味着什么。<br>bellman-ford中最外层是有一个循环的，这个循环的循环次数，实际上是和他求解的答案是有关的。<br>这也就是bellman-ford所能处理的一类特殊的问题——有边数限制的最短路。<br>边数限制至多多少条，就循环多少次。</p>\n<p>同时，我们要知道，bellman-ford是可以用来判断是否有负权回路的。<br>因为n次循环之后，dist[n]一定就是最小值了。<br>如果再一次进行松弛操作，dist[n]的值还能够减小，就说明存在负权回路。<br>这个时候其实他的最短路是不一定存在的。</p>\n<p><a href=\"https://www.acwing.com/problem/content/855/\">题目</a></p>\n<p>ac code:</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nconst int N &#x3D; 510,M &#x3D; 1e4+10;\nconst int INF &#x3D; 0x3f3f3f3f;\ntypedef struct edge&#123;\n    int a,b,w;\n&#125;;\nedge edges[M];\nint dist[N],backup[N];\nint n,m,k;\n\nbool bellmanford()&#123;\n    memset(dist,INF,sizeof dist);\n    dist[1]&#x3D;0;\n    for(int i&#x3D;0;i&lt;k;i++)&#123;\n        memcpy(backup,dist,sizeof dist);\n        for(int j&#x3D;0;j&lt;m;j++)&#123;\n            auto ele &#x3D; edges[j];\n            dist[ele.b]&#x3D;min(dist[ele.b],backup[ele.a]+ele.w);\n        &#125;\n    &#125;\n    if(dist[n]&lt;INF&#x2F;2) return true;\n    else return false;\n&#125;\n\nint main()&#123;\n    cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;\n    for(int i&#x3D;0;i&lt;m;i++)&#123;\n        int a,b,w;\n        cin&gt;&gt;a&gt;&gt;b&gt;&gt;w;\n        edges[i]&#x3D;&#123;a,b,w&#125;;\n    &#125;\n    \n    int res &#x3D; bellmanford();\n    if(res)&#123;\n        cout&lt;&lt;dist[n]&lt;&lt;endl;\n    &#125;\n    else&#123;\n        cout&lt;&lt;&quot;impossible&quot;&lt;&lt;endl;\n    &#125;\n    \n    \n    return 0;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>这里要注意一个问题，就是题解中我们使用了backup数组用来备份dist数组。<br>为什么要用到这个数组呢？因为要防止出现串联的问题。<br>为什么要防止串联式的更新？<br>因为如果允许串联式的更新，那么我们n次循环之后的结果，dist的值一定是至少过了n条边的，而不是至多n条边。<br>所以如果不是这道题的话，只是单纯的求最短路，那么这个backup数组是用不到的其实。</p>\n<p>总结，bellman-ford算法能够适用于存在负权边的图，并且他也能够求图中是否存在负权回路，总的来说功能还是比较强大的。<br>但是唯一的缺点就是时间复杂度太大了。O(n*m)的时间复杂度导致他能够适用的数据量是特别小的。</p>\n<h1 id=\"SPFA\"><a href=\"#SPFA\" class=\"headerlink\" title=\"SPFA\"></a>SPFA</h1><p>SPFA的思想其实是优化了bellman-ford算法的。<br>我们可以看到bellman-ford算法，他更新边的时候，是无脑更新所有的边的。<br>那么很显然，我们可以发现，如果我们到一个节点的距离没有被更新成更短的话，他们这个节点他的后继节点也是没办法通过这个节点更新到更短的。<br>所以我们的SPFA算法就解决了这样的一个问题。<br>SPFA的思想其实就是，我们用更新过的节点，去更新他的后继节点的dist。<br>啥意思呢？就是某个节点的dist值刚被更新过，说明他的值变小了对吧。<br>那么我们可以用这个节点去更新他的后继节点，因为他是被更新过的，所以他的后继节点也是有机会被更新变短的。</p>\n<p>那么实际实现的时候，我们会先建立一个queue，用来存放dist值被更新过的点。<br>然后我们每次用queue头的那个节点，去更新他的所有的后继节点，如果后继节点的值也被更新了，那么就把他放进去对吧。<br>当然如果已经在里面的话，就不需要放了。</p>\n<p><a href=\"https://www.acwing.com/problem/content/853/\">题目</a></p>\n<p>ac code:</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nconst int N &#x3D; 1e5+10;\nint e[N],ne[N],h[N],idx,w[N];\nint dist[N];\nbool st[N];\nint n,m;\nconst int INF &#x3D; 0x3f3f3f3f;\n\nvoid add(int a,int b,int c)&#123;\n    e[idx]&#x3D;b,w[idx]&#x3D;c,ne[idx]&#x3D;h[a],h[a]&#x3D;idx++;\n&#125;\n\nvoid spfa()&#123;\n    memset(dist,INF,sizeof dist);\n    queue&lt;int&gt; work;\n    dist[1]&#x3D;0;\n    st[1]&#x3D;0;\n    work.push(1);\n    while(work.size())&#123;\n        int t &#x3D; work.front();\n        work.pop();\n        st[t]&#x3D;false;\n        for(int i&#x3D;h[t];i!&#x3D;-1;i&#x3D;ne[i])&#123;\n            int j &#x3D; e[i];\n            if(dist[j]&gt;dist[t]+w[i])&#123;\n                dist[j]&#x3D;dist[t]+w[i];\n                if(!st[j])&#123;\n                    work.push(j);\n                    st[j]&#x3D;1;\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n&#125;\n\nint main()&#123;\n    cin&gt;&gt;n&gt;&gt;m;\n    memset(h,-1,sizeof h);\n    for(int i&#x3D;0;i&lt;m;i++)&#123;\n        int a,b,c;\n        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;\n        add(a,b,c);\n    &#125;\n    spfa();\n    if(dist[n]&lt;INF&#x2F;2) cout&lt;&lt;dist[n]&lt;&lt;endl;\n    else cout&lt;&lt;&quot;impossible&quot;&lt;&lt;endl;\n    return 0;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n<p>其实我们看上面的代码，我们会发现。<br>spfa的做法其实和堆优化的dijkstra还是很像的。<br>不过堆优化的dijktra他的那个queue的意义是没有确定最短路的点，<br>而spfa的意义是最短路被更新过的点。<br>然后同样的操作都是，用队头的点去更新后继节点的dist值。<br>这个算法的时间复杂度是很快的，一般为O(m)，最坏的情况下为O(n*m)</p>\n<h1 id=\"floyd\"><a href=\"#floyd\" class=\"headerlink\" title=\"floyd\"></a>floyd</h1><p>floyd算法解决的是多源最短路问题。<br>也就是说，我们query的时候，终点和起点是不一定的，并不是唯一的。<br>那么这里，我们就不能够采用之前的任何一种算法了。<br>因为之前的算法解决的都是单源的问题，也就是起点和终点是固定的。</p>\n<p>floyd的算法思想也很简单，就是一个三重循环。<br>先枚举k，然后枚举i和j，每次更新的是i节点到j节点的距离<br>如果i-&gt;j，并且经过k节点的距离比直接i到j要短那么就更新这段距离。<br><strong>注意，这里的更新是直接在存储的地方更新的。</strong><br>一般我们会采用领接矩阵，所以相当于是直接对领接矩阵进行更新。</p>\n<p>这里我们需要注意的是，我们枚举的经过的中间节点k，必须是在最外层的循环。<br>不然是会出问题的。</p>\n<p><a href=\"https://www.acwing.com/problem/content/856/\">题目链接</a></p>\n<p>ac code:</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nint n,m,k;\nconst int N &#x3D; 210;\nint a[N][N];\n\n\nvoid floyd()&#123;\n    for(int k&#x3D;1;k&lt;&#x3D;n;k++)&#123;\n        for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;\n            for(int j&#x3D;1;j&lt;&#x3D;n;j++)&#123;\n                a[i][j]&#x3D;min(a[i][j],a[i][k]+a[k][j]);\n            &#125;\n        &#125;\n    &#125;\n&#125;\nint main()&#123;\n    cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;\n    memset(a,0x3f3f3f3f,sizeof a);\n    for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;\n        a[i][i]&#x3D;0;\n    &#125;\n    for(int i&#x3D;0;i&lt;m;i++)&#123;\n        int x,y,z;\n        cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;\n        a[x][y]&#x3D;min(a[x][y],z);\n    &#125;\n    floyd();\n    while(k--)&#123;\n        int x,y;\n        cin&gt;&gt;x&gt;&gt;y;\n        if(a[x][y]&gt;0x3f3f3f3f&#x2F;2) cout&lt;&lt;&quot;impossible&quot;&lt;&lt;endl;\n        else cout&lt;&lt;a[x][y]&lt;&lt;endl;\n    &#125;\n    \n    return 0;\n&#125;\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>这个算法的时间复杂度为O(n^3)，可以看到时间复杂度还是很高的。</p>\n<p>好的，那么至此基础的最短路算法总结就到此为止了。也算了填了一个很久的坑了吧。<br>终于填完了XD<br>我们下次再见<br>Bye~</p>\n","feature":false,"text":"好，我们这一节对最短路算法作一个总结。总的来说基础的最短路算法有四种。分别为 Dijksta,bellman-ford，spfa，floyd算法。不同的算法应对的是不同的情况。 什么算法解决什么问题，可以看下面这张图。 我们最短路问题，可以分为两大类问题，一类是单源最短路，也就是...","link":"","photos":[],"count_time":{"symbolsCount":"8.9k","symbolsTime":"8 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":39,"path":"api/tags/ACM.json"},{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"学习","slug":"学习","count":43,"path":"api/tags/学习.json"},{"name":"最短路问题","slug":"最短路问题","count":1,"path":"api/tags/最短路问题.json"},{"name":"Dijkstra","slug":"Dijkstra","count":1,"path":"api/tags/Dijkstra.json"},{"name":"Bellman-ford","slug":"Bellman-ford","count":1,"path":"api/tags/Bellman-ford.json"},{"name":"spfa","slug":"spfa","count":1,"path":"api/tags/spfa.json"},{"name":"floyd","slug":"floyd","count":1,"path":"api/tags/floyd.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Dijkstra\"><span class=\"toc-text\">Dijkstra</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%9C%B4%E7%B4%A0Dijkstra\"><span class=\"toc-text\">朴素Dijkstra</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A0%86%E4%BC%98%E5%8C%96%E7%9A%84Dijkstra\"><span class=\"toc-text\">堆优化的Dijkstra</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#bellman-ford\"><span class=\"toc-text\">bellman-ford</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#SPFA\"><span class=\"toc-text\">SPFA</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#floyd\"><span class=\"toc-text\">floyd</span></a></li></ol>","author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"tech otakus save the world","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}},"mapped":true,"prev_post":{"title":"ACM学习笔记day38(最小生成树,染色法判定二分图，匈牙利算法)","uid":"aade77e076015616546b7ec40503f52f","slug":"ACM学习笔记day38","date":"2023-03-25T12:51:23.000Z","updated":"2023-08-27T09:15:36.952Z","comments":true,"path":"api/articles/ACM学习笔记day38.json","keywords":null,"cover":"/img/codeforces.jpg","text":"在总结了各种的最短路算法之后，我们终于也是迎来了，图论基础算法的最后一部分内容。一个是最小生成树的求法。一个是有关二分图的问题。 关于这部分的内容，可以看下面这个大致的思维导图。 最小生成树对于基础的图论。最小生成树一共有两种算法。一种是prim算法，一种就是kruskal算法。...","link":"","photos":[],"count_time":{"symbolsCount":"9.4k","symbolsTime":"9 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":39,"path":"api/tags/ACM.json"},{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"Prim","slug":"Prim","count":1,"path":"api/tags/Prim.json"},{"name":"Kruskal","slug":"Kruskal","count":1,"path":"api/tags/Kruskal.json"},{"name":"染色法","slug":"染色法","count":1,"path":"api/tags/染色法.json"},{"name":"二分图","slug":"二分图","count":1,"path":"api/tags/二分图.json"},{"name":"匈牙利算法","slug":"匈牙利算法","count":1,"path":"api/tags/匈牙利算法.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"tech otakus save the world","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}},"next_post":{"title":"ACM学习笔记day36(树和图的DFS和BFS)","uid":"1429a762104f1c731f39acc20f00d741","slug":"ACM学习笔记day36","date":"2023-03-25T12:50:55.000Z","updated":"2023-04-08T10:54:15.019Z","comments":true,"path":"api/articles/ACM学习笔记day36.json","keywords":null,"cover":"/img/codeforces.jpg","text":"水一篇blog（树和图的bfs和dfs。 树和图的存储方式采用领接表或者是领接矩阵都可以。dfs和bfs的思路是一样的。bfs套用bfs的模板就可以了，定义一个工作队列。将没有访问过的领接点放入队列中，然后处理即可dfs就遍历他的所有领接点，然后如果没访问过的话就dfs下去。然后...","link":"","photos":[],"count_time":{"symbolsCount":"1.9k","symbolsTime":"2 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":39,"path":"api/tags/ACM.json"},{"name":"学习","slug":"学习","count":43,"path":"api/tags/学习.json"},{"name":"图论","slug":"图论","count":3,"path":"api/tags/图论.json"},{"name":"dfs","slug":"dfs","count":4,"path":"api/tags/dfs.json"},{"name":"bfs","slug":"bfs","count":3,"path":"api/tags/bfs.json"},{"name":"树","slug":"树","count":1,"path":"api/tags/树.json"},{"name":"图","slug":"图","count":1,"path":"api/tags/图.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"tech otakus save the world","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}}}