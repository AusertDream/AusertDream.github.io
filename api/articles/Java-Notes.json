{"title":"Java Notes","uid":"f0b9b0e433bb738921b4a846a4505450","slug":"Java-Notes","date":"2024-01-07T12:21:49.000Z","updated":"2024-01-12T12:27:53.107Z","comments":true,"path":"api/articles/Java-Notes.json","keywords":null,"cover":"/img/javalogo.png","content":"<h1 id=\"序言\"><a href=\"#序言\" class=\"headerlink\" title=\"序言\"></a>序言</h1><p>因课设需要以及工作需要，不得不得开始学java了。</p>\n<p>以下为作为学习java的整体笔记，包括一切有关java的架构或者已经写好的包。</p>\n<p>java版本采用2021年之后的java17。</p>\n<p>因为本身已经学过C&#x2F;C++了，所以对于java基础的内容仅简单的介绍和记笔记，不作过多的解释。</p>\n<p>缩写解释：</p>\n<p>涉及到的java代码，有部分缩写，下面这张表给出缩写和全拼的对应关系。</p>\n<table>\n<thead>\n<tr>\n<th>缩写</th>\n<th>全拼</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>sout</td>\n<td>System.out.println</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<h1 id=\"java基础知识\"><a href=\"#java基础知识\" class=\"headerlink\" title=\"java基础知识\"></a>java基础知识</h1><h2 id=\"基本名词\"><a href=\"#基本名词\" class=\"headerlink\" title=\"基本名词\"></a>基本名词</h2><p>首先需要知道的是java代码是在虚拟机上运行的，而不是像C++那样自己本地跑的。所以java中需要引入虚拟机的概念，也就是JVM</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>JVM(Java Virtual Machine): 运行java的虚拟机。</p>\n<p>JDK：JDK开发包，将java代码编译后然后在JVM上运行的一个打包好的工作包。</p>\n<p>JRE：直接使用已经编译好的字节码在JVM上运行的环境，成为JRE。不用过多了解。</p></blockquote>\n<p>具体关系图可以看下图：</p>\n<p><img src=\"/../img/Java/JDKJREJVM.png\" alt=\"关系图\"></p>\n<h2 id=\"开发环境安装\"><a href=\"#开发环境安装\" class=\"headerlink\" title=\"开发环境安装\"></a>开发环境安装</h2><p>安装的是jdk17。</p>\n<p>使用以下cmd命令查看java版本。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">java -version<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>我用的是java version “17.0.6”</p>\n<p>然后装IDEA，也就是装IJ，自己装去。</p>\n<h2 id=\"初始源文件解释\"><a href=\"#初始源文件解释\" class=\"headerlink\" title=\"初始源文件解释\"></a>初始源文件解释</h2><p>运行的代码源文件是在src文件夹下的，代码源文件是新建一个java class文件。</p>\n<p>以上过程就相当于在cpp源文件中创建一个cpp文件，只不过java创建的要是javaclass。<del>（好奇怪啊</del></p>\n<p>如果想在src中创建多个文件夹，然后将源代码文件放进去，需要在src中创建package，然后在package中创建javaclass文件。</p>\n<p>这里package相当于一般的文件夹。<del>（真的好怪啊</del></p>\n<p>package下的源代码文件需要在代码头上标注 <code>package 对应文件名</code></p>\n<p>out文件存放src中源码编译之后的文件，文件扩展名是.class</p>\n<p>观察一下最基本的java代码：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public class Main &#123;\n    public static void main(String[] args) &#123;\n        System.out.println(&quot;Hello world!&quot;);\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>代码中的关键字和C++中的是一个意思。</p>\n<p>这里需要知道的是java中一切以类为基本单位，也就是说一个java文件中有且仅有一个class类，并且这个仅存在的类里面，必须要有一个main函数，作为这个类的起点函数。</p>\n<p>Main类是整个java程序的起点，main函数是类的起点。</p>\n<p>main函数中的参数args和C语言中的一样，是放参数表列的。</p>\n<h2 id=\"基础语法\"><a href=\"#基础语法\" class=\"headerlink\" title=\"基础语法\"></a>基础语法</h2><p>注释：&#x2F;&#x2F;   &#x2F;**&#x2F; 和C++一样</p>\n<p>TODO功能：在重点文字或者内容前面添加TODO关键词，从而使注释凸出显示，同时在下方工具栏中可以重点显示。类似一个todolist的功能。是IDEA提供的功能。</p>\n<p>e.g:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">//114514</span>\n<span class=\"token comment\">// TODO 14514</span>\n<span class=\"token comment\">//141341</span>\n<span class=\"token comment\">//12312</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>Java数据类型：</p>\n<p><img src=\"/../img/Java/dataType.png\" alt=\"img\" title=\"DataTypeInJava\"></p>\n<p>数据定义和C++一样。</p>\n<p>byte：8位</p>\n<p>short：16位</p>\n<p>int：32位</p>\n<p>long：64位</p>\n<p>float：单精度，32位</p>\n<p>double：双精度，64位</p>\n<p>注意到：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">float</span> b <span class=\"token operator\">=</span> <span class=\"token number\">1.0</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//这会报错，因为java中对于1.0这种常量默认认为是双精度的，而double不能复制给float，需要标识1.0的数据类型。</span>\n<span class=\"token keyword\">float</span> b <span class=\"token operator\">=</span> <span class=\"token number\">1.0f</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//如此改正即可。</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>boolean：取值为true or false。和C++一样。</p>\n<p>有关数据转化的问题：</p>\n<p>值域范围大的数据不可以直接复制给值域小的，会直接报错（C++里面不会报错），反之是允许的。</p>\n<p>强制类型转化方法和C++一样，不过只有以下这种形式的。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">int</span> a <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">)</span>b<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">int</span> a <span class=\"token operator\">=</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">(</span>b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//这样是不允许的，java里面没有这种方法。</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>Java中的运算符：</p>\n<p>绝大部分的运算符和C++中的一样。</p>\n<p>&amp;&amp;和||和C++中一样都是短路运算符。</p>\n<p>不过java中的&amp;,|不仅可以用于一般的位运算，还可以用于逻辑运算。</p>\n<p>作为逻辑运算的时候不是短路运算符。&amp;和|操作的两边的操作数，不可以类型不一致。</p>\n<p>e.g</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">boolean</span> <span class=\"token operator\">|</span> <span class=\"token keyword\">int</span>\n<span class=\"token comment\">//这是不允许的。必须要手动的强制类型转化，java不会提供隐式类型转化</span>\n<span class=\"token comment\">//同时按位取反是用~</span>\n<span class=\"token comment\">//逻辑取反是用!</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><em>java中的顺序，循环，分支结构代码操作和c++中一样。</em></p>\n<h1 id=\"面向对象\"><a href=\"#面向对象\" class=\"headerlink\" title=\"面向对象\"></a>面向对象</h1><h2 id=\"基本语法\"><a href=\"#基本语法\" class=\"headerlink\" title=\"基本语法\"></a>基本语法</h2><h3 id=\"类的定义和使用\"><a href=\"#类的定义和使用\" class=\"headerlink\" title=\"类的定义和使用\"></a>类的定义和使用</h3><p>类的定义和使用大部分和C++一样，只不过用类去定义对象的时候，不像c++那样可以直接用，而是用类名，变量名，然后new一个出来。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">ClassName</span> <span class=\"token class-name\">VarName</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ClassName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>用这种方式来构建一个对象，他所对应的类就是ClassName。</p>\n<p>并且类内定义貌似没有public和private的定义， 但实际上好像是有的，存疑。</p>\n<h3 id=\"内存使用分布\"><a href=\"#内存使用分布\" class=\"headerlink\" title=\"内存使用分布\"></a>内存使用分布</h3><p>一共分为三种区域。</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">栈</th>\n<th>用于存放方法和变量的空间</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">堆</td>\n<td>用于存放对象的空间</td>\n</tr>\n<tr>\n<td align=\"center\">元空间</td>\n<td>用于存放类的信息的空间</td>\n</tr>\n</tbody></table>\n<p>其中，堆空间要大于另外两个空间。</p>\n<p><strong>对象的赋值其实是将存放在堆空间的对象的地址赋给变量，所以变量其实是引用了内存中的对象。</strong></p>\n<h3 id=\"类中属性初始化\"><a href=\"#类中属性初始化\" class=\"headerlink\" title=\"类中属性初始化\"></a>类中属性初始化</h3><p>有一种特殊的对象：**空对象(null)**，没有引用的对象，称之为空对象，又称为关键字对象。</p>\n<p>引用类型变量的默认值就是空对象(null)。</p>\n<p>在<strong>类中的变量</strong>在未初始化的时候均会有一个默认值。这个默认值和C++中堆空间定义的变量差不多。<br>引用类型变量默认值是null，也就是空对象，其他的和c++中的一样。</p>\n<p>变量的作用域范围和C++同理。</p>\n<h3 id=\"可变参数\"><a href=\"#可变参数\" class=\"headerlink\" title=\"可变参数\"></a>可变参数</h3><p>当参数表列中，参数数量不确定，但是参数类型都一样的时候，可以使用可变参数。语法如下</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">void</span> <span class=\"token function\">functino</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n\tsystem<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>使用…来修饰数据类型。来表示可变参数，注意，可变参数只能作为所有参数表列的最后一个参数，如果不是，会引起歧义报错。</p>\n<h3 id=\"方法传值方式\"><a href=\"#方法传值方式\" class=\"headerlink\" title=\"方法传值方式\"></a>方法传值方式</h3><p>默认传值方式是复制类型的，也就是C++里面一样，都是值传递。</p>\n<p>并且java中只有值传递，没有指针引用啥的。</p>\n<p>当然碰到引用数据类型的时候，其实就是引用传递，String除外。</p>\n<p>事实上，String是因为他在修改的时候会产生一个新的String。</p>\n<h3 id=\"静态\"><a href=\"#静态\" class=\"headerlink\" title=\"静态\"></a>静态</h3><p>我们把和对象无关，只和类相关的称之为静态。</p>\n<p>只和类相关的属性称之为静态属性。</p>\n<p>只和类相关的方法称之为静态方法。</p>\n<p>静态语法就是在属性或者方法前面添加一个关键字 <code>static</code></p>\n<p>因为静态和对象无关，只和类相关，所以我们可以不创建对象就可访问静态属性或者方法。</p>\n<p>e.g</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token function\">sout</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">MyClass</span><span class=\"token punctuation\">.</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">MyClass</span><span class=\"token punctuation\">.</span><span class=\"token function\">func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">MyClass</span><span class=\"token punctuation\">&#123;</span>\n\t<span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span> a<span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n\t\tsystem<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"111454\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>成员方法可以访问静态属性和静态方法，但是静态方法不可以访问成员属性和成员方法。</p>\n<p>逻辑：静态是类共有的，是在对象创建之前的，成员属性和成员方法是在对象创建之后才产生的，所以才会设置这样的规则。</p>\n<p>By the way,静态的东西是存放在元空间的（也就是存放类的信息的地方。</p>\n<h3 id=\"静态代码块\"><a href=\"#静态代码块\" class=\"headerlink\" title=\"静态代码块\"></a>静态代码块</h3><p>静态代码块的语法如下：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">class</span> myclass<span class=\"token punctuation\">&#123;</span>\n\t<span class=\"token keyword\">static</span> <span class=\"token punctuation\">&#123;</span>\n\t\t<span class=\"token comment\">//静态代码块段</span>\n\t<span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>其实就是在类里面，用static修饰了一块用大括号括起来的代码段，表示静态代码段。</p>\n<p>静态代码段会在该类被加载的时候自动执行。并且只会执行一遍。</p>\n<p>什么叫做类被加载？其实也就是初次调用类的静态方法的时候或者初次new一个该类的对象的时候，类就会被加载，然后静态代码块就会执行。在这之后，类就是已经被加载过了，静态代码块也不会再次执行了。</p>\n<p>所以静态代码块一般用于类中变量的初始化。同时如果有多段静态代码块，那么在类加载的时候，依次执行。</p>\n<p>逻辑：类的静态代码块其实就相当于对象的构造函数。一个是类加载的时候自动执行，一个是对象创建的时候自动执行。</p>\n<p>当然，如果想在创建对象的时候自动跑一段代码，直接加一段代码块即可，即使上面的东西，去掉static修饰词。</p>\n<p>逻辑：本质上还是就是分清类所拥有的东西和对象所拥有的东西。</p>\n<h3 id=\"包\"><a href=\"#包\" class=\"headerlink\" title=\"包\"></a>包</h3><p>存放类的容器，说白了就是个文件夹用来存放java文件，而java代码中都是在类里面的，所以包就是一个存放类的容器。</p>\n<p>基本语法: <code>package 包路径</code> 。如果要涉及子包，使用.来访问子包 <code>package pk_father.pk_child</code>。</p>\n<p>一个源文件中只能package至多一次，可以没有，但是有只能一次。同时为了区分类名，包名一般小写。</p>\n<p>包可以区分不同包内的相同名称的类。使用方法如下：</p>\n<p><code>java.util.Date()</code> Date是java包中的util包中的一个类。</p>\n<p>因此，一般我们在使用类的时候会使用类的全名(包名+类名)</p>\n<h3 id=\"import-导入\"><a href=\"#import-导入\" class=\"headerlink\" title=\"import 导入\"></a>import 导入</h3><p>import 主要用于导入包中的类，从而使得在使用的时候不需要加包地址。（有点像使用名字空间，但本质上又不一样）</p>\n<p>import只能使用在package后，class前。</p>\n<p>import用法如下：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">//导入单个类</span>\n<span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">java<span class=\"token punctuation\">.</span>lang<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">String</span></span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//String就是lang包里面的类名</span>\n\n<span class=\"token comment\">//导入整个包里面的所有类 </span>\n<span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">java<span class=\"token punctuation\">.</span>lang<span class=\"token punctuation\">.</span></span><span class=\"token operator\">*</span></span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//用*通配符来表示导入这个包里面的所有类。</span>\n<span class=\"token comment\">//当然事实上lang这个包是不需要手动导入的，JVM已经帮你干了这个事情了。</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>注意：如果import了不同包中的相同名字的类，还是要用包路径来区别的，为了防止歧义。</p>\n<h3 id=\"构造方法\"><a href=\"#构造方法\" class=\"headerlink\" title=\"构造方法\"></a>构造方法</h3><p>构造方法和C++的构造函数一样的。</p>\n<p>构造方法的运行优先级低于代码块，也就是先代码块都执行完了，才轮到构造方法执行。</p>\n<h3 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h3><p>继承含义和C++中的继承一样。继承父类只能有一个，但是一个父类可以有多个子类。</p>\n<p>继承采用extends语法，使用例子如下：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Parent</span><span class=\"token punctuation\">&#123;</span>\n\n<span class=\"token punctuation\">&#125;</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Child</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Parent</span><span class=\"token punctuation\">&#123;</span>\n\n<span class=\"token punctuation\">&#125;</span>\n<span class=\"token comment\">//如此Child类就继承了Parent中的成员变量和成员方法，当然构造方法是不继承的。</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>当父类和子类中存在名称相同的变量的时候，使用super和this关键词来区分开来，使用方法和C++中类似，不强调的时候默认是this。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">super</span><span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">;</span><span class=\"token comment\">//super表示父类的这个name变量</span>\n<span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">;</span><span class=\"token comment\">//this表示当前类的这个name变量</span>\n<span class=\"token comment\">//也就是说super指的是父类的，this指的是当前类的。</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>创建多个子类的时候，每一个子类创建前都会先构建父类。当然实际上父类对象并不会真的创建，而是调用构造函数之后，将父类参数给子类而已。</p>\n<p>考虑以下这种情况，父类的构造方法需要传参数，但是子类的构造方法不需要传参数：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Parent</span><span class=\"token punctuation\">&#123;</span>\n\t<span class=\"token class-name\">String</span> name<span class=\"token punctuation\">;</span>\n\t<span class=\"token class-name\">Parent</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n\t\tname<span class=\"token operator\">=</span>s<span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Child</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Parent</span><span class=\"token punctuation\">&#123;</span>\n\t<span class=\"token class-name\">Child</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n\t\t<span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"4558\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//使用super来进行父类的含参构造函数的调用。</span>\n\t<span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token comment\">//理解：其实可以将super就理解为父类的类名，从而去理解使用super()来代表父类的构造函数。</span>\n<span class=\"token comment\">//当然一般super是会自动调用的，当父类需要传递参数的时候，才需要自己写。</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>其实就是子类和父类都有构造函数的时候，子类构造函数中需要调用一下父类的构造函数，用super表示他的父类，如果不带参数，那么JVM就帮你做了这个工作了，不需要自己写。</p>\n<h3 id=\"多态\"><a href=\"#多态\" class=\"headerlink\" title=\"多态\"></a>多态</h3><p>多态的含义和C++面向对象的多态意思一样。</p>\n<h3 id=\"方法重载与重写\"><a href=\"#方法重载与重写\" class=\"headerlink\" title=\"方法重载与重写\"></a>方法重载与重写</h3><p>方法重载就是函数重载，和C++一样的。</p>\n<p>方法名一样，但是参数表列不一样，成为方法重载。</p>\n<p>方法重写：</p>\n<h1 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h1><p>[1] java中的类在用一个对象赋值给另外一个对象的时候，都是引用赋值，也就相当于用的是C++里面的&amp;，比如对象B赋值给对象C，C修改内容的时候，你输出B，B里面的内容也会被修改，原理看java基础知识，变量的原理。这里只有String是例外，不遵循这套原则。</p>\n<p>[2]</p>\n","text":"序言因课设需要以及工作需要，不得不得开始学java了。 以下为作为学习java的整体笔记，包括一切有关java的架构或者已经写好的包。 java版本采用2021年之后的java17。 因为本身已经学过C&#x2F;C++了，所以对于java基础的内容仅简单的介绍和记笔记，不作过多...","link":"","photos":[],"count_time":{"symbolsCount":"5.3k","symbolsTime":"5 mins."},"categories":[{"name":"Java","slug":"Java","count":1,"path":"api/categories/Java.json"}],"tags":[{"name":"Java","slug":"Java","count":1,"path":"api/tags/Java.json"},{"name":"language","slug":"language","count":1,"path":"api/tags/language.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%BA%8F%E8%A8%80\"><span class=\"toc-text\">序言</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86\"><span class=\"toc-text\">java基础知识</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E6%9C%AC%E5%90%8D%E8%AF%8D\"><span class=\"toc-text\">基本名词</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85\"><span class=\"toc-text\">开发环境安装</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%88%9D%E5%A7%8B%E6%BA%90%E6%96%87%E4%BB%B6%E8%A7%A3%E9%87%8A\"><span class=\"toc-text\">初始源文件解释</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95\"><span class=\"toc-text\">基础语法</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1\"><span class=\"toc-text\">面向对象</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95\"><span class=\"toc-text\">基本语法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">类的定义和使用</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8%E5%88%86%E5%B8%83\"><span class=\"toc-text\">内存使用分布</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%B1%BB%E4%B8%AD%E5%B1%9E%E6%80%A7%E5%88%9D%E5%A7%8B%E5%8C%96\"><span class=\"toc-text\">类中属性初始化</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0\"><span class=\"toc-text\">可变参数</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%96%B9%E6%B3%95%E4%BC%A0%E5%80%BC%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">方法传值方式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%9D%99%E6%80%81\"><span class=\"toc-text\">静态</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97\"><span class=\"toc-text\">静态代码块</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8C%85\"><span class=\"toc-text\">包</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#import-%E5%AF%BC%E5%85%A5\"><span class=\"toc-text\">import 导入</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">构造方法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BB%A7%E6%89%BF\"><span class=\"toc-text\">继承</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A4%9A%E6%80%81\"><span class=\"toc-text\">多态</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD%E4%B8%8E%E9%87%8D%E5%86%99\"><span class=\"toc-text\">方法重载与重写</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9\"><span class=\"toc-text\">注意事项</span></a></li></ol>","author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"喜欢前沿科技，想要见证人类科学的飞跃","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}},"mapped":true,"prev_post":{"title":"ML notes","uid":"615e3f2233f9034a4c7de4aa41e90c29","slug":"ML-notes","date":"2024-01-07T12:27:41.000Z","updated":"2024-01-07T12:27:41.922Z","comments":true,"path":"api/articles/ML-notes.json","keywords":null,"cover":null,"text":"","link":"","photos":[],"count_time":{"symbolsCount":0,"symbolsTime":"1 mins."},"categories":[],"tags":[],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"喜欢前沿科技，想要见证人类科学的飞跃","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}},"next_post":{"title":"网安notes","uid":"8a327c3785082cab489d4df782f60065","slug":"网安notes","date":"2024-01-02T13:27:36.000Z","updated":"2024-01-03T01:43:54.905Z","comments":true,"path":"api/articles/网安notes.json","keywords":null,"cover":[],"text":"网络安全和密码学的笔记绪论 网络空间安全的CIA三元组：保密性(Confidecial)，完整性(Integrity)，可用性(Available) 后续又有人提出来还需要两个要求（两个A）：真实性(Authenticity)，可审计性(Accountability) 被动攻击：...","link":"","photos":[],"count_time":{"symbolsCount":"2.1k","symbolsTime":"2 mins."},"categories":[{"name":"网络安全和密码学","slug":"网络安全和密码学","count":1,"path":"api/categories/网络安全和密码学.json"}],"tags":[{"name":"学习","slug":"学习","count":42,"path":"api/tags/学习.json"},{"name":"网络安全","slug":"网络安全","count":1,"path":"api/tags/网络安全.json"},{"name":"密码学","slug":"密码学","count":1,"path":"api/tags/密码学.json"},{"name":"期末复习","slug":"期末复习","count":1,"path":"api/tags/期末复习.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"喜欢前沿科技，想要见证人类科学的飞跃","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}}}