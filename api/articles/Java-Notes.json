{"title":"Java Notes","uid":"f0b9b0e433bb738921b4a846a4505450","slug":"Java-Notes","date":"2024-01-07T12:21:49.000Z","updated":"2024-03-05T11:59:39.526Z","comments":true,"path":"api/articles/Java-Notes.json","keywords":null,"cover":"/img/javalogo.png","content":"<h1 id=\"序言\"><a href=\"#序言\" class=\"headerlink\" title=\"序言\"></a>序言</h1><p>因课设需要以及工作需要，不得不得开始学java了。</p>\n<p>以下为作为学习java的整体笔记，包括一切有关java的架构或者已经写好的包。</p>\n<p>java版本采用2021年之后的java17。</p>\n<p>因为本身已经学过C&#x2F;C++了，所以对于java基础的内容仅简单的介绍和记笔记，不作过多的解释。</p>\n<p>缩写解释：</p>\n<p>涉及到的java代码，有部分缩写，下面这张表给出缩写和全拼的对应关系。</p>\n<table>\n<thead>\n<tr>\n<th>缩写</th>\n<th>全拼</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>sout</td>\n<td>System.out.println</td>\n</tr>\n</tbody></table>\n<p><strong>暂时不理解的点：接口</strong></p>\n<h1 id=\"java基础知识\"><a href=\"#java基础知识\" class=\"headerlink\" title=\"java基础知识\"></a>java基础知识</h1><h2 id=\"基本名词\"><a href=\"#基本名词\" class=\"headerlink\" title=\"基本名词\"></a>基本名词</h2><p>首先需要知道的是java代码是在虚拟机上运行的，而不是像C++那样自己本地跑的。所以java中需要引入虚拟机的概念，也就是JVM</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>JVM(Java Virtual Machine): 运行java的虚拟机。</p>\n<p>JDK：JDK开发包，将java代码编译后然后在JVM上运行的一个打包好的工作包。</p>\n<p>JRE：直接使用已经编译好的字节码在JVM上运行的环境，成为JRE。不用过多了解。</p></blockquote>\n<p>具体关系图可以看下图：</p>\n<p><img src=\"/../img/Java/JDKJREJVM.png\" alt=\"关系图\"></p>\n<h2 id=\"开发环境安装\"><a href=\"#开发环境安装\" class=\"headerlink\" title=\"开发环境安装\"></a>开发环境安装</h2><p>安装的是jdk17。</p>\n<p>使用以下cmd命令查看java版本。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">java -version<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>我用的是java version “17.0.6”</p>\n<p>然后装IDEA，也就是装IJ，自己装去。</p>\n<h2 id=\"初始源文件解释\"><a href=\"#初始源文件解释\" class=\"headerlink\" title=\"初始源文件解释\"></a>初始源文件解释</h2><p>运行的代码源文件是在src文件夹下的，代码源文件是新建一个java class文件。</p>\n<p>以上过程就相当于在cpp源文件中创建一个cpp文件，只不过java创建的要是javaclass。<del>（好奇怪啊</del></p>\n<p>如果想在src中创建多个文件夹，然后将源代码文件放进去，需要在src中创建package，然后在package中创建javaclass文件。</p>\n<p>这里package相当于一般的文件夹。<del>（真的好怪啊</del></p>\n<p>package下的源代码文件需要在代码头上标注 <code>package 对应文件名</code></p>\n<p>out文件存放src中源码编译之后的文件，文件扩展名是.class</p>\n<p>观察一下最基本的java代码：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public class Main &#123;\n    public static void main(String[] args) &#123;\n        System.out.println(&quot;Hello world!&quot;);\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>代码中的关键字和C++中的是一个意思。</p>\n<p>这里需要知道的是java中一切以类为基本单位，也就是说一个java文件中有且仅有一个class类，并且这个仅存在的类里面，必须要有一个main函数，作为这个类的起点函数。</p>\n<p>Main类是整个java程序的起点，main函数是类的起点。</p>\n<p>main函数中的参数args和C语言中的一样，是放参数表列的。</p>\n<h2 id=\"基础语法\"><a href=\"#基础语法\" class=\"headerlink\" title=\"基础语法\"></a>基础语法</h2><p>注释：&#x2F;&#x2F;   &#x2F;**&#x2F; 和C++一样</p>\n<p>TODO功能：在重点文字或者内容前面添加TODO关键词，从而使注释凸出显示，同时在下方工具栏中可以重点显示。类似一个todolist的功能。是IDEA提供的功能。</p>\n<p>e.g:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">//114514</span>\n<span class=\"token comment\">// TODO 14514</span>\n<span class=\"token comment\">//141341</span>\n<span class=\"token comment\">//12312</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>Java数据类型：</p>\n<p><img src=\"/../img/Java/dataType.png\" alt=\"img\" title=\"DataTypeInJava\"></p>\n<p>数据定义和C++一样。</p>\n<p>byte：8位</p>\n<p>short：16位</p>\n<p>int：32位</p>\n<p>long：64位</p>\n<p>float：单精度，32位</p>\n<p>double：双精度，64位</p>\n<p>注意到：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">float</span> b <span class=\"token operator\">=</span> <span class=\"token number\">1.0</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//这会报错，因为java中对于1.0这种常量默认认为是双精度的，而double不能复制给float，需要标识1.0的数据类型。</span>\n<span class=\"token keyword\">float</span> b <span class=\"token operator\">=</span> <span class=\"token number\">1.0f</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//如此改正即可。</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>boolean：取值为true or false。和C++一样。</p>\n<p>有关数据转化的问题：</p>\n<p>值域范围大的数据不可以直接复制给值域小的，会直接报错（C++里面不会报错），反之是允许的。</p>\n<p>强制类型转化方法和C++一样，不过只有以下这种形式的。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">int</span> a <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">)</span>b<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">int</span> a <span class=\"token operator\">=</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">(</span>b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//这样是不允许的，java里面没有这种方法。</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>Java中的运算符：</p>\n<p>绝大部分的运算符和C++中的一样。</p>\n<p>&amp;&amp;和||和C++中一样都是短路运算符。</p>\n<p>不过java中的&amp;,|不仅可以用于一般的位运算，还可以用于逻辑运算。</p>\n<p>作为逻辑运算的时候不是短路运算符。&amp;和|操作的两边的操作数，不可以类型不一致。</p>\n<p>e.g</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">boolean</span> <span class=\"token operator\">|</span> <span class=\"token keyword\">int</span>\n<span class=\"token comment\">//这是不允许的。必须要手动的强制类型转化，java不会提供隐式类型转化</span>\n<span class=\"token comment\">//同时按位取反是用~</span>\n<span class=\"token comment\">//逻辑取反是用!</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><em>java中的顺序，循环，分支结构代码操作和c++中一样。</em></p>\n<h1 id=\"面向对象\"><a href=\"#面向对象\" class=\"headerlink\" title=\"面向对象\"></a>面向对象</h1><h2 id=\"基本语法\"><a href=\"#基本语法\" class=\"headerlink\" title=\"基本语法\"></a>基本语法</h2><h3 id=\"类的定义和使用\"><a href=\"#类的定义和使用\" class=\"headerlink\" title=\"类的定义和使用\"></a>类的定义和使用</h3><p>类的定义和使用大部分和C++一样，只不过用类去定义对象的时候，不像c++那样可以直接用，而是用类名，变量名，然后new一个出来。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">ClassName</span> <span class=\"token class-name\">VarName</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ClassName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>用这种方式来构建一个对象，他所对应的类就是ClassName。</p>\n<p>并且类内定义貌似没有public和private的定义， 但实际上好像是有的，存疑。</p>\n<h3 id=\"内存使用分布\"><a href=\"#内存使用分布\" class=\"headerlink\" title=\"内存使用分布\"></a>内存使用分布</h3><p>一共分为三种区域。</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">栈</th>\n<th>用于存放方法和变量的空间</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">堆</td>\n<td>用于存放对象的空间</td>\n</tr>\n<tr>\n<td align=\"center\">元空间</td>\n<td>用于存放类的信息的空间</td>\n</tr>\n</tbody></table>\n<p>其中，堆空间要大于另外两个空间。</p>\n<p><strong>对象的赋值其实是将存放在堆空间的对象的地址赋给变量，所以变量其实是引用了内存中的对象。</strong></p>\n<h3 id=\"类中属性初始化\"><a href=\"#类中属性初始化\" class=\"headerlink\" title=\"类中属性初始化\"></a>类中属性初始化</h3><p>有一种特殊的对象：**空对象(null)**，没有引用的对象，称之为空对象，又称为关键字对象。</p>\n<p>引用类型变量的默认值就是空对象(null)。</p>\n<p>在<strong>类中的变量</strong>在未初始化的时候均会有一个默认值。这个默认值和C++中堆空间定义的变量差不多。<br>引用类型变量默认值是null，也就是空对象，其他的和c++中的一样。</p>\n<p>变量的作用域范围和C++同理。</p>\n<h3 id=\"可变参数\"><a href=\"#可变参数\" class=\"headerlink\" title=\"可变参数\"></a>可变参数</h3><p>当参数表列中，参数数量不确定，但是参数类型都一样的时候，可以使用可变参数。语法如下</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">void</span> <span class=\"token function\">functino</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n\tsystem<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>使用…来修饰数据类型。来表示可变参数，注意，可变参数只能作为所有参数表列的最后一个参数，如果不是，会引起歧义报错。</p>\n<h3 id=\"方法传值方式\"><a href=\"#方法传值方式\" class=\"headerlink\" title=\"方法传值方式\"></a>方法传值方式</h3><p>默认传值方式是复制类型的，也就是C++里面一样，都是值传递。</p>\n<p>并且java中只有值传递，没有指针引用啥的。</p>\n<p>当然碰到引用数据类型的时候，其实就是引用传递，String除外。</p>\n<p>事实上，String是因为他在修改的时候会产生一个新的String。</p>\n<h3 id=\"静态\"><a href=\"#静态\" class=\"headerlink\" title=\"静态\"></a>静态</h3><p>我们把和对象无关，只和类相关的称之为静态。</p>\n<p>只和类相关的属性称之为静态属性。</p>\n<p>只和类相关的方法称之为静态方法。</p>\n<p>静态语法就是在属性或者方法前面添加一个关键字 <code>static</code></p>\n<p>因为静态和对象无关，只和类相关，所以我们可以不创建对象就可访问静态属性或者方法。</p>\n<p>e.g</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token function\">sout</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">MyClass</span><span class=\"token punctuation\">.</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">MyClass</span><span class=\"token punctuation\">.</span><span class=\"token function\">func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">MyClass</span><span class=\"token punctuation\">&#123;</span>\n\t<span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span> a<span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n\t\tsystem<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"111454\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>成员方法可以访问静态属性和静态方法，但是静态方法不可以访问成员属性和成员方法。</p>\n<p>逻辑：静态是类共有的，是在对象创建之前的，成员属性和成员方法是在对象创建之后才产生的，所以才会设置这样的规则。</p>\n<p>By the way,静态的东西是存放在元空间的（也就是存放类的信息的地方。</p>\n<h3 id=\"静态代码块\"><a href=\"#静态代码块\" class=\"headerlink\" title=\"静态代码块\"></a>静态代码块</h3><p>静态代码块的语法如下：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">class</span> myclass<span class=\"token punctuation\">&#123;</span>\n\t<span class=\"token keyword\">static</span> <span class=\"token punctuation\">&#123;</span>\n\t\t<span class=\"token comment\">//静态代码块段</span>\n\t<span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>其实就是在类里面，用static修饰了一块用大括号括起来的代码段，表示静态代码段。</p>\n<p>静态代码段会在该类被加载的时候自动执行。并且只会执行一遍。</p>\n<p>什么叫做类被加载？其实也就是初次调用类的静态方法的时候或者初次new一个该类的对象的时候，类就会被加载，然后静态代码块就会执行。在这之后，类就是已经被加载过了，静态代码块也不会再次执行了。</p>\n<p>所以静态代码块一般用于类中变量的初始化。同时如果有多段静态代码块，那么在类加载的时候，依次执行。</p>\n<p>逻辑：类的静态代码块其实就相当于对象的构造函数。一个是类加载的时候自动执行，一个是对象创建的时候自动执行。</p>\n<p>当然，如果想在创建对象的时候自动跑一段代码，直接加一段代码块即可，即使上面的东西，去掉static修饰词。</p>\n<p>逻辑：本质上还是就是分清类所拥有的东西和对象所拥有的东西。</p>\n<h3 id=\"包\"><a href=\"#包\" class=\"headerlink\" title=\"包\"></a>包</h3><p>存放类的容器，说白了就是个文件夹用来存放java文件，而java代码中都是在类里面的，所以包就是一个存放类的容器。</p>\n<p>基本语法: <code>package 包路径</code> 。如果要涉及子包，使用.来访问子包 <code>package pk_father.pk_child</code>。</p>\n<p>一个源文件中只能package至多一次，可以没有，但是有只能一次。同时为了区分类名，包名一般小写。</p>\n<p>包可以区分不同包内的相同名称的类。使用方法如下：</p>\n<p><code>java.util.Date()</code> Date是java包中的util包中的一个类。</p>\n<p>因此，一般我们在使用类的时候会使用类的全名(包名+类名)</p>\n<h3 id=\"import-导入\"><a href=\"#import-导入\" class=\"headerlink\" title=\"import 导入\"></a>import 导入</h3><p>import 主要用于导入包中的类，从而使得在使用的时候不需要加包地址。（有点像使用名字空间，但本质上又不一样）</p>\n<p>import只能使用在package后，class前。</p>\n<p>import用法如下：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">//导入单个类</span>\n<span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">java<span class=\"token punctuation\">.</span>lang<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">String</span></span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//String就是lang包里面的类名</span>\n\n<span class=\"token comment\">//导入整个包里面的所有类 </span>\n<span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">java<span class=\"token punctuation\">.</span>lang<span class=\"token punctuation\">.</span></span><span class=\"token operator\">*</span></span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//用*通配符来表示导入这个包里面的所有类。</span>\n<span class=\"token comment\">//当然事实上lang这个包是不需要手动导入的，JVM已经帮你干了这个事情了。</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>注意：如果import了不同包中的相同名字的类，还是要用包路径来区别的，为了防止歧义。</p>\n<h3 id=\"构造方法\"><a href=\"#构造方法\" class=\"headerlink\" title=\"构造方法\"></a>构造方法</h3><p>构造方法和C++的构造函数一样的。</p>\n<p>构造方法的运行优先级低于代码块，也就是先代码块都执行完了，才轮到构造方法执行。</p>\n<h3 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h3><p>继承含义和C++中的继承一样。继承父类只能有一个，但是一个父类可以有多个子类。</p>\n<p>继承采用extends语法，使用例子如下：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Parent</span><span class=\"token punctuation\">&#123;</span>\n\n<span class=\"token punctuation\">&#125;</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Child</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Parent</span><span class=\"token punctuation\">&#123;</span>\n\n<span class=\"token punctuation\">&#125;</span>\n<span class=\"token comment\">//如此Child类就继承了Parent中的成员变量和成员方法，当然构造方法是不继承的。</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>当父类和子类中存在名称相同的变量的时候，使用super和this关键词来区分开来，使用方法和C++中类似，不强调的时候默认是this。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">super</span><span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">;</span><span class=\"token comment\">//super表示父类的这个name变量</span>\n<span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">;</span><span class=\"token comment\">//this表示当前类的这个name变量</span>\n<span class=\"token comment\">//也就是说super指的是父类的，this指的是当前类的。</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>创建多个子类的时候，每一个子类创建前都会先构建父类。当然实际上父类对象并不会真的创建，而是调用构造函数之后，将父类参数给子类而已。</p>\n<p>考虑以下这种情况，父类的构造方法需要传参数，但是子类的构造方法不需要传参数：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Parent</span><span class=\"token punctuation\">&#123;</span>\n\t<span class=\"token class-name\">String</span> name<span class=\"token punctuation\">;</span>\n\t<span class=\"token class-name\">Parent</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n\t\tname<span class=\"token operator\">=</span>s<span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Child</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Parent</span><span class=\"token punctuation\">&#123;</span>\n\t<span class=\"token class-name\">Child</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n\t\t<span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"4558\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//使用super来进行父类的含参构造函数的调用。</span>\n\t<span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token comment\">//理解：其实可以将super就理解为父类的类名，从而去理解使用super()来代表父类的构造函数。</span>\n<span class=\"token comment\">//当然一般super是会自动调用的，当父类需要传递参数的时候，才需要自己写。</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>其实就是子类和父类都有构造函数的时候，子类构造函数中需要调用一下父类的构造函数，用super表示他的父类，如果不带参数，那么JVM就帮你做了这个工作了，不需要自己写。</p>\n<h3 id=\"多态\"><a href=\"#多态\" class=\"headerlink\" title=\"多态\"></a>多态</h3><p>多态的含义和C++面向对象的多态意思一样。</p>\n<h3 id=\"方法重载与重写\"><a href=\"#方法重载与重写\" class=\"headerlink\" title=\"方法重载与重写\"></a>方法重载与重写</h3><p>方法重载就是函数重载，和C++一样的。</p>\n<p>方法名一样，但是参数表列不一样，成为方法重载。</p>\n<p>方法重写：指的是子类和父类中都有一个同样名字的，同样参数表列，同样返回值的函数，这个时候相当于子类的这个方法重写了父类的这个方法。</p>\n<p>也就是子类重写了父类的方法，但是并不说明父类方法被覆盖掉了，仍然可以通过使用super方法来使用父类的方法。构造方法是无法重写的<del>（这不废话吗</del></p>\n<h3 id=\"递归\"><a href=\"#递归\" class=\"headerlink\" title=\"递归\"></a>递归</h3><p>递归和C++一致，都是函数调用函数自己，同样也会有爆栈的问题。</p>\n<h3 id=\"访问权限\"><a href=\"#访问权限\" class=\"headerlink\" title=\"访问权限\"></a>访问权限</h3><p>在java的源码中，公共类(public class)只能有一个，而且必须和源码文件名相同。main方法是由JVM调用的，JVM调用的时候应该可以任意调用而不用考虑任何权限问题，所以在公共类的main函数前面需要加上public来进行修饰，以确保JVM调用的时候可以任意调用。main函数前面需要加static修饰，是因为如果不加static，那main函数是一个对象方法，需要构建对象才可以使用，JVM调用的时候无法构建对象，所以需要用static修饰，使之成为类方法，不构建对象也可以使用main方法。</p>\n<p>推理：程序开始的两个函数，一个需要和文件名保持一致，同时是整个源码文件中的唯一公共类，这可能是因为java中的万物皆对象的思想，同时唯一公共类也是作为了该文件的程序入口。而main函数就作为了唯一公共类的程序入口，使用public和static修饰是为了JVM能够不用考虑任何权限或者其他问题的来调用main函数来运行。</p>\n<p>Java中的访问权限一共分为四种：private,public,protected,(default)</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">访问权限</th>\n<th align=\"center\">具体内容</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">private</td>\n<td align=\"center\">私有，只有本类可以只用</td>\n</tr>\n<tr>\n<td align=\"center\">public</td>\n<td align=\"center\">公用，全都可以任意使用</td>\n</tr>\n<tr>\n<td align=\"center\">protected</td>\n<td align=\"center\">受保护的，本类和子类都可以使用</td>\n</tr>\n<tr>\n<td align=\"center\">(default)</td>\n<td align=\"center\">缺省默认为default，在本包范围内可以随意使用，但子包是不能访问的</td>\n</tr>\n</tbody></table>\n<h3 id=\"内部类\"><a href=\"#内部类\" class=\"headerlink\" title=\"内部类\"></a>内部类</h3><p>外部类：源码中直接声明的类。</p>\n<p>内部类：类中定义的类。</p>\n<p>规定：Java不允许外部类使用private和protected修饰，也就是说只允许public和(default)修饰。</p>\n<p>想要创建一个内部类的对象，需要先创建他外部类的对象，然后再创建内部类的对象，写法上如下：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Main</span><span class=\"token punctuation\">&#123;</span>\n  <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">class</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>string<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n    myclass obj <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token function\">myclass</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">//然后用obj去创建内部类的对象</span>\n    myclass<span class=\"token punctuation\">.</span>childclass obj_child <span class=\"token operator\">=</span> obj<span class=\"token punctuation\">.</span><span class=\"token keyword\">new</span> <span class=\"token function\">childclass</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span>\n<span class=\"token keyword\">class</span> myclass<span class=\"token punctuation\">&#123;</span>\n  <span class=\"token keyword\">class</span> childclass<span class=\"token punctuation\">&#123;</span>\n    \n  <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"单例模式\"><a href=\"#单例模式\" class=\"headerlink\" title=\"单例模式\"></a>单例模式</h3><p><strong>有套路的java代码编写方式称为代码的设计模式</strong>。单例模式就是其中一种。单例模式指通过一些编写方法，使的创建对象的时候永远只会创建一个，如果已经创建过对象，那么再new出来的会是之前创建的对象。一般方法如下：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">class</span> myclass<span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> myclass isNew <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">private</span> <span class=\"token function\">myclass</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n\n    <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> myclass <span class=\"token function\">getInstance</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>isNew<span class=\"token operator\">==</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n            isNew <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token function\">myclass</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n        <span class=\"token keyword\">return</span> isNew<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span> \n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"final\"><a href=\"#final\" class=\"headerlink\" title=\"final\"></a>final</h3><p>final类似C++中的const</p>\n<p>final修饰方法的时候，子类不能重写父类的方法，不可以修饰构造方法。</p>\n<p>final修饰类的时候，该类就没有子类了</p>\n<h3 id=\"抽象\"><a href=\"#抽象\" class=\"headerlink\" title=\"抽象\"></a>抽象</h3><p>抽象概念和C++面向对象一样。</p>\n<p>抽象方法：只有声明，没有实现的方法。</p>\n<p>抽象类：不完整的类就是抽象类。</p>\n<p>需要使用到关键字abstract，如下：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">//抽象类</span>\n<span class=\"token keyword\">abstract</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">A</span><span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">abstract</span> <span class=\"token keyword\">void</span> <span class=\"token function\">eat</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//抽象方法</span>\n    <span class=\"token comment\">//此类中有抽象方法，所以他只能是抽象类</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"接口\"><a href=\"#接口\" class=\"headerlink\" title=\"接口\"></a>接口</h3><p>Java中接口使用interface关键词来声明。使用方法如下：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">interface</span> <span class=\"token class-name\">Name</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token comment\">//规则属性或者方法</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>接口其实是抽象的，但是其中的规则属性和方法是具体的。</p>\n<p>接口可以理解为一些规则的集合，也可以理解为抽象的类。</p>\n<p>使用示例如下：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">//写了三个接口其中USB供能和接受继承自USB接口，Computer实现USBSupply接口。使用的是implements关键词。</span>\n<span class=\"token keyword\">interface</span> <span class=\"token class-name\">USBInterface</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n    \n<span class=\"token punctuation\">&#125;</span>\n<span class=\"token keyword\">interface</span> <span class=\"token class-name\">USBSupply</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">powerSupply</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n<span class=\"token keyword\">interface</span> <span class=\"token class-name\">USBReceive</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">powerReceive</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Computer</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">USBSupply</span> <span class=\"token punctuation\">&#123;</span>\n  \t<span class=\"token keyword\">public</span> <span class=\"token class-name\">USBReceive</span> usb1<span class=\"token punctuation\">;</span>\n  \t<span class=\"token keyword\">public</span> <span class=\"token class-name\">USBReceive</span> usb2<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">powerSupply</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n        <span class=\"token function\">sout</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"114514\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      \tusb1<span class=\"token punctuation\">.</span><span class=\"token function\">powerReceive</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      \tusb2<span class=\"token punctuation\">.</span><span class=\"token function\">powerReceive</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"枚举\"><a href=\"#枚举\" class=\"headerlink\" title=\"枚举\"></a>枚举</h3><p>枚举是一个特殊的类，其中包含了一组特定的对象，这些对象不会发生改变。使用<code>enum</code>关键词使用。</p>\n<p>枚举会将他其中的对象放在最前面。以下为例：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">enum</span> <span class=\"token class-name\">City</span><span class=\"token punctuation\">&#123;</span>\n    <span class=\"token function\">BEIJING</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"BEIJING\"</span><span class=\"token punctuation\">,</span><span class=\"token number\">1001</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span><span class=\"token function\">SHANGHAI</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"shanghai\"</span><span class=\"token punctuation\">,</span><span class=\"token number\">10002</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  \t<span class=\"token class-name\">City</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> name<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> code<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n        <span class=\"token class-name\"><span class=\"token namespace\">this<span class=\"token punctuation\">.</span></span>Name</span><span class=\"token operator\">=</span>name<span class=\"token punctuation\">;</span>\n      \t<span class=\"token class-name\"><span class=\"token namespace\">this<span class=\"token punctuation\">.</span></span>Code</span><span class=\"token operator\">=</span>code<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n  <span class=\"token class-name\">String</span> <span class=\"token class-name\">Name</span><span class=\"token punctuation\">;</span>\n  <span class=\"token class-name\">String</span> <span class=\"token class-name\">Code</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>从例子中可以看到，BEIJING和SHANGHAI是这个枚举类中的对象，这些对象所对应的类就是City。（感觉还挺抽象的）</p>\n<h3 id=\"匿名类\"><a href=\"#匿名类\" class=\"headerlink\" title=\"匿名类\"></a>匿名类</h3><p>在某些场合下，类的名字不重要，我们只需要使用类的方法或功能，此时就可以采用特殊的语法：匿名类。所谓的匿名类，就是没有名字的类。用法如下：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Main</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token class-name\">Person</span> person <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Person</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n            <span class=\"token keyword\">public</span> <span class=\"token class-name\">String</span> <span class=\"token function\">name</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n                <span class=\"token keyword\">return</span> <span class=\"token string\">\"Jack\"</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">&#125;</span>\n        <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token keyword\">abstract</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Person</span><span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">abstract</span> <span class=\"token class-name\">String</span> <span class=\"token function\">name</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>抽象类是不能new一个出来的，但是如果new抽象类之后，在之后又加上{}并且重写了抽象方法， 那么相当于这个抽象类已经具体化，从而可以创建对象，但是像这种具体化的抽象类又没有名字，所以叫匿名类。</p>\n<h3 id=\"bean规范\"><a href=\"#bean规范\" class=\"headerlink\" title=\"bean规范\"></a>bean规范</h3><p>Bean类的设计规范：bean规范。</p>\n<ol>\n<li>类要求必须含有无参的公共的构造方法，</li>\n<li>属性私有化，提供公共的set和get方法，</li>\n</ol>\n<h2 id=\"常见类和对象\"><a href=\"#常见类和对象\" class=\"headerlink\" title=\"常见类和对象\"></a>常见类和对象</h2><h3 id=\"Object\"><a href=\"#Object\" class=\"headerlink\" title=\"Object\"></a>Object</h3><p>Object是Java中的默认的类的父类，也就是说，所有没有明确父类的类都是以Object为父类的。Object也一般被称为超类。以下为Object中的常见方法（因为Object是所有类的父类或者间接父类，所以Object中的方法，在所有类中都可以使用。）：</p>\n<ol>\n<li>toString() 方法：将对象转化为字符串。默认打印对象的内存地址，可以自己重写。return String</li>\n<li>hashCode()方法：获取对象的对应hash值，一般用于判断是否相等。return 十进制数字。</li>\n<li>equals()方法：判断两个对象是否相等。默认比较标准是比较<strong>内存地址</strong>，可以自己重写。return Boolean</li>\n<li>getClass()方法：获取对象的类型信息。return class&lt;?&gt; 具体查java手册。</li>\n</ol>\n<h3 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h3><p>声明方式：类型[] 变量名; <code>String[] names</code></p>\n<p>创建方式：类似类的创建。<code>String[] names = new String[SIZE]</code>这里SIZE是数组的大小，需要提前指定，可以是变量值。</p>\n<h3 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h3><p>Java中使用ASCII码表示的字符是使用一个字节来表示的，除了ASCII码之外都是用三个字节来表示字符的。</p>\n<p>常用操作：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">方法</th>\n<th align=\"center\">作用</th>\n<th align=\"center\">备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">concat(String)</td>\n<td align=\"center\">拼接(concatenate)</td>\n<td align=\"center\">使用+字符串的时候，如果一边不是字符串，另外一边是<strong>字符串</strong>，那么非字符串会自动转化为字符串。</td>\n</tr>\n<tr>\n<td align=\"center\">equals(String)</td>\n<td align=\"center\">比较</td>\n<td align=\"center\">两个字符串只有每一位对应的字符相同才相同</td>\n</tr>\n<tr>\n<td align=\"center\">equalsIgnoreCase(String)</td>\n<td align=\"center\">比较（忽略大小写）</td>\n<td align=\"center\">每一位比较忽略大小写的区别</td>\n</tr>\n<tr>\n<td align=\"center\">compareTo(String)</td>\n<td align=\"center\">比较大小</td>\n<td align=\"center\">返回为正，说明调用函数的string大于被比较的string。a.compareTo(b)&gt;0说明a大于b，反之小于。为零则相等。</td>\n</tr>\n<tr>\n<td align=\"center\">substring(beginIndex,endIndex)</td>\n<td align=\"center\">截取子串</td>\n<td align=\"center\">范围左闭右开</td>\n</tr>\n<tr>\n<td align=\"center\">substring(beginIndex)</td>\n<td align=\"center\">截取子串</td>\n<td align=\"center\">从beginIndex开始截取子串到最后</td>\n</tr>\n<tr>\n<td align=\"center\">split(regx)</td>\n<td align=\"center\">分解字符串</td>\n<td align=\"center\">根据regx参数位置给的参数，将源字符串分开，返回string数组</td>\n</tr>\n<tr>\n<td align=\"center\">trim()</td>\n<td align=\"center\">去掉首尾空格</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">replace(target,replacement)</td>\n<td align=\"center\">替换内容</td>\n<td align=\"center\">将所有“target”中的内容替换成replacement中的内容</td>\n</tr>\n<tr>\n<td align=\"center\">replaceAll(regx,replacement)</td>\n<td align=\"center\">替换内容</td>\n<td align=\"center\">相较于replace单一关键词内容替换，replaceall可以实现多关键词内容替换，不同关键词之间使用|分开。replaceAll(“World|113|eafsji”,”Java”)</td>\n</tr>\n<tr>\n<td align=\"center\">toLowerCase()</td>\n<td align=\"center\">内容全部小写化</td>\n<td align=\"center\">toUpperCase()同理全变大写</td>\n</tr>\n<tr>\n<td align=\"center\">toCharArray()</td>\n<td align=\"center\">string转化为char数组</td>\n<td align=\"center\">返回char数组</td>\n</tr>\n<tr>\n<td align=\"center\">getBytes(charsetName)</td>\n<td align=\"center\">string转化为字节码数组</td>\n<td align=\"center\">返回byte数组,charsetName一般是UTF-8</td>\n</tr>\n<tr>\n<td align=\"center\">charAt(index)</td>\n<td align=\"center\">查询第index位的字符</td>\n<td align=\"center\">返回char。提供这个方法的原因是String不能像数组那样使用[]访问。</td>\n</tr>\n<tr>\n<td align=\"center\">indexOf(String)</td>\n<td align=\"center\">查询子串在源串中的位置</td>\n<td align=\"center\">返回index，返回的是第一次出现的位置。lastIndexOf(String)返回的是最后一次出现的位置。</td>\n</tr>\n<tr>\n<td align=\"center\">contains(String)</td>\n<td align=\"center\">是否包含指定字符串</td>\n<td align=\"center\">返回值为Boolean</td>\n</tr>\n<tr>\n<td align=\"center\">startsWith(String)</td>\n<td align=\"center\">是否以指定字符串开头</td>\n<td align=\"center\">返回值为Boolean</td>\n</tr>\n<tr>\n<td align=\"center\">endsWith(String)</td>\n<td align=\"center\">是否以指定字符串结尾</td>\n<td align=\"center\">返回值为Boolean</td>\n</tr>\n<tr>\n<td align=\"center\">isEmpty()</td>\n<td align=\"center\">是否为空</td>\n<td align=\"center\">空为true，反之为false</td>\n</tr>\n</tbody></table>\n<p><strong>StringBuilder</strong></p>\n<p>Java中提供的一个比String更加好用的类，使用方法需要自己new一个Stringbuilder出来。<code>StringbBuilder s = new StringBuilder();</code> 然后对于s可以使用各种操作对其进行增删改查。比如append,toString,length,reverse,insert。并且他的拼接字符串操作不同于String，他不会频繁创建对象，所以操作代价上会比String要小。</p>\n<h3 id=\"包装类\"><a href=\"#包装类\" class=\"headerlink\" title=\"包装类\"></a>包装类</h3><p>在基本数据类型的基础上进行包装操作的类，从而使得数据操作起来更加方便，这种类成为包装类。基本数据类型和包装类的对应关系如下所示：</p>\n<p>byte -&gt; Byte    short -&gt;Short     int-&gt;Integer</p>\n<p>long-&gt;Long     float-&gt;Float       double-&gt;Double</p>\n<p>char-&gt;Character   boolean-&gt;Boolean</p>\n<p>包装类的使用以Integer为例。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">//将基本数据类型转化为包装类</span>\n<span class=\"token class-name\">Integer</span> ii <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Integer</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//现在已经不推荐了</span>\n<span class=\"token class-name\">Integer</span> ii <span class=\"token operator\">=</span> <span class=\"token class-name\">Integer</span><span class=\"token punctuation\">.</span><span class=\"token function\">valueOf</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//静态转换</span>\n<span class=\"token class-name\">Integer</span> ii <span class=\"token operator\">=</span> i<span class=\"token punctuation\">;</span> <span class=\"token comment\">//直接复制，本质上就是上面那个东西，JVM帮你做了这个工作而已。称为自动装箱</span>\n<span class=\"token comment\">//包装类转化为基本数据类型</span>\n<span class=\"token keyword\">int</span> i2<span class=\"token operator\">=</span>ii<span class=\"token punctuation\">.</span><span class=\"token function\">intValue</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//其他数据类型函数同理，shortValue等等</span>\n<span class=\"token keyword\">int</span> i2<span class=\"token operator\">=</span>ii<span class=\"token punctuation\">;</span><span class=\"token comment\">//也可以这样，称为自动拆箱</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"日期类\"><a href=\"#日期类\" class=\"headerlink\" title=\"日期类\"></a>日期类</h3><p>日期类Date。使用Date创建一个对象，直接sout就可以看到当前日期。可以使用SimpleDateFormat类来格式化日期的对象。Java格式化日期格式：</p>\n<h3 id=\"日历类\"><a href=\"#日历类\" class=\"headerlink\" title=\"日历类\"></a>日历类</h3><p>日历类Calendar。</p>\n<h1 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h1><p>[1] java中的类在用一个对象赋值给另外一个对象的时候，都是引用赋值，也就相当于用的是C++里面的&amp;，比如对象B赋值给对象C，C修改内容的时候，你输出B，B里面的内容也会被修改，原理看java基础知识，变量的原理。这里只有String是例外，不遵循这套原则。</p>\n<p>[2]</p>\n","text":"序言因课设需要以及工作需要，不得不得开始学java了。 以下为作为学习java的整体笔记，包括一切有关java的架构或者已经写好的包。 java版本采用2021年之后的java17。 因为本身已经学过C&#x2F;C++了，所以对于java基础的内容仅简单的介绍和记笔记，不作过多...","link":"","photos":[],"count_time":{"symbolsCount":"11k","symbolsTime":"10 mins."},"categories":[{"name":"Java","slug":"Java","count":1,"path":"api/categories/Java.json"}],"tags":[{"name":"Java","slug":"Java","count":1,"path":"api/tags/Java.json"},{"name":"language","slug":"language","count":1,"path":"api/tags/language.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%BA%8F%E8%A8%80\"><span class=\"toc-text\">序言</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86\"><span class=\"toc-text\">java基础知识</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E6%9C%AC%E5%90%8D%E8%AF%8D\"><span class=\"toc-text\">基本名词</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85\"><span class=\"toc-text\">开发环境安装</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%88%9D%E5%A7%8B%E6%BA%90%E6%96%87%E4%BB%B6%E8%A7%A3%E9%87%8A\"><span class=\"toc-text\">初始源文件解释</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95\"><span class=\"toc-text\">基础语法</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1\"><span class=\"toc-text\">面向对象</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95\"><span class=\"toc-text\">基本语法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">类的定义和使用</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8%E5%88%86%E5%B8%83\"><span class=\"toc-text\">内存使用分布</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%B1%BB%E4%B8%AD%E5%B1%9E%E6%80%A7%E5%88%9D%E5%A7%8B%E5%8C%96\"><span class=\"toc-text\">类中属性初始化</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0\"><span class=\"toc-text\">可变参数</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%96%B9%E6%B3%95%E4%BC%A0%E5%80%BC%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">方法传值方式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%9D%99%E6%80%81\"><span class=\"toc-text\">静态</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97\"><span class=\"toc-text\">静态代码块</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8C%85\"><span class=\"toc-text\">包</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#import-%E5%AF%BC%E5%85%A5\"><span class=\"toc-text\">import 导入</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">构造方法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BB%A7%E6%89%BF\"><span class=\"toc-text\">继承</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A4%9A%E6%80%81\"><span class=\"toc-text\">多态</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD%E4%B8%8E%E9%87%8D%E5%86%99\"><span class=\"toc-text\">方法重载与重写</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%80%92%E5%BD%92\"><span class=\"toc-text\">递归</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90\"><span class=\"toc-text\">访问权限</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%86%85%E9%83%A8%E7%B1%BB\"><span class=\"toc-text\">内部类</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">单例模式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#final\"><span class=\"toc-text\">final</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%8A%BD%E8%B1%A1\"><span class=\"toc-text\">抽象</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%8E%A5%E5%8F%A3\"><span class=\"toc-text\">接口</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9E%9A%E4%B8%BE\"><span class=\"toc-text\">枚举</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8C%BF%E5%90%8D%E7%B1%BB\"><span class=\"toc-text\">匿名类</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#bean%E8%A7%84%E8%8C%83\"><span class=\"toc-text\">bean规范</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%B8%B8%E8%A7%81%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1\"><span class=\"toc-text\">常见类和对象</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Object\"><span class=\"toc-text\">Object</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%95%B0%E7%BB%84\"><span class=\"toc-text\">数组</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AD%97%E7%AC%A6%E4%B8%B2\"><span class=\"toc-text\">字符串</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8C%85%E8%A3%85%E7%B1%BB\"><span class=\"toc-text\">包装类</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%97%A5%E6%9C%9F%E7%B1%BB\"><span class=\"toc-text\">日期类</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%97%A5%E5%8E%86%E7%B1%BB\"><span class=\"toc-text\">日历类</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9\"><span class=\"toc-text\">注意事项</span></a></li></ol>","author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"喜欢前沿科技，想要见证人类科学的飞跃","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}},"mapped":true,"prev_post":{"title":"ML notes","uid":"615e3f2233f9034a4c7de4aa41e90c29","slug":"ML-notes","date":"2024-01-07T12:27:41.000Z","updated":"2024-02-24T09:52:36.121Z","comments":true,"path":"api/articles/ML-notes.json","keywords":null,"cover":"/img/machine_learning.jpg","text":"前言ML教材为《机器学习_周志华》 第一章PAC理论模型PAC(Probably Approximately Correct 概率近似正确) learning model由Leslie Valiant提出。 $$\\begin{aligned}P(|f(x)-y|\\le \\epsi...","link":"","photos":[],"count_time":{"symbolsCount":762,"symbolsTime":"1 mins."},"categories":[{"name":"AI","slug":"AI","count":1,"path":"api/categories/AI.json"}],"tags":[{"name":"Python","slug":"Python","count":2,"path":"api/tags/Python.json"},{"name":"ML","slug":"ML","count":1,"path":"api/tags/ML.json"},{"name":"AI","slug":"AI","count":1,"path":"api/tags/AI.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"喜欢前沿科技，想要见证人类科学的飞跃","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}},"next_post":{"title":"网安notes","uid":"8a327c3785082cab489d4df782f60065","slug":"网安notes","date":"2024-01-02T13:27:36.000Z","updated":"2024-01-03T01:43:54.905Z","comments":true,"path":"api/articles/网安notes.json","keywords":null,"cover":[],"text":"网络安全和密码学的笔记绪论 网络空间安全的CIA三元组：保密性(Confidecial)，完整性(Integrity)，可用性(Available) 后续又有人提出来还需要两个要求（两个A）：真实性(Authenticity)，可审计性(Accountability) 被动攻击：...","link":"","photos":[],"count_time":{"symbolsCount":"2.1k","symbolsTime":"2 mins."},"categories":[{"name":"网络安全和密码学","slug":"网络安全和密码学","count":1,"path":"api/categories/网络安全和密码学.json"}],"tags":[{"name":"学习","slug":"学习","count":42,"path":"api/tags/学习.json"},{"name":"网络安全","slug":"网络安全","count":1,"path":"api/tags/网络安全.json"},{"name":"密码学","slug":"密码学","count":1,"path":"api/tags/密码学.json"},{"name":"期末复习","slug":"期末复习","count":1,"path":"api/tags/期末复习.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"喜欢前沿科技，想要见证人类科学的飞跃","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}}}