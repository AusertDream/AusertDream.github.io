{"title":"ACM学习笔记day32 (数字三角形，最长上升子序列)","uid":"0c3e2aa6872231e13fd503f7a08ea40b","slug":"ACM学习笔记day32","date":"2023-02-20T14:18:20.000Z","updated":"2023-04-08T10:53:21.330Z","comments":true,"path":"api/articles/ACM学习笔记day32.json","keywords":null,"cover":"/img/codeforces.jpg","content":"<p>今天的内容是数字三角形，和最长上升子序列。<br>其中最长上升子序列可以说是dp问题里面非常经典的问题了。</p>\n<span id=\"more\"></span>\n\n\n<h1 id=\"数字三角形\"><a href=\"#数字三角形\" class=\"headerlink\" title=\"数字三角形\"></a><a href=\"https://www.acwing.com/problem/content/900/\">数字三角形</a></h1><p>对于这个题，我们的dp思路其实很简单。<br>当然在此之前，我们需要定义一下这个三角形的行和列。<br>给的三角形是这样的:</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">       7\n      3   8\n    8   1   0\n  2   7   4   4\n4   5   2   6   5</code></pre>\n\n<p>我们稍微移动一下位置，使得他便于在数组中存储</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">7\n3   8\n8   1   0\n2   7   4   4\n4   5   2   6   5</code></pre>\n<p>变成这样之后也是一个三角形的。<br>事实上，我们所定义的行是一般意义上的行，但是列，是从右上角到左下角的一个列叫列。<br>那么我们稍微排一下其实就是这样子的。</p>\n<p>那么我们的DP思路其实就是。<br>对于第i行，第j列的数字，我们从顶部下来到这个位置，sum最大的值。<br>而最终我们要得到答案，就是取我们dp数组最后一行中最大第一个值就是了。<br>那么dp[i][j]应该怎么求呢？<br>我们发现，要到第i行第j列，来源只有两个地方，第i-1行第j-1列，第i-1行第j列。那么我们对于这两个来源。<br>取一个大的就可以了，然后再加上a[i][j]的值就可以了。<br>即状态转移方程为：</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>dp[i][j]&#x3D;max(dp[i-1][j-1],dp[i-1][j])+a[i][j];</p></blockquote>\n<p>当然如果此时这个位置在最左边或者最右边，上一层只有一条路可以过来，所以不用判断，直接赋值就可以了。<br>这是一种需要特判的情况。</p>\n<p>ac code:</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nconst int N &#x3D; 510, M &#x3D; 1e4+10;\nconst int INF &#x3D; 0x3f3f3f3f;\nint a[N][M];\nint f[N][M];\n\nint main()&#123;\n    int n;\n    cin&gt;&gt;n;\n    for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;\n        for(int j&#x3D;0;j&lt;i;j++)&#123;\n            cin&gt;&gt;a[i][j];\n        &#125;\n    &#125;\n    for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;\n        for(int j&#x3D;0;j&lt;i;j++)&#123;\n            if(j&#x3D;&#x3D;0)&#123;\n                f[i][j]&#x3D;f[i-1][j]+a[i][j];\n            &#125;\n            else if(j&#x3D;&#x3D;i-1)&#123;\n                f[i][j]&#x3D;f[i-1][j-1]+a[i][j];\n            &#125;\n            else&#123;\n                f[i][j]&#x3D;max(f[i-1][j]+a[i][j],f[i-1][j-1]+a[i][j]);\n            &#125;\n        &#125;\n    &#125;\n    int ans&#x3D;-INF;\n    for(int i&#x3D;0;i&lt;n;i++)&#123;\n        ans&#x3D;max(ans,f[n][i]);\n    &#125;\n    cout&lt;&lt;ans&lt;&lt;endl;\n    \n    \n    \n    return 0;\n&#125;</code></pre>\n\n\n<h1 id=\"最长上升子序列\"><a href=\"#最长上升子序列\" class=\"headerlink\" title=\"最长上升子序列\"></a><a href=\"https://www.acwing.com/problem/content/897/\">最长上升子序列</a></h1><p>这是一个非常经典的问题了。<br>我们为了求出最终的最长上升子序列的长度。<br>运用dp的方法是从头到尾的递推过去。<br>我们定义dp[i]为以a[i]为结尾的一个子序列他的最大上升子序列是多长。<br>当到dp[i]的时候，我们看看他可以作为哪一个子序列的后缀。<br>也就是从dp[0]到dp[i-1]中找，加上这个数字之后，哪个的长度最长。<br>那么我们就容易得出，这是一个双重循环。<br>状态转移方程就是</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>dp[i]&#x3D;max(dp[0]+1,dp[1]+1,…..dp[i-1]+1);</p></blockquote>\n<p>当然这里有一个前提，就是a[i]的值要大于前面子序列的末尾的值。<br>不然不满足条件了。</p>\n<p>这个算法的时间复杂度是$O(n^2)$</p>\n<p>ac code:</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\n\n\nint main()&#123;\n    int n;\n    cin&gt;&gt;n;\n    vector&lt;int&gt; a(n);\n    for(int i&#x3D;0;i&lt;n;i++)&#123;\n        cin&gt;&gt;a[i];\n    &#125;\n    vector&lt;int&gt; f(n);\n    f[0]&#x3D;1;\n    for(int i&#x3D;0;i&lt;n;i++)&#123;\n        f[i]&#x3D;1;\n        for(int j&#x3D;0;j&lt;i;j++)&#123;\n            if(a[j]&lt;a[i])&#123;\n                f[i]&#x3D;max(f[i],f[j]+1);\n            &#125;\n        &#125;\n    &#125;\n    int res&#x3D;0;\n    for(int i&#x3D;0;i&lt;n;i++)&#123;\n        res&#x3D;max(res,f[i]);\n    &#125;\n    cout&lt;&lt;res&lt;&lt;endl;\n    return 0;\n&#125;</code></pre>\n\n<p>接下来是这题的一种优化做法，因为n方的复杂度还是比较高的。<br><a href=\"https://www.acwing.com/problem/content/898/\">题目连接</a></p>\n<p>优化做法下，我们将时间复杂度控制在了$O(nlogn)$下。<br>我们再回过去看一下前面的朴素dp做法，看看哪里可以优化的。<br>我们发现，从头遍历到尾，这里似乎优化不了。<br>那么就只能对内层循环动手脚了。<br>这里我们需要额外开一个数组，来记录一个信息。<br>就是当我们迭代到第i位的时候。<br>前面长度为1的，长度为2的，3的….长度为目前能得到的上升子序列他的最后一个最小的数字是多少？</p>\n<p>比如说:<br>长度为1的上升子序列，最后一个数字最小的是1<br>长度为2的上升子序列，最后一个数字最小的是2<br>长度为3的上升子序列，最后一个数字最小的是3<br>长度为4的上升子序列，最后一个数字最小的是4<br>长度为5的上升子序列，最后一个数字最小的是5<br>.<br>.<br>.</p>\n<p>当然这里这个数字的值一定是递增的。<br>具体证明可以用反证法。<br>假设有一个不是递增的。<br>这里就不多说明了。</p>\n<p>那么我们得到了这个数组之后，我们再来看ai，我们发现，可以使用二分来查找我们这个ai可以放在哪里。<br>同时使得子序列的长度最大。<br>那么这样，我们就解决了这个问题，在nlogn的时间内。</p>\n<p>ac code:</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\n\nint main()&#123;\n    int n;\n    cin&gt;&gt;n;\n    int len&#x3D;0;\n    vector&lt;int&gt; a(n);\n    vector&lt;int&gt; q(n);\n    for(int i&#x3D;0;i&lt;n;i++)&#123;\n        cin&gt;&gt;a[i];\n    &#125;\n    q[0]&#x3D;-2e9;\n    for(int i&#x3D;0;i&lt;n;i++)&#123;\n        int l&#x3D;0,r&#x3D;len;\n        while(l&lt;r)&#123;\n            int mid&#x3D;l+r+1&gt;&gt;1;\n            if(q[mid]&lt;a[i])&#123;\n                l&#x3D;mid;\n            &#125;\n            else&#123;\n                r&#x3D;mid-1;\n            &#125;\n        &#125;\n        len&#x3D;max(len,r+1);\n        q[r+1]&#x3D;a[i];\n    &#125;\n    cout&lt;&lt;len&lt;&lt;endl;\n    return 0;\n&#125;</code></pre>\n\n<p>OK，这就是全部的内容了。<br>qwq</p>\n","text":"今天的内容是数字三角形，和最长上升子序列。其中最长上升子序列可以说是dp问题里面非常经典的问题了。 数字三角形对于这个题，我们的dp思路其实很简单。当然在此之前，我们需要定义一下这个三角形的行和列。给的三角形是这样的: 7 3 8 8 1 0 2 7 4 4 4 5 2 6 5 ...","link":"","photos":[],"count_time":{"symbolsCount":"3.8k","symbolsTime":"3 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":39,"path":"api/tags/ACM.json"},{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"学习","slug":"学习","count":43,"path":"api/tags/学习.json"},{"name":"DP","slug":"DP","count":5,"path":"api/tags/DP.json"},{"name":"动态规划","slug":"动态规划","count":5,"path":"api/tags/动态规划.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%95%B0%E5%AD%97%E4%B8%89%E8%A7%92%E5%BD%A2\"><span class=\"toc-text\">数字三角形</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97\"><span class=\"toc-text\">最长上升子序列</span></a></li></ol>","author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"tech otakus save the world","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}},"mapped":true,"prev_post":{"title":"Python学习日志day1","uid":"9440b99fb66535a63cc60a8f05ed5e66","slug":"Python学习日志day1","date":"2023-02-23T05:38:44.000Z","updated":"2024-12-29T15:41:00.233Z","comments":true,"path":"api/articles/Python学习日志day1.json","keywords":null,"cover":"/img/Python.jpg","text":"emm，因为导师要求，所以需要学习一下py，同时可能要为数据库的课设作语言准备，所以就另外开了这样的一个日志。 不过虽说是学习日志，这里我也基本上只会放一些容易忘记的函数啥的。 不会有其他的东西了。qwq 关于字符串 字符串.title()这个函数可以使得字符串里面每一个单词的首...","link":"","photos":[],"count_time":{"symbolsCount":986,"symbolsTime":"1 mins."},"categories":[{"name":"Python","slug":"Python","count":4,"path":"api/categories/Python.json"}],"tags":[{"name":"学习","slug":"学习","count":43,"path":"api/tags/学习.json"},{"name":"python","slug":"python","count":3,"path":"api/tags/python.json"},{"name":"语言","slug":"语言","count":3,"path":"api/tags/语言.json"},{"name":"基础","slug":"基础","count":3,"path":"api/tags/基础.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"tech otakus save the world","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}},"next_post":{"title":"ACM学习笔记day31 (多重背包(二进制优化)，分组背包)","uid":"c4215acd2eabdb6df78cd852601c9d9a","slug":"ACM学习笔记day31","date":"2023-02-18T08:34:37.000Z","updated":"2023-04-08T10:53:14.362Z","comments":true,"path":"api/articles/ACM学习笔记day31.json","keywords":null,"cover":"/img/codeforces.jpg","text":"今天的内容是多重背包的二进制优化解法和分组背包。 一开始听多重背包的二进制优化的时候还是蛮难的， 后来知道一个关键点之后就容易了。至于分组背包，其实和多重背包差不多的，只不过选择上稍微变了点。 多重背包（二进制优化）关于多重背包的一个二进制优化。我们原来的朴素做法就是，枚举第i个...","link":"","photos":[],"count_time":{"symbolsCount":"2.6k","symbolsTime":"2 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"学习","slug":"学习","count":43,"path":"api/tags/学习.json"},{"name":"DP","slug":"DP","count":5,"path":"api/tags/DP.json"},{"name":"动态规划","slug":"动态规划","count":5,"path":"api/tags/动态规划.json"},{"name":"背包问题","slug":"背包问题","count":1,"path":"api/tags/背包问题.json"},{"name":"背包","slug":"背包","count":1,"path":"api/tags/背包.json"},{"name":"多重背包","slug":"多重背包","count":1,"path":"api/tags/多重背包.json"},{"name":"分组背包","slug":"分组背包","count":1,"path":"api/tags/分组背包.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"tech otakus save the world","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}}}