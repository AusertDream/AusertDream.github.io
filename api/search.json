[{"id":"bf5e45ddd75ae274164ba73bf6dc58dd","title":"DeepLearning-Note","content":" \n    window.MathJax = { tex: { inlineMath: [['$', '$'], ['\\\\(', '\\\\)']], }}; \n\n\n\nChapter1&amp;2  Introduction&amp;Pre-Knowledge张量的概念——由数值组成的数组，可以有多个维度。\n\ntorch.arange(x)–生成一个0-x的一维张量，左开右闭。\nreshape和shape和numpy中的一样。\ntorch.numel()返回张量中元素的数量，始终为标量。\ntorch.tensor(List)方法可以使得直接用列表赋值，产生一个对应的张量。\n张量可以作＋－×&#x2F; ** 求幂 这些运算，运算均对每一个元素进行。\ntorch.cat((X, Y), dim&#x3D;0) 通过cat方法可以将两个张量拼接起来，dim指定合并在第几维，比如dim&#x3D;0，在第0维合并，也就是按行合并，dim&#x3D;1，也就是按列合并，以此类推。\nX.sum()求和方法。返回一个只有一个元素的张量\ntorch.tensor.item()方法可以取出张量中的元素，仅限0维的张量，只有一个元素的那种。\n\n广播机制对于形状不同的两个张量，基于广播机制，我们仍然可以进行按元素操作，比如相加相乘。比如：\ntensor([[0],\n        [1],\n        [2]])\ntensor([[0, 1]])\ntensor([[0, 1],\n        [1, 2],\n        [2, 3]])\n\n# 对于第一第二个张量，两个相加之后会产生如上所示的第三个张量，也就是说，形状不一样的张量，他会自动扩展成一样的，然后进行计算。\n0     0 0\n1  -&gt; 1 1\n2     2 2\n0 1 -&gt;  0 1\n        0 1\n        0 1\n如上变换之后，再进行按位计算。\n\n处理缺失的数据常用的方法有插值和删除。插值就是将NaN的数据修改成一个正常的数据，删除就是将含有NaN的那行数据直接删除。\n例如一下的插值方法：\ninputs, outputs &#x3D; data.iloc[:, 0:2], data.iloc[:, 2]\ninputs &#x3D; inputs.fillna(inputs.mean())\nprint(inputs)\n\n   NumRooms Alley\n0       3.0  Pave\n1       2.0   NaN\n2       4.0   NaN\n3       3.0   NaN\n\n结果上，将NumRooms中的NaN替换成了现有数据的平均值。\niloc为indexloction根据下标来获取子数组\nfillna用于填充NaN的数据。\ninputs.mean()用于计算每一类别的平均值，如果可以计算的话。\n\n对于数组中的类别值或者离散值，我们将NaN看成一个类别。比如：\ninputs &#x3D; pd.get_dummies(inputs, dummy_na &#x3D; True)\n通过这个方法之后，inputs变为了如下\nNumRooms  Alley_Pave  Alley_nan\n0       3.0           1          0\n1       2.0           0          1\n2       4.0           0          1\n3       3.0           0          1\n\n相当于将原来Alley属性中的所有离散值拆成了表格中的每一个属性，然后通过0和1来表示这条记录中的Alley是什么。这样就消除了NaN。\n\n综上，进行了一个数据的预处理，将csv中的数据处理掉NaN的值，最终转化为torch中使用的张量。\n数学基础范数$c &#x3D; A*b  \\ hence \\  ||c|| \\le ||A|| * ||b||$\n取决于如何衡量b和c的长度，b和c都是向量。\n常见范数：\n矩阵范数：最小的满足上述公式的值\nFrobenius范数：$||A||{Frob} &#x3D; [\\sum{ij} A_{ij}^2]^{\\frac{1}{2}}$\n正交矩阵\n所有行都相互正交\n所有行都有单位长度\n可以写成$U*U^T&#x3D;1$\n\n置换矩阵置换矩阵是一个方形二进制矩阵，它在每行和每列中只有一个1，而在其他地方则为0。\n设P 是一个 m×n 的 (0,1) 矩阵，如果 m≤n且 PP′&#x3D;E，则称 P为一个 m×n的置换矩阵。其中P′是P的转置矩阵，E是m阶单位方阵。\n哈达玛积(Hadamard product)两个矩阵的按元素乘法称为哈达玛积。数学符号为$\\odot$\n$L_2$范数是向量元素平方和的平方根$||x||2 &#x3D; \\sqrt{\\sum{i&#x3D;1}^{n}x_i^2}$\n$L_1$范数是向量元素的绝对值之和$||x||1&#x3D;\\sum{i&#x3D;1}^{n}|x_i|$\n亚导数将导数拓展到不可微的函数\n$$\\frac{\\partial |x|}{\\partial x}&#x3D;\\begin{cases}1 , &amp; x &gt; 0 \\ -1,  &amp;x&lt;0 \\ a , &amp; x&#x3D;0, a \\in [-1,1] \\end{cases}$$\n其中a为该区间内的任意数。\n矩阵求导公式\n\n自动求导自动求导是计算一个函数在指定值上的导数\n有别于：\n\n符号求导，给你一个f(x)，求f’(x)\n数值求导：用一个逼近值去拟合在某一点的导数值。\n\n自动求导实现涉及向量梯度的求解，实现方法如下\nx &#x3D; torch.arange(12, requires_grad&#x3D;True)\n# 或者先构造x，然后调用x.requires_grad_(True)\n# 这样之后，y对于x的梯度会存储在x.grad里面\ny &#x3D; 2 * torch.dot(x, x)\ny.backward()\nprint(x.grad)\n#然后通过调用y的反向传播函数来进行求导，得到的结果通过x.grad访问\n通过x.grad.zero_()将梯度清空，因为pytorch会默认累计梯度值\n\nChapter 3 Linear Neural NetworkLinear regression衡量预估质量：\n​\t平方损失：$y&#x3D;\\frac{(y-y’)^2}{2}$其中y’为估计值，y为真实值。\n调用现有框架来进行线性回归的使用# 使用nn的预定好的层，线性回归实际就是线性的神经网络\nfrom torch import nn\n\nnet &#x3D; nn.Sequential(nn.Linear(2, 1))\n# Linear中规定输入的维度和输出的维度。\n\n# 初始化模型参数\nnet[0].weight.data.normal_(0, 0.01)\nnet[0].bias.data.fill_(0)\n# weight 就是w， bias就是b\n\n# 计算均方误差，使用MSEloss类\nloss &#x3D; nn.MSELoss()\n\n# 实例化梯度下降算法，SGD\ntrainer &#x3D; torch.optim.SGD(net.parameters(), lr &#x3D; 0.03)\n# 需要所使用的network中的所有参数，以及学习率\n\n\n# 构造真实的w和b\ntrue_w &#x3D; torch.tensor([2, -3.4])\ntrue_b &#x3D; 4.2\nfeatures, labels &#x3D; d2l.generate_data(true_w, true_b, num_examples)\n# 这部分都是自己写的，和库无关。\n\n# 读取数据集\ndef load_array(data_arrays, batch_size, is_train&#x3D;True):  #@save\n    &quot;&quot;&quot;构造一个PyTorch数据迭代器&quot;&quot;&quot;\n    dataset &#x3D; data.TensorDataset(*data_arrays)\n    return data.DataLoader(dataset, batch_size, shuffle&#x3D;is_train)\n# 之后就可以通过load方法来获取数据迭代器，来迭代获取各batch数据\nbatch_size &#x3D; 10\ndata_iter &#x3D; load_array((features, labels), batch_size)\n\n\n\n# 训练过程\nnum_epoch &#x3D; 3\nfor epoch in range(num_epoch):\n  for X, y in data_iter: # 遍历每一个batch数据\n    l  &#x3D; loss(net(X), y) # 计算对应的损失\n    trainer.zero_grad() # grad清零\n    l.backward()# 进行反向传播\n    trainer.step() # 更新w和b参数\n  l &#x3D; loss(net(features), labels)\n  print(message)\n\n损失函数L2 loss\n$l(y, y’)&#x3D;\\frac{(y-y’)^2}{2}$\nL1 loss\n$l(y,y’)&#x3D;|y-y’|$\nHuber’s Robust Loss\n$l(y,y’)&#x3D;\\begin{cases} |y-y’|-\\frac{1}{2} \\ if \\ |y-y’|&gt;1 \\ \\frac{(y-y’)^2}{2} \\ otherwise \\end{cases}$\nsoftmax回归softmax回归其实是一种分类模型，他是将输入根据预定好的n个参数，计算出来预定好的k个分类的置信度。输出的每个分类都有一个置信度，也就是一个概率，概率最高的那个，我们就认为模型预测的就是那个。\n而对于label，就相当于某个分类的置信度是1，其他都是0，如此我们可以将输出量化。\nsoftmax具有一个softmax(x)的子操作，我们对于一个输入的example，通过softmax计算出k中分类他们对应的置信度，得到的一个向量。\n对于损失函数，我们使用预测值和真实值的交叉熵作为损失函数的值，用来进行模型参数的优化。\npytorch实现# 设置batchsize大小，获取训练数据和测试数据\n \tbatch_size &#x3D; 256\n   train_iter, test_iter &#x3D; load_data_fashion_mnist(batch_size&#x3D;batch_size)\n# 在神经网络中开辟线性层，同时因为线性网络是全连接层，所以必须要将数据展开\n   net &#x3D; nn.Sequential(nn.Flatten(), nn.Linear(784, 10))\n# 初始化weight，一层一层的初始化\n   def init_weight(m):\n       if type(m) &#x3D;&#x3D; nn.Linear:\n           nn.init.normal_(m.weight, mean &#x3D; 0, std &#x3D; 0.01)\n\n   net.apply(init_weight)\n# 定义损失函数，使用交叉熵\n   loss &#x3D; nn.CrossEntropyLoss()\n# 定义训练方法，使用SGD方法\n   trainer &#x3D; torch.optim.SGD(net.parameters(), lr &#x3D; 0.1)\n# 训练过程，和线性回归类似\n   num_epochs &#x3D; 10\n   for epoch in range(num_epochs):\n       for X, y in train_iter:\n           l &#x3D; loss(net(X), y)\n           trainer.zero_grad()\n           l.backward()\n           trainer.step()\n       loss_list &#x3D; []\n       for X, y in test_iter:\n           with torch.no_grad():\n               l &#x3D; loss(net(X), y)\n               loss_list.append(l.item())\n\n       tensorloss &#x3D; torch.tensor(loss_list)\n       avg_loss &#x3D; tensorloss.mean()\n       print(f&quot;epoch: &#123;epoch + 1&#125;, loss: &#123;avg_loss&#125;&quot;)\n\n计算准确率和准确的个数# 单次预测上的准确个数\ndef accurate_numbers(y_hat, y):\n    if len(y_hat.shape) &gt; 1 and y_hat.shape[1] &gt; 1:\n        y_hat &#x3D; y_hat.argmax(axis&#x3D;1)\n    cmp &#x3D; y_hat.type(y.type()) &#x3D;&#x3D; y\n    return float(cmp.type(y.type()).sum())\n\n# 在数据集上的正确率\ndef accurate_rate(net, data_iter):\n    # 如果net是nn&#39;里面的，net需要修改成评估模式，禁止梯度计算\n    if isinstance(net, torch.nn.Module):\n        net.eval()\n    number_accurate &#x3D; 0.0\n    number_all &#x3D; 0.0\n    for X, y in data_iter:\n        number_accurate +&#x3D; accurate_numbers(net(X), y)\n        number_all +&#x3D; len(y)\n\n    return number_accurate &#x2F; number_all\n\n其实就是比较y_hat和y在类型上有多少相同的。\nChapter 4 感知机感知机给定输入x， 权重w，偏移b，感知机的输出为：\n$o &#x3D; \\sigma (&lt;w, x&gt; + b) \\ \\ \\ \\ \\ \\sigma (x) &#x3D; \\begin{cases} 1 \\ if \\ x &gt; 0 \\ -1 \\ otherwise \\end{cases}$\n他是一种二分类。\n训练过程如下：\nw&#x3D;0, b&#x3D;0\nrepeat \n\tif yi[&lt;w,xi&gt;+b]&lt;&#x3D;0 then\n\tw &#x3D; w + yi*xi \n\tb &#x3D; b + yi\nend if\nuntil all classified correctly\n\n训练过程等价于batchsize&#x3D;1的梯度下降，使用的loss函数如下：\n$l(y,x,w) &#x3D; max(0, -y&lt;w,x&gt;)$\n感知机收敛定理requirements：\n\n数据范围在半径r的范围之内\n存在一个余量$\\sigma$ 使得两种分类之间有至少一个余量的间隔——也就是分类数据之间不能贴太紧\n\n定理：综上，可得，感知机保证在$\\frac{r^2 + 1}{\\rho ^2}$ 步之后收敛\n感知机的局限性感知机只能产生线性分割面，不能处理XOR问题。\n多层感知机(MLP)因为感知机存在局限性，只能产生线性分割面，所以产生了多层感知机\n多层感知机相较于单层感知机，其实就是添加了一个中间层，其中中间层的输出等于上一层的输入经过一个非线性公式变换。注意，一定是非线性变换，不然最终的多层感知机其实还是等价于一个单层感知机。这个非线性变换函数称为激活函数 \n常见激活函数：\n\n\n\n\n\n\n\n\n\nSigmoid函数：$sigmoid(x) &#x3D; \\frac{1}{1+e^{-x}}$\ntanh函数：$tanh(x) &#x3D; \\frac{1-e^{-2x}}{1+e^{-2x}}$\nReLU(rectified linear unit)函数：$ReLU(x) &#x3D; max(x, 0)$\n多层感知机可以设置多层隐藏层，同时也可以调整每个隐藏层的大小。\n超参数：隐藏层数，每层隐藏层的大小\n权重衰退(weight decay)一种控制过拟合的方法。\n使用均方范数作为硬性条件：\n$min \\  l(w, b) \\ \\ \\ subject \\  to \\ ||w||^2 \\le \\theta$ \n通常不限制偏移b，$\\theta$ 越小，意味着更强的正则项。通过这种硬性限制，来调整w的大小，防止w过大\n使用均方范数作为柔性条件：\n对于每一个$\\theta$ 我们都可以找到一个$\\lambda$ 使得之前的目标函数等价于下式。\n$min \\ l(w, b)+\\frac{\\lambda}{2}||w||^2$ \n超参数$\\lambda$ 控制了正则项的重要程度，如果为0，则没作用，如果$\\lambda -&gt; \\infty$ 则w* -&gt; 0 \n\n由公式中可以看出，通过引入$\\lambda$ 我们能够人为的控制$w_t$的大小。\n丢弃法(dropout)丢弃法：就是在层之间加入噪音。但是呢，我们希望加入的噪音，不会影响数据的结果，最起码是平均结果。也就是说$E[x’] &#x3D; x $其中，x’为x加入噪音之后的值。 \n丢弃法对每个元素进行如下扰动：\n$x_i’ &#x3D; \\begin{cases} 0 \\ with \\ probablity \\ p \\ \\frac{x_i}{1-p} \\ otherwise \\end{cases}$\n丢弃法使用在隐藏全连接层的输出上，假设隐藏层输出为h，那么下一层的输入将会变成$h’ &#x3D; dropout(h)$。从结果上来看，在隐藏层上添加了dropout之后，相当于随机的丢弃了隐藏层中的一些节点，减少了模型规模。训练中dropout如上使用，在推理中，不需要dropout 的操作，所以此时的dropout输入就等于输出。\n这个丢弃概率p是一个超参数\n数值稳定性数值稳定性问题，本质上是因为模型的深度增加之后，因为梯度的累乘，导致梯度爆炸或者消失的问题。最终导致训练结果不好。\n解决办法：为了让梯度更稳定，也就是在合理的范围内，可以尝试让乘法变成加法，或者将梯度归一化，梯度裁剪等。\n最重要的还是合理的权重初始化和激活函数。\nXavier初始化：使得$\\gamma_t(n_{t-1}+n_t)&#x2F;2 &#x3D; 1 \\rightarrow \\ \\gamma_t &#x3D; \\frac{2}{n_{t-1}+n_t}$ \n\n正态分布：$N(0, \\sqrt{\\frac{2}{n_{t-1}+n_t}})$ \n均匀分布：$u(-\\sqrt{\\frac{6}{n_{t-1}+n_t}},\\sqrt{\\frac{6}{n_{t-1}+n_t}})$ ——均匀分布[-a, a]和方差是$\\frac{a^2}{3}$\n\nChapter 5 Deep Learning Calculation模型构造使用继承自nn.module的类，来自己构造一个模型，或者说是nn中的一个块，需要重写init和forward函数，同时也可以自己重写一个sequence函数，从而实现nn套nn的情况。\n参数管理主要是nnmodule中的层中的参数都是可以随机访问，并且修改的。同时也支持apply按层初始化方法，不同层之间也可以apply不同的初始化方法。整体上nn框架的自由度还是很高的。\n读写文件保存和加载张量：使用torch.save and torch.load\n加载参数列表的时候，不止要带过来params，同时模型也要一并带过来。\n# save the params \ntorch.save(net.state_dict(), &quot;XXX.params&quot;)\n# Load the params\nclone &#x3D; xxxModel() # 实例化对应的模型\nclone.load_state_dict(torch.load(&quot;XXX.params&quot;))\nclone.eval() # 这一步是将模型切换到评估模式，确保之后进行test的时候，确实是在测试，而不是在训练。\n\n如何在GPU上运行NN# 获取gpu个数\ntorch.cuda.device_count()\n# 获取第i个GPU，0-base\ngpu_name &#x3D; torch.device(&#39;cuda:i&#39;)\n# 查看张量所在的设备上\nx &#x3D; tensor\nx.device # 就是设备名称\n\n# 创建张量的时候可以声明在gpu上\nx &#x3D; torch.ones(2, 3, device &#x3D; gpu_name)\n\n\n# 将张量移动到另外一块GPU上\nX &#x3D; torch.ones(2, 3, device &#x3D; gpu1)\nY &#x3D; torch.ones(3, 2, device &#x3D; gpu2)\n# 想让X和Y进行计算，需要将两个张量置于同一块GPU上，通过以下来移动\nZ &#x3D; X.cuda(i) # 将X复制一份，然后copy到第i块GPU上\n\n\n# 对于nn\nnet.to(device &#x3D; gpu) 通过net.to方法来将整个网络移动到某块GPU上\n# 使用data.device可以确认整个net都在同一块GPU上\nnet.weight.data.device\n\nChapter 6 convolutional neural network，CNN卷积重新考察全连接层，将输入和输出变形成一个矩阵，将权重变成一个4-D张量，(h’, w’)\n两个原则：平移不变形，局部性。\n总结：对全连接层使用以上两个原则就得到了卷积层。\n所以说，卷积层又称为特殊的全连接层\n卷积层二维卷积层$Y &#x3D; X※W + b$\n其中※表示卷积操作，输入X：$n_hn_w$ 核W：$k_hk_w$, $b\\in R$ ，输出Y ：$(n_h-k_h+1) * (n_w-k_w+1)$ \nW和b都是可以学习的参数。\n所以，卷积层其实就是输入和卷积核进行交叉相关，加上bias得到输出。卷积核的大小是超参数。\n填充和步幅由上式子不难发现，卷积之后维度都变小了，多进行几次维度都快没了。\n所以我们需要填充，对输入周围一圈填充一些数据。从而输出的大小和输入一样，甚至更大\n步幅：指行&#x2F;列的滑动步长，默认为1，也就是一步一步移动过去。\n这两个也是个超参数\n多输入多输出通道对于多输入通道，每一个输入都会有一个卷积核，分别做卷积操作，最后结果将各通道的结果加起来。\n对于多输出通道，每一个输出都会有一个对应的卷积核，分别做卷积操作，各通道卷积之后的结果就是该通道的输出结果。\n\n对于多输入，多输出的情况，见上图演示。\n池化层池化层主要是为了降低卷积层对位置的敏感性。池化操作类似卷积，只不过卷积的过程改成了另外一些算法\n常见池化层算法：1. 取max， 2. 取平均值\n池化层和卷积层一样，可以调kernel的大小，调整padding，stride等等超参数。\nLeNET\nchapter 7 modern CNNAlexNet , VGG , NiN , GoogLeNet \n批量归一化(batch normalization)批量归一化固定小批量中的均值和方差，然后学习出适合的偏移和缩放。可以加快收敛速度，一般不改变模型精度\n具体归一化方法如下：\n\n可以学习的参数就是$\\gamma$和$\\beta$ 。可以作用在全连接层和卷积层的输出上，激活函数前，也可以作用在他们的输入上。\n对全连接层，作用在特征维度。\n对卷积层，作用在通道维。\n最初，批量归一化认为可以减少内部协变量转移，反而是通过在小批量中添加了噪音来控制模型复杂度。噪音就是每个batch数据的均值和方差。So， 没必要和dropout一起用。\nResNet残差网络的产生源自于一个问题：加更多的层总是能改进精度吗？\n当添加过多的层的时候，可能导致模型偏移最优解的地方。但是如果不同层直接nested，那就可以避免这个问题。\nresnet中，添加了一个fx &#x3D; x + gx的思想，也就是一块的输入可以跳过这块，直接到他的输出那边，然后相加，作为最终的结果输出。如图：\n\n以上是两种resnet块的方法，区别就在于走捷径的那边有没有一个1*1的卷积。当然resnet块也有很多其他的version，不同version的效果也都不一样。还有两种resnet块，高宽减半resnet块(strider &#x3D; 2)和高宽不变的。\n总体的架构和VGG挺像的。\n残差块使得很深的网络更加容易训练，因为更小的网络被nest进去了，训练起来被nest进去的会优先训练好，然后再逐渐往外训练。这个捷径的使用，其实有点像动态规划。\ndensenetdensenet总体来说和resnet差不多，只不过加操作变成了concat操作，导致了输出通道数的增加，同时，他concat的是一个稠密块中所有前面的结果，所以densenet必须还要带一个过渡层，从而抑制模型复杂度的增加。\nChapter 8 RNN文本预处理 按行读入整段文本，简单预处理一下一些字符（比如大写改小写，非字母字符改成空格）$\\rightarrow$ tokenize化，将文本行拆成word或者char $\\rightarrow$ 根据tokenize之后的结果，构建词汇表(vocabulary)。\n语言模型给定文本序列x1,x2…xT, 语言模型的目的是估计联合概率p(x1,x2,…..xT)。\nN元语法对于一个长度为m的序列，n为总词数，n()表示里面特定词或者词对出现的次数。\n$p(x_1, x_2, x_3…..x_m)&#x3D;p(x_1)p(x_2|x_1)p(x_3|x_1,x_2)…..p(x_m|x_1,x_2,…..x_{m-1})$\n$&#x3D;\\frac{n(x_1)}{n}\\frac{n(x_1,x_2)}{n(x_1)}\\frac{n(x_1,x_2,x_3)}{n(x_1,x_2)}….&#x3D;\\frac{n(x_1,x_2,x_3,….x_m)}{n}$\n如果一个序列比较长，因为文本量不够大，所以分子上可能会小于等于1。这个时候可以使用马尔科夫假设来缓解这个问题。\n所谓N元语法实际上就是马尔科夫假设中采用了N-1的长度。\n比如我采用了i的长度，那么我们预测这个值我们只看前i个，如果i&#x3D;0，则各序列保持独立。相应的，p求解公式也会变化。\nRNNRNN使用了一个隐变量h来表示过去的信息。$h_t由h_{t-1}和x_{t-1}决定，而当前输出o_t 由h_t决定$\nlossfuntion：RNN本质上其实还是个分类问题，预测下一个字符是哪个，选择概率最大的即可。所以loss当然可以选择交叉熵。这里RNN引入了一个新的lossfunction——困惑度（实际上就是对交叉熵作一个e(x)的运算）\n梯度裁剪：迭代中计算到这T个时间步上的维度，在backward的时候会有一个长O（T）的矩阵乘法链，导致数值不稳定。而梯度裁剪可以有效预防梯度爆炸。\n\n\n\n\n\n\n\n\n\ng 表示所有层的梯度\n$g &#x3D; min(1, \\frac{\\theta}{||g||}) * g$\n说白了就是当g的层数超过$\\theta$ 的时候，通过min运算，将g的层数控制在$\\theta$ 以内。\nChapter 9 Modern RNNGRUGRU建立在一个问题上——序列模型中，有些数据是不重要的，可以忽略，有些数据是很重要的，需要着重学习。以此添加了一个门的概念。\n两种门：更新门$Z_t$和重置门$R_t$\n\n由此可以控制Ht多学习一点Ht-1还是现在的Xt\nLSTMLSTM和GRU差不多，只不过两种门改成了三种门：忘记门，输入门，输出门。然后进行相应的参数计算。本质上也还是将GRU的思想一样，通过调成过去状态的比重，来遗忘一些过去的信息，多记住一些现在的信息。\n深度RNN实际上就是增加隐藏层的数量，类似MLP的思想\n双向RNN\n双向LSTM，非常不适合做推理，因为看不到未来的信息。但是很适合作序列抽取特征和填空。\n编码器-解码器编码器：将输入编程成中间形式（特征）。\n解码器：将中间形式转化为输出。\n由此可以得到编码器-解码器架构，一个模型就可以分为两块，编码器和解码器。\nseq2seqseq2seq是一个模型，用于从一个句子到另外一个句子，使用的是编码器解码器的架构。编码器和解码器里面使用的都是RNN，编码器中RNN最后一层的状态直接作为解码器的初始状态。\n使用BLEU来衡量生成结果的好坏。\n束搜索(beam search)在seq2seq中，我们预测每一个字符，都是选取的概率最大的那个。这是一种贪心的搜索。贪心得到的是局部最优解，往往不是全局最优解。当然我们可以暴搜，穷举全部的情况，当然这样时间复杂度太大，不现实。\nbeam search本质上就是穷举加剪枝，不过他这个剪枝不是基于每个子树层面的，而是每一层层面的。具体表现为bs给定一个k，表示我们保留每一层前k大概率的预测结果，然后根据这k种可能再去预测下一个字符。因为每次保留都是保留每一层上前k个，而不是每一个子树上前k个。所以他的时间复杂度是O(nkT)——n是字典大小，因为字典中的每一个值都有一个概率。\nChapter 10 attention mechanism注意力机制心理学认为人通过随意线索和不随意线索选择注意点。注意力机制添加了类似的功能。\n注意力机制显式的考虑随意线索，随意线索被称为查询(query)，非随意线索被称为keys，每一个输入都是一个(key, value)的键值对，通过注意力池化层来有偏好的选择某些输入。\t\n非参注意力池化层就是池化层没参数的，如下图的公式\n\n其中K()函数就是核函数，这里核函数使用高斯核$K(u)&#x3D;\\frac{e^{-\\frac{u^2}{2}}}{\\sqrt{2\\pi}}$ 带入K函数之后，可以得到以下结果。\n\n中间那一步实际上就是做了一个softmax子操作，毕竟分母就是分子的各种情况的求和。\n参数注意力池化层参数化的实际上就是引入了可以学习的w，在无参基础上，我们将fx修改成\n$f(x)&#x3D;\\sum_{i&#x3D;1}^{n} softmax(-\\frac{((x-x_i)*w)^2}{2})y_i$ 其中w就是可以学习的参数。\n实际上注意力机制的总体思想和GRU，LSTM是类似的，都是提取主要特征和内容，从而加强记忆用于之后的预测。\n查询（自主提示）和键（非自主提示）之间的交互形成了注意力汇聚（就是那个池化层）。注意力汇聚有选择地聚合了值（感官输入）以生成最终的输出。\n注意力分数\n注意力分数是query和keys的相似度，计算注意力分数有多种方法。而注意力权重就是将注意力分数做一次softmax的结果。如果拓展到多维，公式如下：\n\nAdditive Attention增加了可学参数$W_k\\in R^{hk}, W_q\\in R^{hq}, v\\in R^h$\n此时的$a(k, q) &#x3D;v^T tanh(W_k k + W_q q)$ 实际上W*k和W*q 的过程是将k和q都化为长为h的向量，之后再和v转置做乘法得到一个值作为a的值。\n等价于将k和q合并之后，放入一个隐藏层大小为h，输出为1的单隐藏层MLP。\nscaled dot-product attention如果query和key都是相同的长度d，那么可以\n$a(q, k_i) &#x3D; \\frac{&lt;q, k_i&gt;}{\\sqrt{d}}$\n向量化版本如下：\n\n自注意力机制自注意力池化层将xi当做key，value，query来对序列抽取特征。\nCNN,RNN,Self-Attention比较\n位置编码CNN和RNN中都能够体现位置信息，而自注意力中却不可以，所以需要引入位置编码在输入中加入位置信息，从而让自注意力能够记忆位置信息。\n多头注意力与其只使用单独一个注意力汇聚， 我们可以用独立学习得到的ℎ组不同的 线性投影（linear projections）来变换查询、键和值。 然后，这ℎ组变换后的查询、键和值将并行地送到注意力汇聚中。 最后，将这ℎ个注意力汇聚的输出拼接在一起， 并且通过另一个可以学习的线性投影进行变换， 以产生最终输出。 这种设计被称为多头注意力（multihead attention）。\n对于ℎ个注意力汇聚输出，每一个注意力汇聚都被称作一个头（head）\n也就是说，每一个注意力就是一个头，最终我们将这多个头的汇聚结果concat起来。期间都要做线性变换。\nTransformerTransformer使用encoder-decoder架构，纯使用注意力机制，没有使用RNN，将一系列层的操作包装成一个transformer块。encoder和decoder都有n个块。\nChapter 11 Optimization常见优化算法：梯度下降及其变种，动量法，adagrad，RMSprop， adadelta，adam。\nChapter 12 computational-performanceGPU并行计算，异步处理，多GPU训练，多服务器多GPU分布式训练。\nChapter13 Computer Vision图像增广其实就是对原图像做各种操作，比如随机切割，改颜色，饱和度，透明度等等，使得能够产生更多的不同的图像，增加数据集的量和不同之处。获取多样性从而使得模型泛化性能更好。\n微调使用一个pre-train过的模型，来用自己的数据集来训练自己的模型。自己的模型参数初始化使用已经训练好的。\n源数据集（预训练模型使用的数据集）远远复杂于目标数据，通常微调的效果更好。\n锚框一类目标检测算法基于锚框来实现的。锚框其实也就是一个框，只不过他属于是检测框的预测。我们最后需要在锚框中选择一个作为检测框。\n首先先生成大量锚框，然后赋予标号，每个标况作为一个样本去训练。\n使用IoU来计算两个框之间的相似度。$IoU &#x3D; \\frac{相交的部分}{并起来的部分}$ 去除多余锚框的时候基于非极大值抑制（NMS），也就是选中非背景类预测值最大的，去掉所有和他IoU值超过一个阈值$\\theta$ 的，重复这个过程，直到所有预测要么被选中，要么被去掉。\nR-CNNsR-CNN是一种regional-CNN 是卷积神经网络，同时是最早的使用锚框做目标检测的CNN。\nFast R-CNN和Faster R-CNN在处理速度上进行了优化。Mask R-CNN则是在处理精度上进行了优化。\n单发多框检测(SSD, single shot detection)single shot 也就是看一次。不像R-CNN，有一个主CNN和一个辅CNN来处理同一个图像。SSD只有一个CNN处理。\nSSD会对每个像素，生成多个以他为中心的锚框，SSD以一个基础网络来抽取特征，然后多个卷积层块来减半高宽，在每段都会生成锚框，对锚框预测类别和边缘框。\n语义分割语义分割是将图片中不同东西都描边描出来，比如猫猫狗狗都分出来，还有背景也分出来。涂成不同的颜色。\n语义分割是将图片中的每个像素分类到对应的类别。\n转置卷积转置卷积实际上是卷积的逆过程。\n卷积是将输入的宽高变小或者不变，而转置卷积则是将输入的宽高变大或者不变。\n转置卷积同样有padding和strike。和卷积相反，padding反而会让结果变小，strike反而会让结果更大。\n转置卷积转化为卷积的过程如下图：\n\n形状换算如下图所示：\n\n转置卷积不等于数学上的反卷积。两个不是一个东西。\n全连接卷积神经网络FCNFCN将CNN中最后两层全局池化层和全连接层，替换成了1*1的卷积层和一个转置卷积层，最后会得到一个扩大之后的图像，并且通道数就等于类别数，从而能够实现对每一个像素点的类别预测。\n样式迁移将样式图片中的样式迁移到内容图片上，得到合成图片。这就是样式迁移。\nChapter 14 NLP-pretrainedword2vec词嵌入词向量是用于表示单词意义的向量。将单词映射到实向量的技术称为词嵌入。独热编码也是一种词嵌入，只不过这种方法效果很差。\nword2vecword2vec工具是为了解决独热编码问题而产生的。它也将每个词映射到一个向量上，只不过这个向量可以更好的表达不同次之间的相似性和类比关系。word2vec包含两个模型，跳元模型和连续词袋。\n跳元模型考虑中心词预测上下文词。\n在两种模型中，每一个词都用两个d维向量表示，词典中索引为i的词有$v_i$ 和$u_i$ 表示中心词和上下文词，在词袋模型中他们的含义正好相反，要注意。\n连续词袋模型考虑上下文预测中心词。\n近似训练上述两种模型中，都用到了softmax子操作来预测结果，而softmax子操作中会涉及整个词表大小一样多的项的求和，这就导致梯度计算非常的昂贵，为了解决这个问题出现了近似训练。\n一共有两种。\n\n负采样。负采样通过让采样中添加负样本而不仅是正样本，使得推理的时候不涉及整个词表大小数量的项的和，而仅仅涉及正负样本数量的项的和。大大减少了梯度的计算量\n层序softmax。层序softmax将词表构建成了一颗二叉树，分层softmax将原本的损失函数更改成了和词w，以及从根节点到词w的路径上的节点相关，而不是跟整个词表相关。从而大大减少了梯度计算。\n\nGloVeGloVe是在word2vec上基础上改的，该模型结合了全局词频统计信息和局部上下文信息 。能够很好的利用高相关性的词对。GloVe主要对跳元模型做了三个修改，一个是使用$x_{ij}$ 和$e^{u_j^T v_i}$ 而不是概率分布，取对数之后计算平方损失。其次为每个词添加了中心词bias和上下文词bias，最后使用权重h(x)来替换每个损失项的权重，hx一方面可以省略掉$x_{ij}$ 为零的，也就是出现次数为零的项，另外一方面可以控制高频词的权重，防止高频词减缓训练速度。基于这三点修改，GLOVE重构了损失函数。\n子词嵌入普通词嵌入没有考虑到词和变形词之间的相近性，同时也没有考虑诸如girl,girlfriend和boy,boyfriend的关系相近。也就是说没有对词的内部结构进行探讨。\nfastText模型fastText提出了子词嵌入的方法，其中子词是一个字符的n-gram。fastText可以认为是子词级的跳元模型，每个中心词由其子词向量之和表示。\n对于一个单词where，首先在他的首尾加上&lt;&gt;变成&lt;where&gt; 然后求他的n-gram，也就是所有的长度为n的子串——子词。假设n&#x3D;3，可以获得如下子词“&lt;wh”“whe”“her”“ere”“re&gt;”和特殊子词“&lt;where&gt;”。\n在fastText中，对于任意词w，用Gw表示其长度在3和6之间的所有子词与其特殊子词的并集。词表是所有词的子词的集合。假设$z_g$是词典中的子词g的向量，则跳元模型中作为中心词的词w的向量$v_w$是其子词向量的和：\n\n\n\n\n\n\n\n\n\n$v_w &#x3D; \\sum_{g \\in G_W} z_g$ \n字节对编码(BPE)BPE 的核心思想是通过逐步合并文本中最频繁的字符对，减少词汇量并创建更紧凑的表示方式。以下是 BPE 的主要步骤：\n\n初始化字符集：将所有词分解成单个字符作为初始单位。\n统计字符对频率：统计所有字符对（即相邻字符组合）的频率，找出出现次数最多的字符对。\n合并字符对：将频率最高的字符对替换为一个新符号（将这个字符对视为一个整体）。\n迭代合并：重复步骤 2 和 3，直到达到预定的合并次数或词汇表大小。\n\n因为合并的始终是频率最高的，所以其实是一种贪心算法。\nChapter 15 NLP-ApplicationNLP应用现在主要是微调预训练好的模型，对于很多应用任务，只需要在预训练好的模型后面添加一些层就可以完成任务了。\nNLP应用主要有：\n\n句子分类——将&lt;cls&gt;对应的向量输入到全连接层做分类问题\n\n命名实体识别——识别一个单词是不是命名实体或者专有名词，比如人名，机构等。做法是将非特殊词元输入到全连接层做分类。\n\n问题回答——给定一个问题和描述问题，找出一个片段作为回答。做法是对描述文字中的每一个词预测他是不是回答的开始或结束。\n\n情感分析——研究人们在文本中的情感，这被认为是一个文本分类问题。\n\n自然语言推断——自然语言推断（natural language inference）主要研究 假设（hypothesis）是否可以从前提（premise）中推断出来， 其中两者都是文本序列。 换言之，自然语言推断决定了一对文本序列之间的逻辑关系。这类关系通常分为三种类型：\n\n蕴涵（entailment）：假设可以从前提中推断出来。\n矛盾（contradiction）：假设的否定可以从前提中推断出来。\n中性（neutral）：所有其他情况。\n\n实际上自然语言推断就是一个推理的过程，给定前提让模型判断是否能够推断出来假设。\n\n\n","slug":"DLNotes","date":"2024-11-06T09:16:39.000Z","categories_index":"AI","tags_index":"AI,DeepLearning,DL,Model","author_index":"Ausert"},{"id":"2c328a2145590af1c8c2b559a8951062","title":"ACM学习笔记day34 (DP专题的总结)","content":"已经很久没有写笔记了。主要是我一方面我摆（bushi,另外一个就是，后面的各种DP其实写笔记也没啥好写的，主要是理解这个DP是啥，然后也没有对应的板子好写的。自然也就不更新笔记了。那么最近是把基础的DP都学完了，作一个总结，大致的讲一下DP到底是个啥。DP的分类有啥怎么分类的。\n\n\n\n什么是动态规划？这个问题其实很难回答。因为对于动态规划的定义，其实很难下定义。但是对于动态规划的概括其实很简单。动态规划就是在运行的过程中，不断的去运用之前已经得到的信息，从而来使得时间复杂度降低。那么相应的，作为代价，空间复杂度就会上升，也就是常说的那句：用空间换时间。怎么运用，这个就是状态转移方程了。其实在说DP之前，我们应该先知道另外一个东西，那就是记忆化搜索。在阿美莉卡那边的教学中，一般都是先教记忆化搜索，然后再教DP的。其实我觉得这样是挺合理的，因为其实记忆化搜索就是DP问题的前身。\n如何建立状态，如何建立状态转移方程，那么这就是DP问题的难点了。\nDP问题的分类。当然这里的DP问题分类是最基础的DP分类，之后专题总结应该还会补充。总的来说分为以下几类：背包问题，线性DP，区间DP，计数类DP，数位统计DP，状态压缩DP，树形DP，记忆化搜索。这里背包问题其实是线性DP的内容，只不过因为太经典了，所以我们这里单独作为一类。\n背包问题背包问题，可以说是DP问题的非常经典的一个问题了。背包问题可以分为很多种类，包括但不限于 01背包，完全背包，多重背包，分组背包。其中最核心的还是01背包问题，因为其他问题是01背包的变种，其核心思路还是和01背包问题大差不差的。\n01背包问题，通常的二维数组解法就是dp[i][j]表示对于背包剩余容量为j，我们已经拿到了第i个物品，此时里面的最大价值是多少。对于第i个物品，我们一共就有两种选择，拿或者不拿，通过这个我们就可以很轻松的得到dp的状态转移方程。\n\n\n\n\n\n\n\n\n\ndp[i][j]&#x3D;max(dp[i-1][j],dp[i-1][j-v[i]]+w[i]);\n当然这里v和w数组到底是啥，可以去看我之前背包问题的具体分析的blog。;\n其他的背包问题具体可以看我其他的blog，都有分析的。\n线性DP什么是线性DP呢？其实很简单。我们都知道DP他是有一个存储状态的数组的。一般我们都叫他dp数组，或者是f数组。那么我们也都知道，要做动态规划的问题，一方面要处理边界值，另一方便，就是遍历一边我们的dp数组来解决问题。那么怎么遍历呢？线性DP的遍历方式就是从头遍历到尾巴。比如说这样的一个二维数组\n1 2 3 \n4 5 6\n7 8 9\n\n我们线性DP的方向就是这样的:\n\n1-&gt;2-&gt;3 \n-&gt;4-&gt;5-&gt;6\n-&gt;7-&gt;8-&gt;9\n\n\n那么这样子的遍历方式就是线性DP。概念很好理解，但是碰到题目，那就难了。不过这种东西还是要多练才可以。\n区间DP区间DP和线性DP最大的不同点就在于，他每次DP的时候，是规定了一个DP的区间长度的。\n区间dp就是在区间上进行动态规划，求解一段区间上的最优解。主要是通过合并小区间的最优解进而得出整个大区间上最优解的dp算法\n我们会发现，这个求解局部最优解是不是有点眼熟，没错，贪心也是求取局部最优解的，不过，贪心没有将各个局部的最优解合并。\n其实，光听那么说会感觉很抽象，说实话，这个阐述我也不太理解，能懂，但是实际上并不理解。这个我估计还是题目做少了。\n计数类DP计数类DP顾名思义，其实就是一种运用DP去统计数量的问题。计数类DP是是比一般的DP问题约束更多的。因为一般的DP问题，只要求我们对于情况的枚举不能遗漏，如果有重复是没有关系的。但是计数类的DP，是不能遗漏同时也不能重复，因为他最终是要统计出来有多少个可行解的。如果重复，显然会使得结果偏大。\n比较常见的问题，比如说问题。这里其实就是让你求一个整数可以划分成多少种可能，那么很显然，我们dp过去的时候，肯定不能重复算，也不能漏算。这就是计数类DP问题。计数类DP问题他的遍历方法和线性dp是一样的。\n数位统计DP数位DP往往都是这样的题型，给定一个闭区间[l,r]，让你求在这个区间内的某种条件的，数的个数。这种时候，一般这个区间都会开的很大，如果暴力做的话，肯定会TLE的。而这种时候，我们不能在这个区间内的所有数字上做文章，而是要在要在给的边界上做文章。具体在哪里做文章呢？其实就是数字位上，这也就是为什么他被成为数位DP。当然这个讲的很抽象，还是要多做题去理解的。\n状态压缩DP状态压缩DP，这其实是一类非常奇妙的DP。我们来看这个名字，状态压缩。什么叫状态压缩？其实就是将我们需要表示的状态，采用特殊的形式来表示，比如说用二进制数字来表示，或者string来表示。以方便我们放入我们的dp数组，好进行遍历，状态转移的求解。而这个过程也就叫状态压缩。关于这个的题，我这里也是有一篇博客的来着的。\n树形DP这个很好理解，顾名思义，就是相当于在树上面进行DP的过程。一般也会搭配dfs的过程。\n记忆化搜索这个其实也很好理解，就是在dfs爆搜的过程中，加入了一个dp数组，用来存储我们之前已经爆搜过的数据，来减少不必要的冗余搜索。过程上来看，和树形DP有一点像，但又不是完全一样的。\n好的，那么DP专题到这里是大致的讲完了。终于把之前的坑给填完了（总之，对于DP说实话还是不太理解的，还是需要多刷题。题目做的太少了。我们下次再见捏Bye~~\n","slug":"ACM学习笔记day34","date":"2023-03-19T10:29:55.000Z","categories_index":"ACM","tags_index":"ACM,打卡,笔记,DP,动态规划,专题总结","author_index":"Ausert"},{"id":"4a9ea142753f2671aa4c5ecbc1f2c491","title":"ACM小本本","content":"这里是记录ACM知识点中一些零碎的东西，或者一些小的注意点啥的\n\n\n1.使用二分模板的时候，当修改left值的时候，注意要让mid&#x3D;left+right+1&gt;&gt;1，不然会出现mid&#x3D;left然后死循环的出现2.快排和归并的本质就是分治，快排是先处理数据再分治，归并是先分治再处理数据3.浮点数二分的时候，当要求保留4位小数的时候，循环条件应该为r-l&gt;1e-6,当保留六位的时候，应该为r-l&gt;1e-8就是位数要比保留的数字多2，比如4-&gt;6,6-&gt;84.计算机一秒大约可以运算10^8次。5.构建前缀和数组的时候，下标从1一开始，零的位置就置成零，这样的话，能直接递推，而不用让第一个对于所给数组的第一个。&amp;ensp;&amp;ensp;同时在求值l到r之间的数字和的时候，能直接Sr-Sl-1，不怕l-1越界。6.一种取消C++和C混用的方式，用ios修改，可以提高cincout的速度：\nios::sync_with_stdio(0);\ncin.tie(0);\n这两行代码，相当于将C++的输入输出流和C的联系分开，加快了输入输出效率。7.差分数组不需要构建，把原来的数组看成全是零的输入，然后在i i之间的数加上个a[i]即可。这是个小技巧。二位差分数组同理。8.unique函数，vector a,unique(a.begin(),a.end())就是把a数组去重，然后重复的多余的数放在最后返回最后那段第一个元素的迭代器，搭配erase函数，可以直接把数组里面的重复数字全部去掉。e.g: a.erase(unique(a.begin(),a.end()),a.end());如上9.用数组模拟单向链表和双向链表的时候，要注意他插入的第k个数据，和我们的index的差别。比如单项链表，我们使用head作为头，但是实际数据index是从0开始的，而k一般从1开始，所以进行操作的时候要把k减一而双向链表，我们已经提前存了一个left和right头，所以实际数据index是从2开始的，k从1开始，所以操作的时候要把k加110.用到Trie树的时候，一般是字符串里面的字符比较简单，全部是小写字母，或者大写字母，或者全是数字，或者全是0和111.关于不同的数据量，在1s的时间内要求的最高时间复杂度，可以看这篇博客。链接12.如何把一个杂乱的数组，在O(n)的时间复杂度下快速构建成一个堆？代码如下\n&#x2F;&#x2F;n为数组长度，编号从1开始，down是down操作，证明可以模拟一下，然后用级数求和做\nfor(int i&#x3D;n&#x2F;2;i;i--)&#123;\n    down(i);\n&#125;\n\n13.字符串哈希的时候，不要把字母对应的数值映射成0，容易产生哈希冲突。\n14.采用开放寻址法处理哈希冲突的时候，一般要把哈希数组的长度扩大为给定数组长度的2~3倍\n15. 字符串哈希，一般P取131或者13331，Q取2^64，这样绝大多数情况不会发生哈希冲突\n16. 定义unsigned long long变量的时候，如果值溢出了，会自动取余\n17. 关于最短路问题常见的算法框架\n\n\n\nFloyd算法不能处理存在负权自环的图，会导致距离为负无穷\n\n对于n&#x2F;k向上取整，可以这么写 (n+k-1)&#x2F;k;\n\n对于int范围内的数字，约数最多的一个数字，他的约数个数大概为1500,1600个。\n\n对于要 求形如这种表达式的值的情况，对于数字特别大的情况下，也就是要求你每一步都要取模的时候，可能会爆pow函数。这个时候要使用秦九韶算法，也就是进行alpha1次循环，令t&#x3D;1，每次循环t&#x3D;t*p+1;这样最终t的值就是我们要求的值了。\n\n在C++中%代表的是取余运算，也就是说，得到的结果可能是负数的，但是我们数学意义上的余数不会是负数的。为了能够保证一定得到正数，可以这样做   设模数为b，原来的数字为a  (a%b+b)%b。这样我们得到的结果一定是正的了。\n\nSTL优先队列自定义比较方式的写法。和sort函数一样，都需要一个自己写一个cmp比较函数，但是在定义对象的时候必须要这么写。\nclass A &#123;&#125;;\npriority_queue&lt;A,vector&lt;A&gt;,decltype(&amp;cmp)&gt; a(cmp); &#x2F;&#x2F;这里第三个位置为固定的比较位，decltype函数参数里面要cmp的地址，定义对象的时候要执行含有cmp的构造函数。\n\nn个数的两两的最小异或对就是排序后最小的相邻异或值。\n\n\n\n","slug":"ACM小本本","date":"2022-11-09T12:43:41.000Z","categories_index":"ACM","tags_index":"ACM,学习,笔记本,零碎的,知识点","author_index":"Ausert"},{"id":"5a49538b9703a5d95e8ed166fb3d78bc","title":"研究生基本功","content":"Linux简单使用\n\n\n\n\n\n\n\n\n在进行以下操作之前，请先自行检索环境变量的作用，以及如何配置环境变量。\n新用户装机步骤# 升级系统\nsudo apt update # 更新软件包列表，切记不要upgrade\n\n# 配置 ssh，docker容器可以忽略\nsudo apt install openssh-server # 安装 ssh 服务\nsudo systemctl enable ssh # 开机自启\nsudo systemctl start ssh # 启动 ssh 服务\n\n# 如果端口出现问题，配置防火墙，docker容器内单独考虑\nsudo ufw allow 22 # 开放 22 端口\nsudo ufw allow 80 # 开放 80 端口\nsudo ufw allow 443 # 开放 443 端口\nsudo ufw allow 3306 # 开放 3306 端口\n\n# 在这之前，请先搞清楚公网和局域网的概念\n# 装好了以后，就可以在终端里通过下面的命令连接服务器。\nssh 192.168.8.65 # 注意替换ip\n# 如果需要X11图形化界面\nssh -X 192.168.8.65\n\n# 使用 ssh-keygen 生成一个 ssh key\n# 目前使用密码上不如使用 key 安全的，因为 key 的长度通常是 2048 或 4096 位，远超普通的密码。这里建议按照 GitHub 官方网站上的教程生成新 SSH 密钥并添加到 ssh-agent，这样不仅可以用于登录 Linux 机器，也可以用于 git。\n\n# 使用 ssh-keygen 生成了密钥以后，你会得到两个文件：\n\n# ~&#x2F;.ssh&#x2F;id_rsa\n# ~&#x2F;.ssh&#x2F;id_rsa.pub\n# 其中 id_rsa 是私钥，id_rsa.pub 是公钥。不要把私钥发给任何人。\n# 首先使用密码登录刚才的机器, 然后创建 ~&#x2F;.ssh 目录，并且创建 ~&#x2F;.ssh&#x2F;authorized_keys 文件，配置好相应的权限：\nmkdir -p ~&#x2F;.ssh\ntouch ~&#x2F;.ssh&#x2F;authorized_keys\nchmod 700 ~&#x2F;.ssh\nchmod 600 ~&#x2F;.ssh&#x2F;authorized_keys\nnano ~&#x2F;.ssh&#x2F;authorized_keys\n\n# 添加你的公钥，如 ssh-rsa AAAA...\n# 把刚才生成的公钥 id_rsa.pub 添加到 ~&#x2F;.ssh&#x2F;authorized_keys 里，如果文件已经有内容，就添加在最后一行。这样以后每次使用 ssh 登录机器都不需要再输入密码了。\n# 禁止密码登录\n# 由于密码登录存在不安全因素，比如暴露在公网的 IP 会被扫描，而 key 是相对安全的，所以我们可以禁止不安全的密码登录：\nsudo nano &#x2F;etc&#x2F;ssh&#x2F;sshd_config\n\nPasswordAuthentication no # 添加在最后一行\n\n# 配置 apt 源\n# 在使用 apt 的时候有可能因为网络原因导致安装过慢或失败，这时候可以配置一些 apt 源：\n\n# https:&#x2F;&#x2F;mirror.tuna.tsinghua.edu.cn&#x2F;help&#x2F;ubuntu&#x2F;\n# https:&#x2F;&#x2F;opsx.alibaba.com&#x2F;mirror\n# 下面以清华大学开源软件镜像站为例：\nsudo mv &#x2F;etc&#x2F;apt&#x2F;sources.list &#x2F;etc&#x2F;apt&#x2F;sources_backup.list\nsudo nano &#x2F;etc&#x2F;apt&#x2F;sources.list\n\n# 添加下面的内容，保存\ndeb https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;ubuntu&#x2F; bionic main restricted universe multiverse\n# deb-src https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;ubuntu&#x2F; bionic main restricted universe multiverse\ndeb https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;ubuntu&#x2F; bionic-updates main restricted universe multiverse\n# deb-src https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;ubuntu&#x2F; bionic-updates main restricted universe multiverse\ndeb https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;ubuntu&#x2F; bionic-backports main restricted universe multiverse\n# deb-src https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;ubuntu&#x2F; bionic-backports main restricted universe multiverse\ndeb https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;ubuntu&#x2F; bionic-security main restricted universe multiverse\n# deb-src https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;ubuntu&#x2F; bionic-security main restricted universe multiverse\n# 添加好以后，使用下面的命令更新 apt 以后，安装其他软件包的速度就会变快：\nsudo apt update\n# 恢复默认源：\nsudo mv &#x2F;etc&#x2F;apt&#x2F;sources_backup.list &#x2F;etc&#x2F;apt&#x2F;sources.list\n\n# 安装 oh my zsh 以及常用命令\n# 安装 oh my zsh\n# 相比默认的 bash，zsh 有以下几个优点：\n\n# 当你使用 tab 提示的时候，如果有多个匹配项，你可以用 tab 进行切换\n# 当你想使用一个之前输入过的命令的时候，只需要输入首字母，然后按上方向键切换\n# 安装 oh my zsh 的步骤如下：\n\n# 安装 zsh\n# 安装 oh my zsh\n# 完整命令如下：\nsudo apt install -y git curl zsh\nsh -c &quot;$(curl -fsSL https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;robbyrussell&#x2F;oh-my-zsh&#x2F;master&#x2F;tools&#x2F;install.sh)&quot;\n# 清华源安装 oh myz sh\ngit clone https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;git&#x2F;ohmyzsh.git\ncd ohmyzsh&#x2F;tools\nREMOTE&#x3D;https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;git&#x2F;ohmyzsh.git sh install.sh\n\n常用 Linux 命令# 基本命令，以下自行查找并练习使用\nls # 列出当前目录下的文件\ncd # 切换目录\npwd # 查看当前目录\nmkdir # 创建目录\nrm # 删除文件\nrmdir # 删除目录\ncp # 复制文件\nmv # 移动文件\ntouch # 创建文件\ncat # 查看文件内容\nless # 查看文件内容\nhead # 查看文件前几行\ntail # 查看文件后几行\nchmod # 修改文件权限\nchown # 修改文件所有者\nchgrp # 修改文件所属组\nfind # 查找文件\ngrep # 查找文件内容\ntar # 压缩文件\ngzip # 压缩文件\nunzip # 解压文件\nzip # 压缩文件\nssh # 远程登录\nscp # 远程复制文件\n\n# 以下为常用指令，需要熟练使用\nls 展开文件目录\nll 是ls -lh的别名 显示详细目标列表\n\n访问\ncd .. 返回上一级 cd ~ 访问home目录\ncd xx 进入某一目录或当前目录\nGPU\nnvidia-smi 查看gpu使用情况\n\n路径\npwd 以绝对路径显示用户当前工作目录\n合并 查看文件\ncat a.txt b.txt-&gt; c.txt 创建新txt\ncat a.txt 显示文件内容，较大时会滚动，ctrl+s 停止滚动，ctrl+q恢复滚动，ctrl+c退出当前命令\nhead -n 5 train.csv 显示前五行内容\ntail -n 5 a.txt 显示文件尾部10行内容\n\n查找 筛选\nfind 在指定目录下查找文件\ngrep 筛选命令 ll | grep .md\nwhereis xx查找包含指定关键字的文件 \nwhich python 查找当前使用的命令的绝对路径\nlocate 寻找包含关键字的所有文件路径 (locate命令需要sudo进行安装)\n\n创建 删除 复制\nmkdir 创建文件夹\ntouch xx.txt 创建空文件\nrm 删除\nrm -r 移除文件夹\nrm -rf * 删除所有文件\ncp src dst 复制文件\ncp -r src dst 复制文件夹\nmv src dst 移动命令\n\n压缩 解压\nzip file.zip file 压缩文件\nzip files.zip -r dir 压缩整个文件夹\nunzip files.zip\nunzip -d &#x2F;temp test.zip\n \n*.tar 打包文件格式，吧小文件拼接在一起\n*.tar.gz 压缩文件，先打包成一个文件，然后再压缩一遍\ntar -cvf files.tar dir 打包文件夹\ntar -xvf files.tar 解包\n\n权限管理\nsudo 以root权限执行命令\nchmod -r 777 data 修改权限的命令，777任何人可以读写\nchown -R ypw data 修改所有者的权限，把data文件夹的所有权改为ypw\npasswd修改当前用户密码\nsudo passwd xx 强制修改某个用户的密码\n\n进程管理\nps aux 列出所有进程的详细信息\nps aux | grep ipython | grep -v grep\n首先使用 ps aux 获取所有的进程信息，然后用 grep ipython 查找带有 python 的进程，最后使用 grep -v grep 过滤 grep 进程本身。\nkill 杀掉执行中的进程，ps命令得到进程\n\n磁盘管理\ndf -h 查看磁盘空间\ndf -ih 查看Inodes使用情况\ndu -h xx 查看文件夹大小\nmount -t ext4 &#x2F;dev&#x2F;nvme0n1p1&#x2F;data挂载磁盘 \ndu -h --max-depth&#x3D;1 查看当前目录下所有文件和文件夹的大小 # NOTE: 主目录下不要有太多文件，否则会导致磁盘空间不足，数据集等放在机械盘\n\n系统管理\napt install curl ubuntu系统的包管理器，用于安装和卸载软件包\nexport 设置环境变量，一般卸载.bashrc或.zshrc文件中\nsource ~.&#x2F;bashrc 更新环境变量\n\n系统监测\nuname -a显示当前的系统信息\ntop 实时查看系统的运行状态，如CPU,内存，进程等信息\nifconfig | grep inet查看当前网卡的ip地址\nfree -h 查看内存使用情况\n\n网络通信\nssh user@xx.xx.xx.xx\nscp 本地文件 user@xx：目标主机路径 复制文件到远程服务器\nscp user@xx：目标主机路径 本地地址\nscp file user@xx:&#x2F;data 复制文件\nscp -r directory user@xx:&#x2F;data 复制文件需要添加 -r参数\nrsync -avP 本地文件夹 user@xx:远程地址 复制大量小文件时，用rsync命令\nwget url从指定的url下载文件\n\n常用的监控工具# 以下为常用指令，需要熟练使用\nnvidia-smi 查看GPU使用情况\nwatch -n 10 nvidia-smi # 周期性输出GPU使用情况。-n指定每多少秒执行一次命令。\n# 推荐用nvitop包来监控GPU&#x2F;CPU用量，在安装单个包的时候也可以加 -i 镜像源名称。\npip install nvitop -i https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple some-package # nvitop --corlor # 彩虹颜色\ntop 查看系统状态\nhtop 查看进程 sudo apt install htop\ndf -h 查看磁盘空间\nfree -h 查看内存使用情况\niotop 查看IO使用情况 sudo apt install iotop\n\n\n计算机网络基础子网划分等基本概念该部分自己网络或者参考数据自行查找，这里不做要求\n主要搞清楚公网和局域网的概念，不要混淆\n学会使用两服务器通过网线构建p2p传输\n服务器代理挂载为了方便解决问题，统一使用 Clash Verge\nhttps:&#x2F;&#x2F;www.clashverge.dev&#x2F; # 自行下载\n# 比较便宜的机场推荐，非广告\nhttps:&#x2F;&#x2F;www.mojie.co\nhttps:&#x2F;&#x2F;hk.freecat.cloud&#x2F;\n# 购买后在Clash Verge中添加订阅即可\n\n# 服务器挂载代理，在设置中开启局域网（不要和公网ip混淆来问这种愚蠢的问题）连接，查看自己的ip并记下端口，在服务器端的环境变量中设置如下脚本代码：\n# 定义代理地址（根据实际端口修改）\nproxy_on() &#123;\n    # 默认值（可自行调整）\n    local ip&#x3D;&quot;$&#123;1:-xxx,xxx,xxx,xxx&#125;&quot; # 自行改为自己的ip地址\n    local port&#x3D;&quot;$&#123;2:-xxx&#125;&quot; # 自行改为自己的端口\n\n    # 构造代理地址\n    export proxy&#x3D;&quot;http:&#x2F;&#x2F;$ip:$port&quot;\n    export http_proxy&#x3D;&quot;$proxy&quot;\n    export https_proxy&#x3D;&quot;$proxy&quot;\n    export ftp_proxy&#x3D;&quot;$proxy&quot;\n    echo &quot;代理已启用：$proxy&quot;\n&#125;\n\n# 禁用代理\nproxy_off() &#123;\n    unset proxy http_proxy https_proxy ftp_proxy\n    echo &quot;代理已禁用&quot;\n&#125;\n\n# 检查代理状态\nproxy_status() &#123;\n    if [ -n &quot;$http_proxy&quot; ]; then\n        echo &quot;当前代理状态：启用 ($http_proxy)&quot;\n    else\n        echo &quot;当前代理状态：未启用&quot;\n    fi\n&#125;\n# 使用方法\nproxy_on # 启用默认代理\nproxy_on your_ip your_port # 启用代理，并指定ip和端口\nproxy_off # 禁用代理\nproxy_status # 查看代理状态\n\n# 或者采用以下手动方式：\nexport proxy&#x3D;&quot;http:&#x2F;&#x2F;xxx.xxx.xxx.xxx:xxxx&quot; # 修改为你的代理地址和端口\nexport http_proxy&#x3D;$proxy\nexport https_proxy&#x3D;$proxy\nexport ftp_proxy&#x3D;$proxy\n\nGit简单使用#GitHub加速\ngit config --global url.&quot;https:&#x2F;&#x2F;gh-proxy.com&#x2F;github.com&#x2F;&quot;.insteadOf &quot;https:&#x2F;&#x2F;github.com&#x2F;&quot;\n\n#Huggingface加速\nexport HF_ENDPOINT&#x3D;https:&#x2F;&#x2F;hf-mirror.com\n\n# Git 常用命令\ngit init # 初始化本地仓库\ngit clone # 克隆远程仓库\ngit add # 添加文件到暂存区\ngit commit # 提交暂存区文件到本地仓库\ngit status # 查看仓库状态\ngit diff # 查看文件差异\ngit log # 查看提交历史\ngit reset # 回退到指定版本\ngit branch # 查看分支\ngit checkout # 切换分支\ngit merge # 合并分支\ngit pull # 拉取远程仓库\ngit push # 推送本地仓库到远程仓库\n\n# 以下为常用指令\n# 需先在GitHub需要建立一个仓库 ，然后用git clone获取.git文件夹，放到你的对应文件夹下，然后开始如下命令\ngit clone\ngit init\ngit add .\ngit commit -m &quot;update&quot;\ngit push -u update main\n# 后面再用就git pull和git push\n# 推荐使用vscode自带的git插件，可以更方便的进行操作\n\nConda安装# 下载最新版 Miniconda (Linux 64位)\ncurl -L -O https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;anaconda&#x2F;miniconda&#x2F;Miniconda3-latest-Linux-x86_64.sh\n# 运行安装脚本\nbash Miniconda3-latest-Linux-x86_64.sh\n# 安装时You can undo this by running &#96;conda init --reverse $SHELL&#96;?\n# 此项必须选择Yes,安装完成后重启终端conda命令才能生效~\n\n# 验证安装\nconda --version\n# 应该显示类似：conda 25.1.1\n\n# 添加清华 conda 源\nconda config --add channels https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;anaconda&#x2F;pkgs&#x2F;free&#x2F;\nconda config --add channels https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;anaconda&#x2F;pkgs&#x2F;main&#x2F;\nconda config --add channels https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;anaconda&#x2F;cloud&#x2F;conda-forge&#x2F;\n# 显示通道URL\nconda config --set show_channel_urls yes\n# 设置 pip 使用清华源\npip config set global.index-url https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple\n\nconda create -n pytorch python&#x3D;3.10 # 创建新环境，指定py版本\nconda remove -n pytorch --all # 移除环境\nconda activate pytorch # 激活环境\nconda deactivate # 退出当前环境\nconda –version # 查看conda版本\nconda list # 查看当前环境下安装的包\nconda env list # 查看当前安装了哪些环境\nconda info --envs # 查看当前安装了哪些环境（这两个命令一样的功能）\nconda export pytorch &gt; conda.yaml # 导出当前环境的配置文件\nconda create -f conda.yaml # 根据配置文件创建环境\n\n代码后台运行\n[NOTE] 按照推荐优先级排序\n\nnohup命令nohup python xx.py &amp; #可以把程序放到后台运行，即便关闭当前终端也不会影响程序的运行。\nnohup python myscript.py &gt; myscript.log 2&gt;&amp;1 &amp; # 如果你想在后台运行python myscript.py并将日志保存到myscript.log，你可以这样做\n\nscreen命令screen -S mysession # 创建一个名为mysession的screen会话\nscreen -r mysession # 恢复名为mysession的screen会话\nscreen -ls # 列出所有screen会话\nscreen -d mysession # 将名为mysession的screen会话放入后台运行\nscreen -X -S mysession quit # 结束名为mysession的screen会话\n\ntmux命令参考：https://blog.csdn.net/weixin_44343319/article/details/126864366\n安装 ubuntu 版本tmux\nsudo apt-get install tmux\n启动 tmux\ntmux new -s roclinux\n创建一个新的窗口，自动创建0：bash\n1. 按Ctrl+B，然后松开\n2. 然后单独按一下C键\n在窗口间切换\n1. 按Ctrl+B，然后松开\n2. 按数字0键\n退出会话后，还能回来\n在tmux 0:bash下面\nwatch -n 2 free 这个命令会每隔2s更新一次内存状态，如果不输出ctrl+c，则永远不会退出\n \n带电脑去开会，电脑要断网，但不想中断服务器上正在执行的watch命令\n1. 按Ctrl+B，然后松开\n2. 输入字母d\ntmux环境会消失，只剩detached提示\n \n恢复联网后，执行\ntmux ls\ntmux a -t roclinux\n此时会恢复状态\ntmux\n\n\nCuda和Cudnn安装参考：https://github.com/Liujian1997/Franka_env-Installation/blob/main/conda%2Bcuda%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE.md\n有sudo权限通常安装在 /usr/local/ 目录下\n\n\n\n\n\n\n\n\n\n以上内容作者：刘健\n","slug":"研究生基本功","date":"2025-04-22T15:25:39.000Z","categories_index":"基本功","tags_index":"基本功,必须会的东西,不会可以remake了,倒也不必,研究生","author_index":"Ausert"},{"id":"e51c6b0cc288c9b94c0f6d165fb0d5e1","title":"selfNotes","content":"以此note介绍LLM有关的trick或者一些信息差的东西。\n\n计算loss的时候记得把padding token屏蔽掉，不然模型学的全是padding token，根本不会输出其他token\n\nLLM的学习率往往很低，不要以为0.0005就已经很小了，如果发现模型收敛到一定的值就不收敛了，试试看减小学习率，让他多训练一会（暴怒）。\n\nLLM的prompt很重要，问题描述不清楚，往往模型的输出没办法align到你想要的输出。\n\n数据集记得分一个dev dataset出来，用来方便开发，不然跑一次train dataset跑半天突然来个报错就老实了\n\n多卡训练模型保存之后，state_dict上会多加一个module标记，这个时候如果想单卡推理，记得module删了，不然dict会对不上。\n\ntransformers库的模型，在生成的时候有generate和chat两个方法，generate是单轮的，chat是多轮对话，注意chat_template。得严格按照模型的template来chat，不然很容易答非所问。此外虽然说LLM是可以多轮对话的，但实际上仍然是线性的，只不过是把history一股脑的给LLM而已，predict next token到结束。查看模型的template可以print(tokenizer.chat_template)查看，不过一般花里胡哨的，瞪眼法看也看不出来啥（\n\n如果发现没有chat方法，那么如何方便的对齐chat_template呢？有两种方法：\n使用transformers库的pipeline:\npipe &#x3D; pipeline(\n    &quot;text-generation&quot;,\n    model&#x3D;modelConfig[&quot;model_name&quot;],\n    tokenizer&#x3D;tokenizer,\n    device_map&#x3D;&quot;cuda:3&quot;,\n)\noutputs &#x3D; pipe(\n    messages,\n    generation_config&#x3D;generation_config,\n)\nres &#x3D; outputs[0][&quot;generated_text&quot;][-1]\nreturn res\n\n使用tokenizer的apply_chat_template，然后将结果tokenize之后，丢给generate方法去生成结果。\n# 定义对话历史\nconversation &#x3D; [\n    &#123;&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: &quot;你好&quot;&#125;,\n    &#123;&quot;role&quot;: &quot;assistant&quot;, &quot;content&quot;: &quot;您好！有什么可以帮您？&quot;&#125;,\n    &#123;&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: &quot;推荐一部科幻电影&quot;&#125;\n]\n\n# 转换为模型需要的格式\nformatted_text &#x3D; tokenizer.apply_chat_template(\n    conversation,\n    tokenize&#x3D;False,          # 返回字符串而不是 tokens\n    add_generation_prompt&#x3D;True  # 添加模型回复引导符\n)\n\ninputs &#x3D; tokenizer(formatted_text, return_tensors&#x3D;&quot;pt&quot;).to(&quot;cuda:3&quot;)\n\n# 生成回复\noutputs &#x3D; model.generate(\n    inputs.input_ids,\n    max_new_tokens&#x3D;500,\n    temperature&#x3D;0.7,\n    top_p&#x3D;0.9\n)\nprint(tokenizer.decode(outputs[0], skip_special_tokens&#x3D;True))\n\n推荐使用pipeline，因为pipeline处理完之后返回的也是对话的列表，方便获取内容，这也是为什么上面代码中return的是[-1]的原因，因为返回最后一条，肯定是AI回答的。\n\npartial方法：使用该方法可以冻结函数中部分参数，产生一个新的函数。\nmt_image_loader &#x3D; partial(load_image, image_dir&#x3D;mt_images_dir)\n\n如上代码中所示，load_image里面是包含两个参数的，一个是sample，一个是image_dir，这里使用partial相当于提前将image_dir这个参数给这个函数了，然后现在mt_image_loader是一个只有一个参数sample的函数了。可以直接给map方法用。\n\n\n","slug":"selfNotes","date":"2025-03-24T03:58:23.871Z","categories_index":"LLM","tags_index":"学习,笔记本,零碎的,知识点,深度学习,大模型,训练","author_index":"Ausert"},{"id":"ce7691ff8f2ef9994a806e6cb0977c21","title":"2024年终总结","content":"一年的时间真的过的很快，转眼间2024年已经行将尾声。现在再回首看向2024年的自己，感觉2024年的自己上下起伏还是很大的。也是自高考失败，插班生失败之后，第一次做成功了一件事。或许在之后，拼尽全力但是考插失败的阴影能够逐渐散去吧。\n这一年间，我都干了点啥呢？保研结算，进到同济大学x上海自主智能无人系统科学中心去读博。感觉真要说的话，也就这么点事情而已，其他我也没干啥了，2024年本来就是保研结算的一年，自然搞的都是保研的事情。之后就是找了同济大学的导师，然后还正好是无人系统科学中心的老师。之后就是提前进组学习的事情了。\n回过头看之前的保研经历的话，突然也感觉好像也没做什么。也就卷卷绩点，打打比赛，之后拿到保研名额之后，准备夏令营的笔试，机试和面试。然后就拿到优营名额，填了同济的直博。这么看也挺流水账的。一段旅途的重点不是终点，而是旅途的过程。从一开始的对于保研懵懂无知，到接触了李桑他们，和计科的那些比我厉害的多的同学交流，再到进了绿群，了解到了更多关于计算机保研的信息，对于保研流程有了整体的，清楚的认识。从一开始对于保研的忐忑不安，对于未知的害怕，到现在的老油条。保研过程中真得感谢他们，帮助我打消了很多的信息差，帮助我了解了很多我以前完全不知道，也完全不懂的事情。如果说大一时候的想要为了自己考插是第一次成长的话，那么保研过程中那就是第二次的成长。在考插过后，我只是有想做什么的想法，但是目标实际上并不具体。在保研过后，这个目标已经具体了，我自己也更加坚定了我想要做什么，我要去做什么，为了我的目标我应该怎么做。这里真的很感谢李桑，在我大学的四年里面是我的引路人，启蒙导师。如果没有李桑，我估计也不会接触到ICPC，也不会认识到计科的那帮大佬，我估计到现在也还是跟着傻子一样阿巴阿巴。\n在保研结束到找到导师的那段时间，其实感觉过的挺空虚的，因为目的达成了，也没啥事情干了，就天天steam启动，一天一天过去，很容易陷入虚无主义的情绪，甚至心理上有点玉玉。因为觉得自己没有做什么有意义的事情，也没有干什么上进的事情。不过提前进组之后，明显感觉好多了，毕竟有事情可干，有目标。\n哦对，要说2024年印象深刻的东西的话，感觉应该就是崩坏：星穹铁道的2.x匹诺康尼剧情和《败犬女主太多了！》这两个了吧。\n匹诺康尼的剧情不愧是烧鸡主笔的剧情，跌宕起伏的剧情当然不用说，其中对于哲学命题的思考，相较于崩坏3第一部鸟为什么会飞（其实是同一个topic），又有了不同的解答。其中对于存在主义和虚无主义的讨论，对于我们人生意义的讨论，相较于崩坏3中的讨论，又有了更深刻的见解，或者说不是更深刻，是另外一种解答。我自己本来就对于哲学命题挺感兴趣的，也时不时的会思考人生意义的问题。这一点上，我和崩坏3，崩坏：星穹铁道还是很契合的，这也是为什么我这么喜欢他们的剧情。他们的剧情有热血，有感动，有对于宏大主题的思考和讨论，也有对于平凡现象的反思和批评，对于人的成长，世界观和价值观的形成有很大的帮助。同时，虽然崩坏系列的剧情经常调侃“很甜”“一点也不刀”，但实际上他是一种很健康阳光，积极向上的剧情，他能够给予人力量，能够让人面对挫折和苦难依旧坚强下去。另外一个就是今年我特别喜欢的一部番了。《败犬女主太多了！》说实话，自大一考插以来，我已经很久没有看新番了，因为感觉考插之后，已经完全没有当年看番的热情了，很多新番一是不想看，二是也没啥时间看。但是败犬这番看了第一集就已经想看第二集了，甚至看完了之后还想去补小说。这部番真的太青春了，他所描绘的高中时光太美好了，美好到与现实世界形成强烈的反差，同时也很明显的能感受到，这就是我当初追的二次元的美好。是的，这番让我想起来我当初追番的初心，亦或是当年看番的感觉——对于二次元美好的追求。虽然说玩mihoyo的游戏也是对于二次元美好的追求，因为他们的剧情很多都是描绘二次元的美好。但看番毕竟和玩米游有区别的。\n2024年要过去了，明年就是2025年了，2025年下半年就要去同济大学读博了。正好五年读博，出来2030年，而2030年是mihoyo计划实现崩坏神域的年份。虽说目前来看想要真的按照SAO里面那样，实现完全潜入式的崩坏神域感觉不太可能。但即便不可能，我们也要为了这个目标去努力。开拓从来不会因为目标难以战胜而停下脚步。包括我自己读博，想要去research也同样是践行开拓的意志，在科研领域上开拓出新的东西，为了崩坏神域，为了人类文明的进步！\n2025年要来了，希望未来的我，不论遭遇怎么样的变故，无论经历了什么事情，都不要忘记自己的初心。成为永远的技术宅，永远的二次元，永远的热爱美好，追求美好。技术宅拯救世界真的很酷！\n2024再见，2025你踏马过来2333。\n\n\n\n\n\n\n\n\n\n tech otakus save the world!\n","slug":"2024年终总结","date":"2024-12-29T15:29:06.724Z","categories_index":"年终总结","tags_index":"年终总结,碎碎念","author_index":"Ausert"},{"id":"615e3f2233f9034a4c7de4aa41e90c29","title":"ML notes","content":"前言ML教材为《机器学习_周志华》\n第一章PAC理论模型PAC(Probably Approximately Correct 概率近似正确) learning model由Leslie Valiant提出。\n$$\\begin{aligned}P(|f(x)-y|\\le \\epsilon )\\ge 1-\\delta\\end{aligned}$$\n基本术语数据集，训练，测试\n示例(instance)，样例(example)——样例就是示例带上label标记，也就是结果的单条数据\n样本(sample)\n属性(attribute)，特征(feature)，属性值——有时候称属性为特征\n属性空间&#x3D;样本空间&#x3D;输入空间\n特征向量——在属性空间中的示例\n标记空间，输出空间\n假设(hypothesis)，真相(ground-truth)，学习器(learner)\n分类——输出结果是离散的，二分类，多分类区别于输出不同结果的数量（比如二分类就好或者坏，多分类则有大中小）。二分类中有术语，正类和反类，正反类不是绝对的，可以交换。\n回归——输出结果是连续的\n监督学习(supervised learning)——有导师的学习，有label的示例作为输入。\n无监督学习(unsupervised learning)——无导师的学习，无label的示例作为输入。也就是区别于数据集中是否已经告诉你示例的label结果。\n未见样本(unseen instance)——未来的数据输入，未知\n未知“分布”——数据背后的规律\n独立同分布(i.i.d)——指样本是由同一个分布中独立的取出来的\n泛化(generalization)——泛化能力指的是模型对新数据的处理能力，是从特殊到一般的过程，也有特化，是一般到特殊的过程。\n归纳偏好表示机器学习算法在学习过程中对某种类型假设的偏好\n任何一个有效的机器学习算法必有其偏好\n判断的一般原则：奥卡姆剃刀(Occam‘s razor)——若非必要，勿增实体，也就是说对于多个模型都能解释一个现象，我们选择一个最简单的即可。\n\n\n\n\n\n\n\n\n\n学习算法的归纳偏好是否与问题本身相匹配，大多数时候直接决定了算法能否取得好的性能。\nNFL定理NFL(No Free Lunch Theorem)定理：一个算法A在某些问题上比算法B好，那么一定存在另外有一些问题B比A好。\nNFL定理的重要前提：所有问题出现的机会相同，所有问题同样重要。然而实际上我们只关注自己正在解决的问题。\n泛化能力泛化误差：在“未来”的样本上的误差\n经验误差：在训练集上的误差，也叫训练误差\n过拟合(overfitting) vs 欠拟合(underfitting) 如下图所示：\n\n上图表示出了，训练误差并不是越小越好。\n模型选择根据三个问题：\n如何获得测试结果？→   评估方法\n关键：怎么获得”测试集”\n常见方法：\n留出法(hold-out)\n也就是将训练数据分一部分出来用来测试。\n需要注意：1.保持数据划分的一致性（分层采样）2.多次重复划分（100次随机划分）3.测试集不能太大也不能太小（例如：1&#x2F;5~1&#x2F;3）\n交叉验证法(cross validation)\n又称k-折(fold)交叉验证法。\n例如10折交叉验证，也就是说将数据集分成10份，首次用前9个训练，第十个用于测试，然后轮转，用第九个测试，其他训练，如此往复，进行十次，得到的十次结果作平均返回。\n为了减少切分的误差，所以分成10份的过程，也还要做10次，也就是要做100次。\n如果k&#x3D;m的话，也就是k等于数据量，则得到”留一法”(leave-one-out,LOO) → 可能会导致测试结果误差较大。\t\n\n自助法(bootstrap)\n基于“自助采样”(bootstrap sampling)，也叫“有放回的采样”，“可重复采样”。也就是说将所有数据看做一个盲盒，每次采样的时候抽取一个，然后放回去，同时再复制一个这个数据。\n缺点：1.训练集和原样本集同规模 2.数据分布有所改变\n 算法的参数：一般由人工设定，也叫“超参数”\n模型的参数：一般由学习确定\n验证集：区别于测试集，主要是用于调整模型参数的。是训练集中的专门用来调参用的。\n如何评估性能优劣？→   性能度量\n 回归任务常用均方误差：\n\n对于分类任务：\n\n\n查准率(precision)：也就是在所有模型找出来的正样例里面，有多少是查对的，确确实实是正样例的。\n查全率(recall)：在所有的正样例中，模型找出来了多少。\nP和R的综合使用：\n\nF1度量其实就是P和R的调和平均数，如果对哪一方有一点偏好的话，假设偏好是beta，那么对应的公式就是下面框起来的那个。\nbeta&gt;1的时候查全率有更大影响，beta&lt;1时查准率有更大的影响\n如何判断实质差别？→   比较检验\n 统计假设检验为学习器性能比较提供了重要依据。\n常用检验方法：1.交叉验证t检验（基于成对t检验）2.McNemar检验（基于列联表，卡方检验）\n线性模型线性模型(linear model)试图学得一个通过属性的线性组合来进行预测的函数。\n\n\n\n\n\n\n\n\n\nf(x) &#x3D; w1x1+w2x2+w3x3+….+b\n向量形式 :  f(x) &#x3D; w^Tx +b\nxi是对应的属性，wi是对应的权重。\n线性回归线性回归(Linear Regression)是要求得以下内容\n\n\n\n\n\n\n\n\n\nf(xi)&#x3D;wxi+b 使得 f(xi) ≈yi\n计算以上内容的关键在于将属性数值化，而对于离散的属性不好数值化，采用如下方法：若有序（order），则可以连续化；否则，转化为k维向量。\n\n\n\n\n\n\n\n\n\n比如，西瓜有青色的这个属性，是离散的属性，不管青色还是蓝色还是绿色，没有明显的序关系，那么就将这个属性置入向量中用0和1来表示。[010]总左到右分别表示是否是青色，蓝色，绿色，其中一个是1，就表示是的。\n对于线性回归想要学到的这个表达式f(xi)&#x3D;wxi+b，如何确定w和b，其实就是衡量f(x)和y的差别，均方误差是回归任务中常用的性能度量，因此我们可以让均方误差最小化，从而确定w和b。(arg min 就是使后面这个式子达到最小值时的变量的取值)\n\n基于均方误差最小化来进行模型求解的方法称为“最小二乘法”，在线性回归中，最小二乘法就是试图找到一条直线，使得所有样本到直线上的欧氏距离之和最小。\n求解w和b使得上图中右式值最小化的过程，称为线性回归模型的最小二乘“参数估计”。事实上，此时就是一个数学问题，对于一个二元函数f(w,b)，让你求f函数的最小值，问你w和b的值。\n多元线性回归对于多元情况，其实就是如下情况：\n\n\n\n\n\n\n\n\n\nf(xi)&#x3D;wTxi+b 使得 f(xi) ≈yi\n其中xi&#x3D;(xi1;xi2;xi3….;xid)   yi属于R\n我们可以将b看作b*1，从而将右式合并为:w‘ * X\n其中w’&#x3D;(w;b)，X&#x3D;(xi;1)，这个这个1是一个全是1的列向量，和xi对齐的。\n类似的，我们使用最小二乘法来求w和b，也就是w’。\n\n令偏导等于0求w’即可，需要用到矩阵求逆。\n如果X^T*X满秩或者正定，则\n如果不满秩，则可以解出来多个w’。此时需要求助于归纳偏好，或者引入正则化（regularization）\n广义线性模型广义线性模型相较于线性模型，其实就是用表达式去逼近y的衍生物，比如逼近lny等等，一般形式如下:\n\n\n\n\n\n\n\n\n\ny &#x3D; g^(-1) (w^T*x + b)\n这个g^(-1)称为单调可微的联系函数(link function)。\n形式上来看，其实就是通过这个联系函数来实现逼近y的衍生物。\n广义线性模型的例子：\n对率回归\n对于实值输出是连续值，但期望输出是离散值的情况，我们需要一个联系函数，从而使用线性回归模型来解决这类问题。常用的函数如下，他单调可微，任意阶可导，被称为对数几率函数，简称“对率函数”\n\n\n\n\n\n\n\n\n\ny&#x3D;1&#x2F;(1+e^(-z))\n对上式进行带入变换，得到\n\n\n\n\n\n\n\n\n\nln(y&#x2F;(1-y)) &#x3D; w^T*x + b\n其中y&#x2F;(1-y)称为几率（odds），反应了x作为正例的可能性。前面加了一个对数，称为“对数几率”(log odds,也叫logit)。对应的回归问题也相应的叫对率回归问题（logistic regression）。这个是分类学习算法。\n线性判别分析线性判别分析(Linear discriminant analysis)，简称LDA。\n基本机器学习算法及其实现线性回归","slug":"ML-notes","date":"2024-01-07T12:27:41.000Z","categories_index":"AI","tags_index":"AI,Python,ML","author_index":"Ausert"},{"id":"f0b9b0e433bb738921b4a846a4505450","title":"Java Notes","content":"序言因课设需要以及工作需要，不得不得开始学java了。\n以下为作为学习java的整体笔记，包括一切有关java的架构或者已经写好的包。\njava版本采用2021年之后的java17。\n因为本身已经学过C&#x2F;C++了，所以对于java基础的内容仅简单的介绍和记笔记，不作过多的解释。\n缩写解释：\n涉及到的java代码，有部分缩写，下面这张表给出缩写和全拼的对应关系。\n\n\n\n缩写\n全拼\n\n\n\nsout\nSystem.out.println\n\n\n暂时不理解的点：接口\njava基础知识基本名词首先需要知道的是java代码是在虚拟机上运行的，而不是像C++那样自己本地跑的。所以java中需要引入虚拟机的概念，也就是JVM\n\n\n\n\n\n\n\n\n\nJVM(Java Virtual Machine): 运行java的虚拟机。\nJDK：JDK开发包，将java代码编译后然后在JVM上运行的一个打包好的工作包。\nJRE：直接使用已经编译好的字节码在JVM上运行的环境，成为JRE。不用过多了解。\n具体关系图可以看下图：\n\n开发环境安装安装的是jdk17。\n使用以下cmd命令查看java版本。\njava -version\n\n我用的是java version “17.0.6”\n然后装IDEA，也就是装IJ，自己装去。\n初始源文件解释运行的代码源文件是在src文件夹下的，代码源文件是新建一个java class文件。\n以上过程就相当于在cpp源文件中创建一个cpp文件，只不过java创建的要是javaclass。（好奇怪啊\n如果想在src中创建多个文件夹，然后将源代码文件放进去，需要在src中创建package，然后在package中创建javaclass文件。\n这里package相当于一般的文件夹。（真的好怪啊\npackage下的源代码文件需要在代码头上标注 package 对应文件名\nout文件存放src中源码编译之后的文件，文件扩展名是.class\n观察一下最基本的java代码：\npublic class Main &#123;\n    public static void main(String[] args) &#123;\n        System.out.println(&quot;Hello world!&quot;);\n    &#125;\n&#125;\n\n代码中的关键字和C++中的是一个意思。\n这里需要知道的是java中一切以类为基本单位，也就是说一个java文件中有且仅有一个class类，并且这个仅存在的类里面，必须要有一个main函数，作为这个类的起点函数。\nMain类是整个java程序的起点，main函数是类的起点。\nmain函数中的参数args和C语言中的一样，是放参数表列的。\n基础语法注释：&#x2F;&#x2F;   &#x2F;**&#x2F; 和C++一样\nTODO功能：在重点文字或者内容前面添加TODO关键词，从而使注释凸出显示，同时在下方工具栏中可以重点显示。类似一个todolist的功能。是IDEA提供的功能。\ne.g:\n&#x2F;&#x2F;114514\n&#x2F;&#x2F; TODO 14514\n&#x2F;&#x2F;141341\n&#x2F;&#x2F;12312\n\nJava数据类型：\n\n数据定义和C++一样。\nbyte：8位\nshort：16位\nint：32位\nlong：64位\nfloat：单精度，32位\ndouble：双精度，64位\n注意到：\nfloat b &#x3D; 1.0; &#x2F;&#x2F;这会报错，因为java中对于1.0这种常量默认认为是双精度的，而double不能复制给float，需要标识1.0的数据类型。\nfloat b &#x3D; 1.0f; &#x2F;&#x2F;如此改正即可。\n\nboolean：取值为true or false。和C++一样。\n有关数据转化的问题：\n值域范围大的数据不可以直接复制给值域小的，会直接报错（C++里面不会报错），反之是允许的。\n强制类型转化方法和C++一样，不过只有以下这种形式的。\nint a &#x3D; (int)b;\nint a &#x3D; int(b);&#x2F;&#x2F;这样是不允许的，java里面没有这种方法。\n\nJava中的运算符：\n绝大部分的运算符和C++中的一样。\n&amp;&amp;和||和C++中一样都是短路运算符。\n不过java中的&amp;,|不仅可以用于一般的位运算，还可以用于逻辑运算。\n作为逻辑运算的时候不是短路运算符。&amp;和|操作的两边的操作数，不可以类型不一致。\ne.g\nboolean | int\n&#x2F;&#x2F;这是不允许的。必须要手动的强制类型转化，java不会提供隐式类型转化\n&#x2F;&#x2F;同时按位取反是用~\n&#x2F;&#x2F;逻辑取反是用!\n\njava中的顺序，循环，分支结构代码操作和c++中一样。\n面向对象基本语法类的定义和使用类的定义和使用大部分和C++一样，只不过用类去定义对象的时候，不像c++那样可以直接用，而是用类名，变量名，然后new一个出来。\nClassName VarName &#x3D; new ClassName();\n\n用这种方式来构建一个对象，他所对应的类就是ClassName。\n并且类内定义貌似没有public和private的定义， 但实际上好像是有的，存疑。\n内存使用分布一共分为三种区域。\n\n\n\n栈\n用于存放方法和变量的空间\n\n\n\n堆\n用于存放对象的空间\n\n\n元空间\n用于存放类的信息的空间\n\n\n其中，堆空间要大于另外两个空间。\n对象的赋值其实是将存放在堆空间的对象的地址赋给变量，所以变量其实是引用了内存中的对象。\n类中属性初始化有一种特殊的对象：**空对象(null)**，没有引用的对象，称之为空对象，又称为关键字对象。\n引用类型变量的默认值就是空对象(null)。\n在类中的变量在未初始化的时候均会有一个默认值。这个默认值和C++中堆空间定义的变量差不多。引用类型变量默认值是null，也就是空对象，其他的和c++中的一样。\n变量的作用域范围和C++同理。\n可变参数当参数表列中，参数数量不确定，但是参数类型都一样的时候，可以使用可变参数。语法如下\nvoid functino(String... a)&#123;\n\tsystem.out.println(a);\n&#125;\n\n使用…来修饰数据类型。来表示可变参数，注意，可变参数只能作为所有参数表列的最后一个参数，如果不是，会引起歧义报错。\n方法传值方式默认传值方式是复制类型的，也就是C++里面一样，都是值传递。\n并且java中只有值传递，没有指针引用啥的。\n当然碰到引用数据类型的时候，其实就是引用传递，String除外。\n事实上，String是因为他在修改的时候会产生一个新的String。\n静态我们把和对象无关，只和类相关的称之为静态。\n只和类相关的属性称之为静态属性。\n只和类相关的方法称之为静态方法。\n静态语法就是在属性或者方法前面添加一个关键字 static\n因为静态和对象无关，只和类相关，所以我们可以不创建对象就可访问静态属性或者方法。\ne.g\nsout(MyClass.a);\nMyClass.func();\n\n\nclass MyClass&#123;\n\tstatic int a&#x3D;1;\n\tstatic void func()&#123;\n\t\tsystem.out.println(&quot;111454&quot;);\n\t&#125;\n&#125;\n\n成员方法可以访问静态属性和静态方法，但是静态方法不可以访问成员属性和成员方法。\n逻辑：静态是类共有的，是在对象创建之前的，成员属性和成员方法是在对象创建之后才产生的，所以才会设置这样的规则。\nBy the way,静态的东西是存放在元空间的（也就是存放类的信息的地方。\n静态代码块静态代码块的语法如下：\nclass myclass&#123;\n\tstatic &#123;\n\t\t&#x2F;&#x2F;静态代码块段\n\t&#125;\n&#125;\n\n其实就是在类里面，用static修饰了一块用大括号括起来的代码段，表示静态代码段。\n静态代码段会在该类被加载的时候自动执行。并且只会执行一遍。\n什么叫做类被加载？其实也就是初次调用类的静态方法的时候或者初次new一个该类的对象的时候，类就会被加载，然后静态代码块就会执行。在这之后，类就是已经被加载过了，静态代码块也不会再次执行了。\n所以静态代码块一般用于类中变量的初始化。同时如果有多段静态代码块，那么在类加载的时候，依次执行。\n逻辑：类的静态代码块其实就相当于对象的构造函数。一个是类加载的时候自动执行，一个是对象创建的时候自动执行。\n当然，如果想在创建对象的时候自动跑一段代码，直接加一段代码块即可，即使上面的东西，去掉static修饰词。\n逻辑：本质上还是就是分清类所拥有的东西和对象所拥有的东西。\n包存放类的容器，说白了就是个文件夹用来存放java文件，而java代码中都是在类里面的，所以包就是一个存放类的容器。\n基本语法: package 包路径 。如果要涉及子包，使用.来访问子包 package pk_father.pk_child。\n一个源文件中只能package至多一次，可以没有，但是有只能一次。同时为了区分类名，包名一般小写。\n包可以区分不同包内的相同名称的类。使用方法如下：\njava.util.Date() Date是java包中的util包中的一个类。\n因此，一般我们在使用类的时候会使用类的全名(包名+类名)\nimport 导入import 主要用于导入包中的类，从而使得在使用的时候不需要加包地址。（有点像使用名字空间，但本质上又不一样）\nimport只能使用在package后，class前。\nimport用法如下：\n&#x2F;&#x2F;导入单个类\nimport java.lang.String; &#x2F;&#x2F;String就是lang包里面的类名\n\n&#x2F;&#x2F;导入整个包里面的所有类 \nimport java.lang.*; &#x2F;&#x2F;用*通配符来表示导入这个包里面的所有类。\n&#x2F;&#x2F;当然事实上lang这个包是不需要手动导入的，JVM已经帮你干了这个事情了。\n\n\n注意：如果import了不同包中的相同名字的类，还是要用包路径来区别的，为了防止歧义。\n构造方法构造方法和C++的构造函数一样的。\n构造方法的运行优先级低于代码块，也就是先代码块都执行完了，才轮到构造方法执行。\n继承继承含义和C++中的继承一样。继承父类只能有一个，但是一个父类可以有多个子类。\n继承采用extends语法，使用例子如下：\nclass Parent&#123;\n\n&#125;\nclass Child extends Parent&#123;\n\n&#125;\n&#x2F;&#x2F;如此Child类就继承了Parent中的成员变量和成员方法，当然构造方法是不继承的。\n\n当父类和子类中存在名称相同的变量的时候，使用super和this关键词来区分开来，使用方法和C++中类似，不强调的时候默认是this。\nsuper.name;&#x2F;&#x2F;super表示父类的这个name变量\nthis.name;&#x2F;&#x2F;this表示当前类的这个name变量\n&#x2F;&#x2F;也就是说super指的是父类的，this指的是当前类的。\n\n创建多个子类的时候，每一个子类创建前都会先构建父类。当然实际上父类对象并不会真的创建，而是调用构造函数之后，将父类参数给子类而已。\n考虑以下这种情况，父类的构造方法需要传参数，但是子类的构造方法不需要传参数：\nclass Parent&#123;\n\tString name;\n\tParent(String s)&#123;\n\t\tname&#x3D;s;\n\t&#125;\n&#125;\nclass Child extends Parent&#123;\n\tChild()&#123;\n\t\tsuper(&quot;4558&quot;);&#x2F;&#x2F;使用super来进行父类的含参构造函数的调用。\n\t&#125;\n&#125;\n\n&#x2F;&#x2F;理解：其实可以将super就理解为父类的类名，从而去理解使用super()来代表父类的构造函数。\n&#x2F;&#x2F;当然一般super是会自动调用的，当父类需要传递参数的时候，才需要自己写。\n\n其实就是子类和父类都有构造函数的时候，子类构造函数中需要调用一下父类的构造函数，用super表示他的父类，如果不带参数，那么JVM就帮你做了这个工作了，不需要自己写。\n多态多态的含义和C++面向对象的多态意思一样。\n方法重载与重写方法重载就是函数重载，和C++一样的。\n方法名一样，但是参数表列不一样，成为方法重载。\n方法重写：指的是子类和父类中都有一个同样名字的，同样参数表列，同样返回值的函数，这个时候相当于子类的这个方法重写了父类的这个方法。\n也就是子类重写了父类的方法，但是并不说明父类方法被覆盖掉了，仍然可以通过使用super方法来使用父类的方法。构造方法是无法重写的（这不废话吗\n递归递归和C++一致，都是函数调用函数自己，同样也会有爆栈的问题。\n访问权限在java的源码中，公共类(public class)只能有一个，而且必须和源码文件名相同。main方法是由JVM调用的，JVM调用的时候应该可以任意调用而不用考虑任何权限问题，所以在公共类的main函数前面需要加上public来进行修饰，以确保JVM调用的时候可以任意调用。main函数前面需要加static修饰，是因为如果不加static，那main函数是一个对象方法，需要构建对象才可以使用，JVM调用的时候无法构建对象，所以需要用static修饰，使之成为类方法，不构建对象也可以使用main方法。\n推理：程序开始的两个函数，一个需要和文件名保持一致，同时是整个源码文件中的唯一公共类，这可能是因为java中的万物皆对象的思想，同时唯一公共类也是作为了该文件的程序入口。而main函数就作为了唯一公共类的程序入口，使用public和static修饰是为了JVM能够不用考虑任何权限或者其他问题的来调用main函数来运行。\nJava中的访问权限一共分为四种：private,public,protected,(default)\n\n\n\n访问权限\n具体内容\n\n\n\nprivate\n私有，只有本类可以只用\n\n\npublic\n公用，全都可以任意使用\n\n\nprotected\n受保护的，本类和子类都可以使用\n\n\n(default)\n缺省默认为default，在本包范围内可以随意使用，但子包是不能访问的\n\n\n内部类外部类：源码中直接声明的类。\n内部类：类中定义的类。\n规定：Java不允许外部类使用private和protected修饰，也就是说只允许public和(default)修饰。\n想要创建一个内部类的对象，需要先创建他外部类的对象，然后再创建内部类的对象，写法上如下：\npublic class Main&#123;\n  public static class main(string[] args)&#123;\n    myclass obj &#x3D; new myclass();\n    &#x2F;&#x2F;然后用obj去创建内部类的对象\n    myclass.childclass obj_child &#x3D; obj.new childclass();\n  &#125;\n&#125;\nclass myclass&#123;\n  class childclass&#123;\n    \n  &#125;\n&#125;\n\n单例模式有套路的java代码编写方式称为代码的设计模式。单例模式就是其中一种。单例模式指通过一些编写方法，使的创建对象的时候永远只会创建一个，如果已经创建过对象，那么再new出来的会是之前创建的对象。一般方法如下：\nclass myclass&#123;\n    private static myclass isNew &#x3D; null;\n\n    private myclass()&#123;\n\n    &#125;\n    public static myclass getInstance()&#123;\n        if(isNew&#x3D;&#x3D;null)&#123;\n            isNew &#x3D; new myclass();\n        &#125;\n        return isNew;\n    &#125; \n&#125;\n\nfinalfinal类似C++中的const\nfinal修饰方法的时候，子类不能重写父类的方法，不可以修饰构造方法。\nfinal修饰类的时候，该类就没有子类了\n抽象抽象概念和C++面向对象一样。\n抽象方法：只有声明，没有实现的方法。\n抽象类：不完整的类就是抽象类。\n需要使用到关键字abstract，如下：\n&#x2F;&#x2F;抽象类\nabstract class A&#123;\n    public abstract void eat();&#x2F;&#x2F;抽象方法\n    &#x2F;&#x2F;此类中有抽象方法，所以他只能是抽象类\n&#125;\n\n接口Java中接口使用interface关键词来声明。使用方法如下：\ninterface Name &#123;\n    &#x2F;&#x2F;规则属性或者方法\n&#125;\n\n接口其实是抽象的，但是其中的规则属性和方法是具体的。\n接口可以理解为一些规则的集合，也可以理解为抽象的类。\n使用示例如下：\n&#x2F;&#x2F;写了三个接口其中USB供能和接受继承自USB接口，Computer实现USBSupply接口。使用的是implements关键词。\ninterface USBInterface()&#123;\n    \n&#125;\ninterface USBSupply()&#123;\n    public void powerSupply();\n&#125;\ninterface USBReceive()&#123;\n    public void powerReceive();\n&#125;\nclass Computer implements USBSupply &#123;\n  \tpublic USBReceive usb1;\n  \tpublic USBReceive usb2;\n    public void powerSupply()&#123;\n        sout(&quot;114514&quot;);\n      \tusb1.powerReceive();\n      \tusb2.powerReceive();\n    &#125;\n&#125;\n\n枚举枚举是一个特殊的类，其中包含了一组特定的对象，这些对象不会发生改变。使用enum关键词使用。\n枚举会将他其中的对象放在最前面。以下为例：\nenum City&#123;\n    BEIJING(&quot;BEIJING&quot;,1001),SHANGHAI(&quot;shanghai&quot;,10002);\n  \tCity(String name, int code)&#123;\n        this.Name&#x3D;name;\n      \tthis.Code&#x3D;code;\n    &#125;\n  String Name;\n  String Code;\n&#125;\n\n从例子中可以看到，BEIJING和SHANGHAI是这个枚举类中的对象，这些对象所对应的类就是City。（感觉还挺抽象的）\n匿名类在某些场合下，类的名字不重要，我们只需要使用类的方法或功能，此时就可以采用特殊的语法：匿名类。所谓的匿名类，就是没有名字的类。用法如下：\npublic class Main &#123;\n    public static void main(String[] args) &#123;\n        Person person &#x3D; new Person()&#123;\n            public String name()&#123;\n                return &quot;Jack&quot;;\n            &#125;\n        &#125;;\n\n    &#125;\n&#125;\n\nabstract class Person&#123;\n    public abstract String name();\n&#125;\n\n抽象类是不能new一个出来的，但是如果new抽象类之后，在之后又加上{}并且重写了抽象方法， 那么相当于这个抽象类已经具体化，从而可以创建对象，但是像这种具体化的抽象类又没有名字，所以叫匿名类。\nbean规范Bean类的设计规范：bean规范。\n\n类要求必须含有无参的公共的构造方法，\n属性私有化，提供公共的set和get方法，\n\n常见类和对象ObjectObject是Java中的默认的类的父类，也就是说，所有没有明确父类的类都是以Object为父类的。Object也一般被称为超类。以下为Object中的常见方法（因为Object是所有类的父类或者间接父类，所以Object中的方法，在所有类中都可以使用。）：\n\ntoString() 方法：将对象转化为字符串。默认打印对象的内存地址，可以自己重写。return String\nhashCode()方法：获取对象的对应hash值，一般用于判断是否相等。return 十进制数字。\nequals()方法：判断两个对象是否相等。默认比较标准是比较内存地址，可以自己重写。return Boolean\ngetClass()方法：获取对象的类型信息。return class&lt;?&gt; 具体查java手册。\n\n数组声明方式：类型[] 变量名; String[] names\n创建方式：类似类的创建。String[] names = new String[SIZE]这里SIZE是数组的大小，需要提前指定，可以是变量值。\n字符串Java中使用ASCII码表示的字符是使用一个字节来表示的，除了ASCII码之外都是用三个字节来表示字符的。\n常用操作：\n\n\n\n方法\n作用\n备注\n\n\n\nconcat(String)\n拼接(concatenate)\n使用+字符串的时候，如果一边不是字符串，另外一边是字符串，那么非字符串会自动转化为字符串。\n\n\nequals(String)\n比较\n两个字符串只有每一位对应的字符相同才相同\n\n\nequalsIgnoreCase(String)\n比较（忽略大小写）\n每一位比较忽略大小写的区别\n\n\ncompareTo(String)\n比较大小\n返回为正，说明调用函数的string大于被比较的string。a.compareTo(b)&gt;0说明a大于b，反之小于。为零则相等。\n\n\nsubstring(beginIndex,endIndex)\n截取子串\n范围左闭右开\n\n\nsubstring(beginIndex)\n截取子串\n从beginIndex开始截取子串到最后\n\n\nsplit(regx)\n分解字符串\n根据regx参数位置给的参数，将源字符串分开，返回string数组\n\n\ntrim()\n去掉首尾空格\n\n\n\nreplace(target,replacement)\n替换内容\n将所有“target”中的内容替换成replacement中的内容\n\n\nreplaceAll(regx,replacement)\n替换内容\n相较于replace单一关键词内容替换，replaceall可以实现多关键词内容替换，不同关键词之间使用|分开。replaceAll(“World|113|eafsji”,”Java”)\n\n\ntoLowerCase()\n内容全部小写化\ntoUpperCase()同理全变大写\n\n\ntoCharArray()\nstring转化为char数组\n返回char数组\n\n\ngetBytes(charsetName)\nstring转化为字节码数组\n返回byte数组,charsetName一般是UTF-8\n\n\ncharAt(index)\n查询第index位的字符\n返回char。提供这个方法的原因是String不能像数组那样使用[]访问。\n\n\nindexOf(String)\n查询子串在源串中的位置\n返回index，返回的是第一次出现的位置。lastIndexOf(String)返回的是最后一次出现的位置。\n\n\ncontains(String)\n是否包含指定字符串\n返回值为Boolean\n\n\nstartsWith(String)\n是否以指定字符串开头\n返回值为Boolean\n\n\nendsWith(String)\n是否以指定字符串结尾\n返回值为Boolean\n\n\nisEmpty()\n是否为空\n空为true，反之为false\n\n\nStringBuilder\nJava中提供的一个比String更加好用的类，使用方法需要自己new一个Stringbuilder出来。StringbBuilder s = new StringBuilder(); 然后对于s可以使用各种操作对其进行增删改查。比如append,toString,length,reverse,insert。并且他的拼接字符串操作不同于String，他不会频繁创建对象，所以操作代价上会比String要小。\n包装类在基本数据类型的基础上进行包装操作的类，从而使得数据操作起来更加方便，这种类成为包装类。基本数据类型和包装类的对应关系如下所示：\nbyte -&gt; Byte    short -&gt;Short     int-&gt;Integer\nlong-&gt;Long     float-&gt;Float       double-&gt;Double\nchar-&gt;Character   boolean-&gt;Boolean\n包装类的使用以Integer为例。\nint i &#x3D; 1;\n&#x2F;&#x2F;将基本数据类型转化为包装类\nInteger ii &#x3D; new Integer(i);&#x2F;&#x2F;现在已经不推荐了\nInteger ii &#x3D; Integer.valueOf(i);&#x2F;&#x2F;静态转换\nInteger ii &#x3D; i; &#x2F;&#x2F;直接复制，本质上就是上面那个东西，JVM帮你做了这个工作而已。称为自动装箱\n&#x2F;&#x2F;包装类转化为基本数据类型\nint i2&#x3D;ii.intValue();&#x2F;&#x2F;其他数据类型函数同理，shortValue等等\nint i2&#x3D;ii;&#x2F;&#x2F;也可以这样，称为自动拆箱\n\n日期类日期类Date。使用Date创建一个对象，直接sout就可以看到当前日期。可以使用SimpleDateFormat类来格式化日期的对象。Java格式化日期格式：\ny(Y) -&gt; year yyyy\nm(M) -&gt; MM: month mm:minute\nd(D) -&gt; dd:一个月中的日期  D:一年中的日期\nh(H) -&gt; h:12进制  HH:24进制\ns(S) -&gt; s:second S:millisecond \n\nSimpleDateFormat的使用方法如下：\nDate d &#x3D; new Date();&#x2F;&#x2F;fetch the current time\n&#x2F;&#x2F;sout d is the result\nSimpleDateFormat time &#x3D; new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss.sss&quot;)&#x2F;&#x2F;parameter is the pattern\n  &#x2F;&#x2F;yyyy MM dd HH mm ss sss are the numbers to be filled in. Other format is user DIY\n String timeRes &#x3D; time.format(d);&#x2F;&#x2F;use SimpleDateFormat&#39;s function to uniform the time based on the pattern user give\n&#x2F;&#x2F;Now timeRes is the uniformed time \nsout(timeRes);\n\n使用SDF（就是SimpleDateFormat，这里简称了）来格式化Date对象，其实就是创建一个SDF对象，自己输入想要的格式，然后使用SDF对象的format方法获得一个结果字符串，这样就能够格式化系统提供的时间了。这是将Date转化为String。\n也可以String转化为Date，当然需要注意格式。使用例子如下:\nString curTime &#x3D; &quot;2024-3-7 12:22:01.111&quot;;\nDate parseTime &#x3D; time.parse(curTime);&#x2F;&#x2F;这里的time还是上面那个\n\n日历类集合Java中的集合是一种容器，用于容纳各种数据的容器。\nArrayList类似c++STL中的vector，创建对象如下所示：\nArrayList&lt;Integer&gt; list &#x3D; new ArrayList&lt;Integer&gt;(10);\n&#x2F;&#x2F;&lt;&gt;可以不带，如果带，里面的数据类型不能是基本数据类型。\n&#x2F;&#x2F;构造函数参数填入数字，即为初始化数组大小。\n\nLinkedList就是链表。\nLinkedList&lt;Integer&gt; list &#x3D; new LinkedList&lt;Integer&gt;();\n&#x2F;&#x2F;使用方法如上，链表不能初始化固定长度\n\n比较器说是说比较器，但其实就是让developer自己重写一下比较器，从而能够自定义线性表的排序方法。java中的比较方法重写比较复杂，需要自己定义一个类，这个类需要去实现Comparator接口，然后再在sort方法里面输入这个类的对象。如下所示：\npublic class Main &#123;\n    public static void main(String[] args) &#123;\n        LinkedList&lt;Integer&gt; list &#x3D; new LinkedList&lt;Integer&gt;();\n        list.add(1);\n        list.add(3);\n        list.add(2);\n        System.out.println(list);\n\n    &#125;\n&#125;\n&#x2F;&#x2F; 类名字无所谓，但是需要继承Comparator接口，并且这个类里面需要重写compare方法。\nclass NumberComparator implements Comparator&lt;Integer&gt; &#123;\n    public int compare(Integer o1, Integer o2) &#123;\n        return o1 - o2;\n      &#x2F;&#x2F;返回值为正,代表升序\n      &#x2F;&#x2F;return o2-o1;\n      &#x2F;&#x2F;返回值为负，代表降序\n    &#125;\n&#125;\n\nHashSet类似于C++STL中的set。是不会含有重复元素的集合，同时里面的数据是有序的，默认升序排列。HashSet不是线程安全的。\nHashSet的使用方法和上面的类差不多。\nHashMap类似C++STL中的map，创建方式同理。\nHashMap&lt;String,Integer&gt; map &#x3D; new HashMap&lt;&gt;();\n\nHashTableHashTable几乎和HashMap一模一样，只不过HashMap是线程不安全的，而Table是线程安全的，在并发操作下，Map会出现问题，而Table不会。\n安卓开发JNI编程JNI（Java Native Interface，Java本地接口），是Java平台中的一个强大特性。应用程序可以通过JNI把C&#x2F;C++代码集成进Java程序中。\nApp页面的创建包含三个步骤：\n\n在layout布局文件里面创建XML文件。设计页面样式。\n创建与XML文件对应的Java代码，用于处理交互逻辑。\n在AndroidManifest.xml文件中注册页面配置。\n\nActivity生命周期\nMediaplayer多媒体播放器，可以播放音频也可以播放视频。\n音频播放示例:\nMediaPlayer mediaPlayer &#x3D; MediaPlayer.create(context, R.raw.your_sound_file);\nif(mediaPlayer !&#x3D; null) &#123;\n    mediaPlayer.setOnCompletionListener(new MediaPlayer.OnCompletionListener() &#123;\n        @Override\n        public void onCompletion(MediaPlayer mp) &#123;\n            &#x2F;&#x2F; 播放结束后的处理\n            mediaPlayer.release();\n        &#125;\n    &#125;);\n    \n    try &#123;\n        mediaPlayer.start();\n    &#125; catch (IllegalStateException e) &#123;\n        e.printStackTrace();\n        &#x2F;&#x2F; 处理异常\n    &#125;\n&#125; else &#123;\n    &#x2F;&#x2F; 处理 MediaPlayer 创建失败的情况\n&#125;\n注意事项[1] java中的类在用一个对象赋值给另外一个对象的时候，都是引用赋值，也就相当于用的是C++里面的&amp;，比如对象B赋值给对象C，C修改内容的时候，你输出B，B里面的内容也会被修改，原理看java基础知识，变量的原理。这里只有String是例外，不遵循这套原则。\n[2]\n","slug":"Java-Notes","date":"2024-01-07T12:21:49.000Z","categories_index":"Java","tags_index":"Java,language,Android Development","author_index":"Ausert"},{"id":"8a327c3785082cab489d4df782f60065","title":"网安notes","content":"网络安全和密码学的笔记绪论\n网络空间安全的CIA三元组：保密性(Confidecial)，完整性(Integrity)，可用性(Available)\n\n后续又有人提出来还需要两个要求（两个A）：真实性(Authenticity)，可审计性(Accountability)\n\n被动攻击：只窃取和利用信息，但是不修改系统资源，分为两个，信息内容泄露和流量分析。\n主动攻击：对数据流的修改或者伪造数据流。可分为四类:伪造，重放，信息修改，拒绝服务\n网络安全：分为通信安全，设备安全。通信安全主要通过网络协议来实现。设备安全通过防火墙，入侵检测软件&#x2F;硬件，入侵防御软件&#x2F;硬件三类安全设备来实现。\n\n密码学分为密码分析学和密码编码学，加密方案成为密码体系或者密码。\n密码方案公开设计原则：密码的安全只能依赖密钥的保密，而不依赖加密算法的保密。\n古典密码学古典密码学主要采用的加密方法就是代替和置换。\n密码分析学——攻击类型\n\n\n攻击类型\n密码攻击者知道的消息\n\n\n\n唯密文攻击(Ciphtext Only Attack)\n加密算法和密文\n\n\n已知明文攻击(Known Plaintext Attack)\n加密算法和部分明密文对\n\n\n选择明文攻击(Chosen Plaintext Attack)\n加密算法和任意选择明文可以知道对应的密文\n\n\n选择密文攻击(Chosen Ciphertext Attack)\n加密算法和任意选择密文可以知道对应的明文\n\n\n选择文本攻击(Chosen Text Attack)\n加密算法和CPA+CCA\n\n\n从上到下，危险程度越来越大，同时攻击者的攻击难度也越来越低。\n凯撒密码采用密钥K，每个字母在字母表上循环往后移动K位为新的字母。\nC&#x3D;E(K,P)&#x3D;(p+K)%26\np&#x3D;D(K,C)&#x3D;(C-K)%26\n单表代替密码将26个字母一一映射到一个26字母全排列的一张表上，其中均为一对一映射。\n攻击方法：利用统计学的方法，分析字母的频率来进行字母代还尝试来破解密文。\n经得起统计分析是现代密码的基本要求\nPlayfair密码是最著名的多字母代替密码，他把明文中的双字母音节作为一个单元并将其转化为密文的”双字母音节”\n该算法基于一个密钥词构成一个5*5的字母矩阵。比如密钥词是monarchy，先将密钥词按照顺序，从左到右，从上到下的填入矩阵，然后将剩下的字母也按照顺序填入。得到以下矩阵图。\n\n\n\nM\nO\nN\nA\nR\n\n\n\nC\nH\nY\nB\nD\n\n\nE\nF\nG\nI&#x2F;J\nK\n\n\nL\nP\nQ\nS\nT\n\n\nU\nV\nW\nX\nZ\n\n\nI和J当成一个字母，因为J出现的频率远低于I。\n加密算法如下：\n\nHill密码（多字母代替密码）该加密算法是将m个连续的明文字母替换成m个密文字母。\n加密方法（m&#x3D;3）如下：\n[$c_1$,$c_2$,$c_3$]&#x3D;[$p_1$,$p_2$,$p_3$] *K mod 26\n其中K为3*3的密钥矩阵:\n\n\n\n$k_{11}$\n$k_{12}$\n$k_{13}$\n\n\n\n$k_{21}$\n$k_{22}$\n$k_{23}$\n\n\n$k_{31}$\n$k_{32}$\n$k_{33}$\n\n\n解密方法：\n$P&#x3D;C*K^{-1} mod 26$\n足以抵抗唯密文攻击，但是不能抵抗已知明文攻击。\n多表代替密码采用多张表来进行置换操作。\nVigenere密码他的代替规则是由26个凯撒密码的代替表组成的。其中每一个代替表是对明文移位0~25次的后得到的代替单表。\n加密算法如下：\n定义明文序列$p&#x3D;p_0,p_1,p_2,…….p_{n-1}$,密钥序列$K&#x3D;k_0,k_1…..k_{m-1}$,密文序列$c&#x3D;c_0,c_1,c_2……c_{n-1}$\n其中$m&lt;n$。\n$C&#x3D;c_0,c_1….c_{n-1}&#x3D;E(K,P)&#x3D;(p_0+k_0)mod26,(p_1+k_1)mod26…..(p_{m-1}+k_{m-1})mod26,(p_{m}+k_0)mod26….$\n加密的一般过程可以表示为：\n$C_i&#x3D;(p_i+k_{i mod m}) mod 26$\n解密的过程和凯撒密码一样，减去即可：\n$C_i&#x3D;(p_i-k_{i mod m}) mod 26$\nVernam密码生成密钥K，二进制的长度和明文一致，然后将二者异或，结果就是密文。\n$C_i&#x3D;p_i \\oplus k_i$\n一次一密一次一密其实是对Vernam密码的优化，他要求每次加密一条信息的时候使用一个密钥K，用完之后便丢弃不用。之后需要的时候再重新生成一个。他是唯一一个具有完善保密机制的密码体制，但实际的时候很少用，因为产生大规模的随机密钥有实际困难，并且存在庞大的密钥分配问题。\n栅栏技术将明文按照对角线的顺序写出来，然后再从左往右，从上到下的写出来，得到密文。\n如下图所示：\n\n\nAES和DES\n中国自己的对称密码标准SM4\n\n公钥密码学\n\n\n","slug":"网安notes","date":"2024-01-02T13:27:36.000Z","categories_index":"网络安全和密码学","tags_index":"学习,网络安全,密码学,期末复习","author_index":"Ausert"},{"id":"5a6c29c310d82ce99bfc421188b80faf","title":"ACM学习笔记day41(懒标记线段树)","content":"带懒标记的线段树实际上的函数就多了一个，pushdown操作。以下为板子：板子题目链接板子中线段树维护的是一段区间的数组的和。懒标记表示的是该节点的子树要加上去的值，不包括他自己。\nstruct node&#123;\n    int l,r;\n    ll sum&#x3D;0;\n    ll add&#x3D;0;\n&#125;;\n\nnode tr[N * 4];\nint a[N];\nint n,m;\n\nvoid pushup(int u)&#123;\n    tr[u].sum&#x3D;tr[u*2].sum+tr[u*2+1ll].sum;  \n&#125;\n\nvoid pushdown(int u)&#123;\n    auto &amp;root &#x3D; tr[u],&amp;left &#x3D; tr[u*2],&amp;right &#x3D; tr[u*2+1ll];\n    if(root.add)&#123;\n        left.add+&#x3D;root.add,left.sum+&#x3D;(ll(left.r-left.l+1))*root.add;\n        right.add+&#x3D;root.add,right.sum+&#x3D;(ll(right.r-right.l+1))*root.add;\n        root.add&#x3D;0;\n    &#125;\n&#125;\n\nvoid build(int u,int l,int r)&#123;\n    tr[u].l&#x3D;l;\n    tr[u].r&#x3D;r;\n    if(l&#x3D;&#x3D;r) return;\n    else&#123;\n        int mid&#x3D;l+r&gt;&gt;1;\n        build(u*2,l,mid);\n        build(u*2+1,mid+1,r);\n    &#125;\n&#125;\n\nvoid modify(int u,int l,int r ,int v)&#123;\n    if(tr[u].l&gt;&#x3D;l&amp;&amp;tr[u].r&lt;&#x3D;r)&#123;\n        tr[u].sum+&#x3D;(ll(tr[u].r-tr[u].l+1))*v;\n        tr[u].add+&#x3D;v;\n    &#125;\n    else&#123;\n        pushdown(u);\n        int mid&#x3D;tr[u].l+tr[u].r&gt;&gt;1;\n        if(l&lt;&#x3D;mid)&#123;\n            modify(u*2,l,r,v);\n        &#125;\n        if(r&gt;mid)&#123;\n            modify(u*2+1,l,r,v);\n        &#125;\n        pushup(u);\n    &#125;\n&#125;\n\nll query(int u,int l,int r)&#123;\n    if(tr[u].l&gt;&#x3D;l&amp;&amp;tr[u].r&lt;&#x3D;r)&#123;\n        return tr[u].sum;\n    &#125;\n    else&#123;\n        pushdown(u);\n        ll res&#x3D;0;\n        int mid&#x3D;tr[u].l+tr[u].r&gt;&gt;1;\n        if(l&lt;&#x3D;mid)&#123;\n            res+&#x3D;query(u*2,l,r);\n        &#125;\n        if(r&gt;mid)&#123;\n            res+&#x3D;query(u*2+1,l,r);\n        &#125;\n        return res;\n    &#125;\n&#125;\n\n\n以下是关于代码的一些解释。\n&#x2F;&#x2F;pushup操作和没有懒标记的线段树一样，都是用孩子节点的信息去更新一下父节点的信息。没有任何变化。\nvoid pushup(int u)&#123;\n    tr[u].sum&#x3D;tr[u*2].sum+tr[u*2+1ll].sum;  \n&#125;\n&#x2F;&#x2F;pushdown操作是懒标记线段树的核心操作。\n&#x2F;&#x2F;他是将父节点的懒标记信息传递下去，传递给他的两个孩子节点，然后自己的当前的懒标记信息清空。\n&#x2F;&#x2F;这里add表示的含义的就是当前节点的子树应该要加上的值。注意这里是所有的值。\n&#x2F;&#x2F;所以之后我们要进行modify和query操作的时候要记得将add信息传递下去。\nvoid pushdown(int u)&#123;\n    auto &amp;root &#x3D; tr[u],&amp;left &#x3D; tr[u*2],&amp;right &#x3D; tr[u*2+1ll]; &#x2F;&#x2F;这里为了方便起见，用root表示当前u的这个节点，left表示他的左孩子，right表示他的右孩子。\n    if(root.add)&#123; &#x2F;&#x2F;如果当前这个节点的add不为零，也就是有需要传递下去的信息，那就进行传递操作。\n        left.add+&#x3D;root.add,left.sum+&#x3D;(ll(left.r-left.l+1))*root.add; &#x2F;&#x2F;在这题求区间和的情景下，左右孩子的add要加上传递下的信息add，然后他自己要每一个都要加上add值，因为是区间中每一个元素。\n        right.add+&#x3D;root.add,right.sum+&#x3D;(ll(right.r-right.l+1))*root.add;\n        root.add&#x3D;0; &#x2F;&#x2F;别忘了让root的add值清零。\n    &#125;\n&#125;\n&#x2F;&#x2F;线段树的构建过程。可以和无懒标记的构建过程一样，也可以在有初始值的时候，稍微做一下修改就可以了。这里板子放的是初始化全部为零的，线段树。\nvoid build(int u,int l,int r)&#123;\n    tr[u].l&#x3D;l;\n    tr[u].r&#x3D;r;\n    if(l&#x3D;&#x3D;r) return;\n    else&#123;\n        int mid&#x3D;l+r&gt;&gt;1;\n        build(u*2,l,mid);\n        build(u*2+1,mid+1,r);\n    &#125;\n&#125;\n&#x2F;&#x2F;自带初始化值的线段树的构建过程。\nvoid build2(int u,int l,int r)&#123;\n    tr[u].l&#x3D;l;\n    tr[u].r&#x3D;r;\n    if(l&#x3D;&#x3D;r)&#123;\n        tr[u].sum&#x3D;a[r]; &#x2F;&#x2F;实际上就是在区间长度为1的时候，初始化一下tr的值\n        &#x2F;&#x2F;这里其实要记得让tr[u].add都为零的，但是因为在结构体中我已经写了，所以这里就不需要写了。\n        return;\n    &#125;\n    else&#123;\n        int mid&#x3D;l+r&gt;&gt;1;\n        build(u*2,l,mid);\n        build(u*2+1,mid+1,r); \n        pushup(u);&#x2F;&#x2F;然后利用pushup操作，根据孩子节点的值，去计算父节点的值。\n    &#125;\n&#125;\n&#x2F;&#x2F;修改操作，支持区间修改。\nvoid modify(int u,int l,int r ,int v)&#123;\n    if(tr[u].l&gt;&#x3D;l&amp;&amp;tr[u].r&lt;&#x3D;r)&#123; &#x2F;&#x2F;如果要修改的区间已经完全包含了当前segment的区间，那么直接改这个节点的值就可以了。\n        tr[u].sum+&#x3D;(ll(tr[u].r-tr[u].l+1))*v; &#x2F;&#x2F;当前节点的值可以直接修改，但是要记住add也要加上这个v，因为我们修改的是当前节点的sum值，理论上他的子树的sum都要修改的。\n        tr[u].add+&#x3D;v;\n    &#125;\n    else&#123;\n        &#x2F;&#x2F;因为当前节点的区间和l，r只是部分相交，那么就要涉及讨论是哪一部分相交了，从而递归下去。\n        &#x2F;&#x2F;这里一定要记得在分裂之前，也就是要分开递归之前，一定要将当前节点的懒标记信息传递下去，也就是pushdown一次。\n        &#x2F;&#x2F;因为当前add 表示的是当前节点的所有值都要加上一个add，如果不传递下去，此时要修改的l到r区间只是和当前segment部分相交，那么也就是部分元素要加上v值，会和add表达的意思冲突，所以我们必须先将add信息传递给两个孩子\n        &#x2F;&#x2F;传递完之后，在进行分裂的操作，看是否和左孩子有交集，看是否和右孩子有交集，如果有，那就修改左孩子，右孩子。\n        pushdown(u);\n        int mid&#x3D;tr[u].l+tr[u].r&gt;&gt;1;\n        if(l&lt;&#x3D;mid)&#123;\n            modify(u*2,l,r,v);\n        &#125;\n        if(r&gt;mid)&#123;\n            modify(u*2+1,l,r,v);\n        &#125;\n        pushup(u); &#x2F;&#x2F;结束的时候别忘了要pushup一下，因为更新了最下面节点的值，要更新一下他父节点的值。\n    &#125;\n&#125;\n &#x2F;&#x2F;询问操作其实和没有懒标记的差不多，只不过就多了一个要记得将add信息传递下去就是了。\nll query(int u,int l,int r)&#123;\n    if(tr[u].l&gt;&#x3D;l&amp;&amp;tr[u].r&lt;&#x3D;r)&#123; &#x2F;&#x2F;如果已经包含了当前节点的区间，那么直接返回sum值就可以了。\n        return tr[u].sum;\n    &#125;\n    else&#123;\n        pushdown(u); &#x2F;&#x2F;分裂前要记得将懒标记信息传递下去，所以要pushdown一次。\n        ll res&#x3D;0;\n        int mid&#x3D;tr[u].l+tr[u].r&gt;&gt;1; &#x2F;&#x2F;和之前的类似，分开讨论，左右区间。\n        if(l&lt;&#x3D;mid)&#123;\n            res+&#x3D;query(u*2,l,r);\n        &#125;\n        if(r&gt;mid)&#123;\n            res+&#x3D;query(u*2+1,l,r);\n        &#125;\n        return res;\n    &#125;\n&#125;\n\n这就是懒标记线段树的一个板子，实际题目中，还是得根据题目要求，自己选择懒标记所带的信息。\n","slug":"ACM学习笔记day41","date":"2023-08-27T07:57:57.000Z","categories_index":"ACM","tags_index":"ACM,数据结构,线段树,板子,懒标记","author_index":"Ausert"},{"id":"f730cb1c16c6cae11f6020e8c15e8535","title":"ACM学习笔记day40(无懒标记线段树)","content":"不带懒标记的线段树的板子。注意代码中节点属性是区间的最大值。下面为代码：\nstruct node&#123;\n    int l,r;\n    int maxnum; \n&#125;;\nnode tree[N*4];\n\nvoid pushup(int u)&#123;\n    tree[u].maxnum&#x3D;max(tree[u*2].maxnum,tree[u*2+1].maxnum);\n&#125;\n\nvoid build(int u,int l,int r)&#123;\n    tree[u].l&#x3D;l,tree[u].r&#x3D;r;\n    if(l&#x3D;&#x3D;r) return;\n    else&#123;\n        int mid&#x3D;(l+r)&#x2F;2;\n        build(u*2,l,mid),build(u*2+1,mid+1,r); \n    &#125; \n&#125;\n\nvoid modify(int u,int x,int v)&#123;\n    if(x&#x3D;&#x3D;tree[u].l&amp;&amp;x&#x3D;&#x3D;tree[u].r)&#123;\n        tree[u].maxnum&#x3D;v;\n    &#125;  \n    else&#123;\n        int mid&#x3D;tree[u].l+tree[u].r&gt;&gt;1;\n        if(x&lt;&#x3D;mid)&#123;\n            modify(u*2,x,v);\n        &#125;\n        else&#123;\n            modify(u*2+1,x,v);\n        &#125;\n        pushup(u);\n    &#125;\n&#125;\n\nint query(int u,int l,int r)&#123;\n    if(tree[u].l&gt;&#x3D;l&amp;&amp;tree[u].r&lt;&#x3D;r)&#123;\n        return tree[u].maxnum;\n    &#125;\n    else&#123;\n        int res&#x3D;0;\n        int mid&#x3D;(tree[u].l+tree[u].r)&#x2F;2;\n        if(l&lt;&#x3D;mid)&#123;\n            res&#x3D;query(u*2,l,r);\n        &#125;\n        if(r&gt;mid)&#123;\n            res&#x3D;max(res,query(u*2+1,l,r));\n        &#125;\n        return res;\n    &#125;\n&#125;\n\n\n以下是对于代码的一些解释。来辅助回忆和复习。\n线段树构造了如下的一个二叉树结构，节点上的值由题目需要会任意改变。\n\n其实就是将一个数组按照区间分成了很多段，然后构建成了二叉树的形式。节点在编号的时候是按照完全二叉树去编号的，而且除了最后一层，这个树就是一个完全二叉树，所以假设一个节点是u，那么他的左孩子节点就是2*u，右孩子就是2*u+1。普通的线段树一共有四种操作。分别是build——构建操作，pushup——用子节点去更新父节点的操作，modify——单点修改，query——区间查询。因为不涉及区间修改，所以他不是懒标记线段树。\n一些注意事项：\n\n线段树的数组长度一般要开4*n的长度，n为输入的数据量。\n线段树的查询，修改操作都是logn级别的，不过会带一个常数4，也就是说时间复杂度是O(4logn)。\n\n&#x2F;&#x2F;build操作是将一个数组构建成一个线段树的过程。\nvoid build(int u,int l,int r)&#123; &#x2F;&#x2F;u是当前在哪个节点，l和r是在数据数组中的区间左右边界。\n    tree[u].l&#x3D;l,tree[u].r&#x3D;r; &#x2F;&#x2F;将当前节点的左右边界更改为l和r\n    if(l&#x3D;&#x3D;r) return; &#x2F;&#x2F;如果r已经等于l了，相当于就一个元素了，那就直接返回。\n    else&#123;\n        int mid&#x3D;(l+r)&#x2F;2;\n        build(u*2,l,mid),build(u*2+1,mid+1,r);  &#x2F;&#x2F;递归的处理左孩子和右孩子。分别分给他们一半的区间长度。\n    &#125; \n&#125;\n\n&#x2F;&#x2F;pushup操作是根据孩子节点的信息来更新一下父节点的信息的操作。\nvoid pushup(int u)&#123;\n    tree[u].maxnum&#x3D;max(tree[u*2].maxnum,tree[u*2+1].maxnum); &#x2F;&#x2F;u代表当前节点，根据实际的含义进行更新即可。\n&#125;\n\n&#x2F;&#x2F;单点修改的操作的关键就在于找到我们修改的这个点，在线段树上的位置在哪里，修改完值之后，回溯的过程中用pushup更新父节点的值就可以了。\nvoid modify(int u,int x,int v)&#123; &#x2F;&#x2F;u代表是当前在哪个节点上，x代表修改值的这个点在数据数组中的位置，v代表修改后的值。\n    if(x&#x3D;&#x3D;tree[u].l&amp;&amp;x&#x3D;&#x3D;tree[u].r)&#123; &#x2F;&#x2F;如果已经找到了，直接修改就可以了。\n        tree[u].maxnum&#x3D;v;\n    &#125;  \n    else&#123;\n        int mid&#x3D;tree[u].l+tree[u].r&gt;&gt;1; &#x2F;&#x2F;去左右孩子分别查找，x是不是在左右孩子的区间里面，如果是就递归到对应孩子里面去。\n        if(x&lt;&#x3D;mid)&#123;\n            modify(u*2,x,v);\n        &#125;\n        else&#123;\n            modify(u*2+1,x,v);\n        &#125;\n        pushup(u); &#x2F;&#x2F;递归完之后要记得用pushup操作更新一下父节点的信息。\n    &#125;\n&#125;\n\n&#x2F;&#x2F;查询操作就是查询任意区间的他的value值。\nint query(int u,int l,int r)&#123; &#x2F;&#x2F;u代表当前的节点，l和r代表查询的数据数组的区间。\n    if(tree[u].l&gt;&#x3D;l&amp;&amp;tree[u].r&lt;&#x3D;r)&#123;\n        return tree[u].maxnum; &#x2F;&#x2F;如果当前节点的区间已经完全在l和r之间的话，直接返回当前节点的值就可以了。\n    &#125;\n    else&#123;\n        &#x2F;&#x2F;不然的话，那就是l和r和当前节点的区间是部分有交集的。我们就要判断是否和左右孩子还有交集。\n        &#x2F;&#x2F;如果还有交集，那么就递归的query左孩子这个区间，对于右孩子同理，如果没有交集，那就不用处理了已经，最终将结果整合即可。\n        int res&#x3D;0;\n        int mid&#x3D;(tree[u].l+tree[u].r)&#x2F;2; \n        if(l&lt;&#x3D;mid)&#123;\n            res&#x3D;query(u*2,l,r);\n        &#125;\n        if(r&gt;mid)&#123;\n            res&#x3D;max(res,query(u*2+1,l,r));\n        &#125;\n        return res;\n    &#125;\n&#125;\n\n\n线段树的使用并不局限于板子中的提供的区间最大值，题目中根据题目的需要需要自己设计线段树各节点的属性。无论如何，需要确保的是，设计的属性，一定得是父节点的属性可以由孩子节点得出来的。也就是说pushup操作是能实现的。下一篇就是懒标记的线段树了，支持区间修改的线段树，多了一个pushdown的操作。\n","slug":"ACM学习笔记day40","date":"2023-08-26T14:16:45.000Z","categories_index":"ACM","tags_index":"ACM,数据结构,线段树,板子","author_index":"Ausert"},{"id":"f37560f9bc1b5fea2432f5534d910cca","title":"扩展欧几里得2（exgcd的最小正整数解，通解）","content":"由exgcd我们可以得到如下式子的一对解，前提是有解。ax+by&#x3D;c; (c%gcd(a,b)&#x3D;&#x3D;0)设一组解为x1,y1;即ax1+by1&#x3D;c;\n记 u &#x3D; a*b&#x2F;gcd(a,b);\n\n\n\n\n\n\n\n\n\n通解为:x&#x3D;x1+u&#x2F;a*t,y&#x3D;y1-u&#x2F;b*t;t&#x3D;…..-3,-2,-1,0,1,2,3…\n最小正整数解为：\n\n\n\n\n\n\n\n\n\nx&#x3D;(x1%(u&#x2F;a)+u&#x2F;a)%(u&#x2F;a);y&#x3D;(c-a*x1)&#x2F;b;\n注意，这里是x是最小的正整数解。\n如果要y是最小的正整数解：\n\n\n\n\n\n\n\n\n\ny&#x3D;(y1%(u&#x2F;b+u&#x2F;b)%(u&#x2F;b))x&#x3D;(c-b*y1)&#x2F;a;\n","slug":"扩展欧几里得2","date":"2023-07-19T13:53:28.000Z","categories_index":"ACM","tags_index":"ACM,exgcd,最小正整数解,通解","author_index":"Ausert"},{"id":"7710f88b0aefcb65b0ee353b8ff291a3","title":"ACM学习笔记day39(树状数组)","content":"树状数组的板子。\n有几个小结论需要记住。\n\n\n\n\n\n\n\n\n\n\n每个结点t[x]保存以x为根的子树中叶结点值的和\n每个结点覆盖的长度为lowbit(x)\nt[x]结点的父结点为t[x + lowbit(x)]\n树的深度为log2n+1\n\n理解树状数组的图为:\n\nlowbit操作：\n\nint lowbit(int x)&#123;\n\treturn x &amp; -x;\n&#125;\n\nadd操作（其实也就是modity操作)：\n\nvoid add(int x, int d)&#123;\n\tfor(int i&#x3D;x;i&lt;&#x3D;n;i+&#x3D;lowbit(i))&#123;\n\t\ttree[i]+&#x3D;d;\n\t&#125;\n&#125;\n\nquery操作（查询从第一个到第x个所有的前缀和是多少）：\n\nint query(int x)&#123;\n\tint res&#x3D;0;\n\tfor(int i&#x3D;x;i;i-&#x3D;lowbit(i))&#123;\n\t\tres+&#x3D;tree[i];\n\t&#125;\n\treturn res;\n&#125;\n\n树状数组就这两个操作，一个查询，一个修改里面数值，时间复杂度都是logn级别的。\n","slug":"ACM学习笔记day39","date":"2023-07-18T14:56:43.000Z","categories_index":"ACM","tags_index":"数据结构,binary index tree,树状数组","author_index":"Ausert"},{"id":"aade77e076015616546b7ec40503f52f","title":"ACM学习笔记day38(最小生成树,染色法判定二分图，匈牙利算法)","content":"在总结了各种的最短路算法之后，我们终于也是迎来了，图论基础算法的最后一部分内容。一个是最小生成树的求法。一个是有关二分图的问题。\n\n\n关于这部分的内容，可以看下面这个大致的思维导图。\n\n最小生成树对于基础的图论。最小生成树一共有两种算法。一种是prim算法，一种就是kruskal算法。\nPrim算法Prim算法的思想就是，我们随便的选择一个点，作为我们的起始节点然后我们去选择一条最短的以这个节点为一头的边。作为最小生成树的一条边。然后我们选了这个节点和之前的起始节点，这部分节点所组成的一个集合，我们给他一个名字，就叫做连通块。接下来我们重复这个过程，我们再去寻找一个节点，使的他到我们目前连通块的距离最短，然后将这个节点加入到我们的连通块中去。如此往复，进行n次循环。我们就结束了这样的一个过程。其实我们可以发现，我们每一次的循环，都可以确定一个节点那么n次循环之后，我们就可以确定n个节点，那么也就相当于最小生成树要求的n个节点的要求已经满足了。这里有一个问题，我们怎么才能知道节点到目前连通块的距离。这个其实很简单，我们使用dist数组来记录就行了，只不过我们每次在选完点的时候，需要用这个点去更新一下其他点到该连通块的距离。\n其实稍微理一下prim算法的思路的话，我们会发现，他的算法步骤其实和dijkstra很像。都是n次循环，然后找一个距离最近的，然后用我们选出来的这个点，去更新所有的距离。当然，prim算法这里的，这个dist表示的含义是，该节点到目前的这个连通块的距离所以我们到时候去更新dist值的时候，要注意是直接取min值，而不是累加上去，不是求最短路！！！\n对了，最小生成树是有可能不存在的，什么时候不存在呢？就是原来的图他不是连通图的时候，这样，最小生成树就一定是不存在的，毕竟没办法最小生成树他的基本要求。\n在程序里面就体现为什么呢？就是我们枚举所有到连通块距离最近的点，发现他的距离是无穷，也就是不可达，这个时候说明剩下来的点，都是不可达目前的这个节点的也就说明，他不是连通图，是不存在最小生成树的。\n题目链接\n算法的时间复杂度为O(n^2)\nac code:\n#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nconst int N &#x3D; 510;\nint a[N][N];\nint n,m;\nint dist[N];\nbool st[N];\nint res;\n\nbool prim()&#123;\n    memset(dist,0x3f3f3f3f,sizeof dist);\n  \n    dist[1]&#x3D;0;\n    for(int i&#x3D;0;i&lt;n;i++)&#123;\n        int t&#x3D;-1;\n        for(int j&#x3D;1;j&lt;&#x3D;n;j++)&#123;\n            if(!st[j]&amp;&amp;(t&#x3D;&#x3D;-1||dist[j]&lt;dist[t]))&#123;\n                t&#x3D;j;\n            &#125;\n        &#125;\n        if(i&amp;&amp;dist[t]&#x3D;&#x3D;0x3f3f3f3f) return false; &#x2F;&#x2F;如果此时dist[t]的值为无穷，并且已经选了一个节点的情况下，说明不是连通图。\n        st[t]&#x3D;true;\n        if(i) res+&#x3D;dist[t];\n        for(int j&#x3D;1;j&lt;&#x3D;n;j++)&#123;\n            if(!st[j])&#123;\n                dist[j]&#x3D;min(dist[j],a[t][j]);\n            &#125;\n        &#125;\n    &#125;  \n  \n    return true;\n&#125;\n\nint main()&#123;\n    cin&gt;&gt;n&gt;&gt;m;\n    memset(a,0x3f3f3f3f,sizeof a);\n    while(m--)&#123;\n        int x,y,z;\n        cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;\n        a[x][y]&#x3D;min(a[x][y],z);\n        a[y][x]&#x3D;min(a[y][x],z);\n    &#125;\n    if(prim())&#123;\n        cout&lt;&lt;res&lt;&lt;endl;\n    &#125;\n    else&#123;\n        cout&lt;&lt;&quot;impossible&quot;&lt;&lt;endl;\n    &#125;\n  \n    return 0;\n&#125;\n\n看到这里，或许你应该会有一个问题，如果说我们采用这种方法来生成最小生成树的话，会不会产生环？首先，可以肯定是，思考到这个问题，肯定是好的、那么，答案肯定是显然的，不会产生环。比如说我们要选出来一个三个点的，三条边的环。但是我们这个算法，选择的过程是这样的，我们先选择一个点，然后选择一个距离这个连通块最近的点然后重复这个过程，也就是说，我们对于这个三个点，实际上我们只会选到两条边，显然，两条边无论如何都不能形成环。那么对于其他的情况也是类似的。选不到环的原因就是，在我们快要选到环的时候，那最后一条可以让连通块中形成环的那条边是绝对选不到的。因为那条边的两个顶点，已经被加入到连通块中了。而连通块中的点，是不是被二次选中的。那么因此，我们这个算法在运行的过程中，也是不会形成环的。\nkruskal算法kruskal算法的思想就比较简单了。我们对于图中的每一条边，每次去选择没有选过的，同时权值是最小的边，但是要确保我们选出来的边不能形成环。这就是Kruskal算法，思想很简单。是线上需要用点之前的内容。我们每次要选择权值最小的边，这个很简单，我们可以使用堆，来快速的得出，或者直接对边排序即可。那么如何确保我们选出来的边没有形成环呢？这个我们可以通过并查集来判断。我们定义，p[i]数组，其中p的值代表和当前i节点在一个连通块中的节点。也就是说，一个连通块中的节点，他们是在一个并查集里面的，也就是p数组的值是相同的。我们发现，其实我们要判断一条边的加入会不会形成环，其实就是判断，这条边的两个端点是不是在一个连通块内。如果在一个连通块内，那么很显然，加入这条边，就会形成环。如果不在一个连通块内，那么加入这条边一定不会形成环。这个两句话还是要好好理解一下的。好，那么至此我们的问题其实已经解决了。就是存储所有的边，然后，取最小的边，作为树的边，注意不要产生环就是了。\n题目链接\n这个算法的时间复杂度为O(mlogm)主要还是因为快排导致速度变慢的。\nac code:\n#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nconst int N &#x3D; 2e5+10,M&#x3D;1e5+10;\nstruct Edge&#123;\n    int u,v,w;\n&#125; Edges[N];\nint n,m;\nint res;\nint p[M];\n\nbool cmp(Edge a,Edge b)&#123;\n    return a.w&lt;b.w;\n&#125;\n\nint find(int x)&#123;\n    if(p[x]!&#x3D;x)&#123;\n        int t&#x3D; find(p[x]);\n        p[x]&#x3D;t;\n    &#125;\n    return p[x];\n&#125;\n\nbool kruskal()&#123;\n    int cnt&#x3D;0;\n    for(int i&#x3D;0;i&lt;m;i++)&#123;\n        int a&#x3D;Edges[i].u,b&#x3D;Edges[i].v,c&#x3D;Edges[i].w;\n        if(find(a)&#x3D;&#x3D;find(b))&#123;\n            continue;\n        &#125;\n        else&#123;\n            cnt++;\n            res+&#x3D;c;\n            p[find(b)]&#x3D;find(a);\n        &#125;\n    &#125;\n    if(cnt&#x3D;&#x3D;n-1)&#123;\n        return true;\n    &#125;\n    else&#123;\n        return false;\n    &#125;\n&#125;\nint main()&#123;\n    cin&gt;&gt;n&gt;&gt;m;\n    for(int i&#x3D;0;i&lt;m;i++)&#123;\n        int u,v,w;\n        cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;\n        Edges[i]&#x3D;&#123;u,v,w&#125;;\n    &#125;\n    for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;\n        p[i]&#x3D;i;\n    &#125;\n    sort(Edges,Edges+m,cmp);\n    if(kruskal())&#123;\n        cout&lt;&lt;res&lt;&lt;endl;\n    &#125;\n    else&#123;\n        cout&lt;&lt;&quot;impossible&quot;&lt;&lt;endl;\n    &#125;\n  \n    return 0;\n&#125;\n\n二分图问题我们首先需要知道什么是二分图。\n一个图是二分图当且仅当这个图的点集可以划分为两个集合，使的对于图中的每一条边，两个端点分别处在这两个集合中，而不是在一个集合中。这样的图，就成为二分图。\n染色法判定二分图我们从定义出发，我们发现每一条边，两个端点都是处于不同的集合中的。而且这个集合，只有两个。染色法的思想就是，我们不妨设一个集合的颜色会红色，一个集合的颜色为蓝色。然后我们去对节点染色，因为要满足二分图的条件，所以任意的一条边两个端点的颜色必须是一个是红色一个是蓝色。那么对于这个涂色的过程，我们可以使用dfs也可以使用bfs来进行。如果我们顺利的完成了涂色的过程，那么这个图就是第一个二分图。如果在涂色中，发现有一条边的两个节点是同一个颜色的话，就说明他不是二分图。\n题目链接\n这个算法的时间复杂度为O(n+m)\nbfs 做法：\n#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nconst int N &#x3D; 1e5+10,M&#x3D;2e5+10;\nint h[N],e[M],ne[M],idx;\nint color[N];\nint n,m;\n\nvoid add(int a,int b)&#123;\n    e[idx]&#x3D;b,ne[idx]&#x3D;h[a],h[a]&#x3D;idx++;\n&#125;\n\nbool bfs()&#123;\n  \n    for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;\n        if(!color[i])&#123;\n            color[i]&#x3D;1;\n            queue&lt;int&gt; work;\n            work.push(i);\n            while(work.size())&#123;\n                int t&#x3D; work.front();\n                work.pop();\n                for(int j&#x3D;h[t];j!&#x3D;-1;j&#x3D;ne[j])&#123;\n                    int k&#x3D;e[j];\n                    if(!color[k])&#123;\n                        color[k]&#x3D;3-color[t];\n                        work.push(k);\n                    &#125;\n                    else if(color[k]&#x3D;&#x3D;color[t])&#123;\n                        return false;   \n                    &#125;\n                &#125;\n            &#125;\n        &#125;  \n    &#125;\n    return true;\n&#125;\n\nint main()&#123;\n    cin&gt;&gt;n&gt;&gt;m;\n    memset(h,-1,sizeof h);\n    for(int i&#x3D;0;i&lt;m;i++)&#123;\n        int a,b;\n        cin&gt;&gt;a&gt;&gt;b;\n        add(a,b),add(b,a);\n    &#125;\n    if(bfs())&#123;\n        cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl;\n    &#125;\n    else&#123;\n        cout&lt;&lt;&quot;No&quot;&lt;&lt;endl;\n    &#125;\n    return 0;\n&#125;\n\ndfs传递的第一个参数节点，第二个参数是该节点应该被涂成什么颜色dfs做法：\n#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nconst int N &#x3D; 1e5+10,M&#x3D;2e5+10;\nint h[N],e[M],ne[M],idx;\nint color[N];\nint n,m;\n\nvoid add(int a,int b)&#123;\n    e[idx]&#x3D;b,ne[idx]&#x3D;h[a],h[a]&#x3D;idx++;\n&#125;\n\nbool dfs(int u,int c)&#123;\n    color[u]&#x3D;c;\n    for(int i&#x3D;h[u];i!&#x3D;-1;i&#x3D;ne[i])&#123;\n        int j&#x3D;e[i];\n        if(!color[j])&#123;\n            if(!dfs(j,3-c)) return false;\n        &#125;\n        else if(color[j]&#x3D;&#x3D;color[u])&#123;\n            return false;\n        &#125;\n    &#125;\n  \n    return true;\n&#125;\n\nint main()&#123;\n    cin&gt;&gt;n&gt;&gt;m;\n    memset(h,-1,sizeof h);\n    for(int i&#x3D;0;i&lt;m;i++)&#123;\n        int a,b;\n        cin&gt;&gt;a&gt;&gt;b;\n        add(a,b),add(b,a);\n    &#125;\n    bool res&#x3D;true;\n    for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;\n        if(!color[i])&#123;\n            if(!dfs(i,1))&#123;\n                res&#x3D;false;\n            &#125;\n        &#125;\n    &#125;\n    if(res) cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl;\n    else cout&lt;&lt;&quot;No&quot;&lt;&lt;endl;\n    return 0;\n&#125;\n\n二分图的最大匹配在进行这一节之前，我们需要先知道两个概念二分图的匹配和二分图的最大匹配。\n\n\n\n\n\n\n\n\n\n二分图的匹配：给定一个二分图 G，在 G的一个子图 M中，M的边集{E}中的任意两条边都不依附于同一个顶点，则称M是一个匹配。二分图的最大匹配：所有匹配中包含边数最多的一组匹配被称为二分图的最大匹配，其边数即为最大匹配数。\n对于二分图的最大匹配问题，我们采用的算法就是匈牙利算法。\n题目链接\n先看一下题目。我们这里为了方便理解。采用一个纳西妲般的比喻来看待这道题。给定一个二分图，分为左右两半部分。我们将这个左右两半部分理解为，左边的是男生，右边的是女生。我们将两个节点之间的连线理解为男生和女生有暗恋关系。然后我们就是那个月老，我们要去牵线。但是恋爱要忠诚对吧，任何一个人都不能脚踏多只船。也就是我们这里二分图的匹配的要求。那么我们应该怎么连线，来使的情侣数最多。其实，我们可以这么看。我们只看左边男生的。（当然也可以只看女生的，一样的）我们遍历过去男生的，看他有没有和谁有暗恋关系，如果有的话，我们就牵线。如果发现对面那个女生已经被前面的某人给拐走了。一般的想法可能是放弃对吧，但是这样的话这题就会造成错解了而这也是匈牙利算法的优越性。如果说我们当前这个男生所有和他有暗恋关系的女生都被占用了那我们尝试去看看占用那个女生的男生是谁，看看能不能够让他换一个女生。如果可以的话，那我们这个男生也算是可以成对了对吧，对于我们的答案来讲，就是使的我们的匹配数更大了。对于所有的男生，都是执行这个过程。最终结果输出就可以了。这就是匈牙利算法。为什么可以只考虑一边呢？因为最大匹配数就是min(n1,n2)而且左右两边是连接的，所以看左边了，其实也就是看右边了。\n这个算法的时间复杂度为O(n*m)，但实际上达不到n*m\nac code:\n#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nconst int N &#x3D; 510,M &#x3D; 1e5+10;\nint h[N],e[M],ne[M],idx;\nint match[N];\nbool st[N]; &#x2F;&#x2F;st数组表示该女生是否被占用或者预定\nint n1,n2,m;\nint res;\n\nvoid add(int a,int b)&#123;\n    e[idx]&#x3D;b,ne[idx]&#x3D;h[a],h[a]&#x3D;idx++;\n&#125;\n\nbool find(int x)&#123;\n  \n    for(int i&#x3D;h[x];i!&#x3D;-1;i&#x3D;ne[i])&#123;\n        int j&#x3D;e[i];\n        if(!st[j])&#123;  &#x2F;&#x2F;如果这个女生没有被预定\n            st[j]&#x3D;true;\n            if(match[j]&#x3D;&#x3D;0||find(match[j]))&#123; &#x2F;&#x2F;只有这个女生没有男朋友，或者是他的男朋友可以选择其他人的时候，才是true值，也就是当前这个人是可以找这个女生的\n                match[j]&#x3D;x;\n                return true;\n            &#125;\n        &#125;\n    &#125;\n    return false;\n&#125;\n\nint main()&#123;\n    cin&gt;&gt;n1&gt;&gt;n2&gt;&gt;m;\n    memset(h,-1,sizeof h);\n    while(m--)&#123;\n        int u,v;\n        cin&gt;&gt;u&gt;&gt;v;\n        add(u,v);\n    &#125;  \n    for(int i&#x3D;1;i&lt;&#x3D;n1;i++)&#123;\n        memset(st,false,sizeof st); &#x2F;&#x2F;这里每次find前，都要初始化st数组一次为false，因为每次判断都是独立的。\n        if(find(i))&#123;\n            res++;\n        &#125;\n    &#125;  \n    cout&lt;&lt;res&lt;&lt;endl;\n    return 0;\n&#125;\n\n好了，至此为止，算法基础课的内容图论部分也已经结束了。那么到现在，2023.4.15，终于我将算法基础课的内容都整理好了笔记一遍。除了博弈论中的SG函数内容，那个真听不懂，之后再回来补吧。接下来就是提高课的内容。也是要开始大规模刷题的时候了。提高课可不会像这样一门课一门课的做笔记了。除非在高级数据结构里面会做一下笔记，其他的就是纯刷题了。好了，那么再见了！我们高级数据结构里面再见！Bye!~~~\n","slug":"ACM学习笔记day38","date":"2023-03-25T12:51:23.000Z","categories_index":"ACM","tags_index":"ACM,打卡,Prim,Kruskal,染色法,二分图,匈牙利算法","author_index":"Ausert"},{"id":"d62cd488fd25981616571e6226f3871a","title":"ACM学习笔记day37 (最短路算法总结)","content":"好，我们这一节对最短路算法作一个总结。总的来说基础的最短路算法有四种。分别为 Dijksta,bellman-ford，spfa，floyd算法。不同的算法应对的是不同的情况。\n\n\n什么算法解决什么问题，可以看下面这张图。\n\n我们最短路问题，可以分为两大类问题，一类是单源最短路，也就是从固定的一个顶点出发到另外一个点的最短距离。另外一类就是多源最短路，这类问题就是我们要求出的最短路，出发点是不固定的。\n我们依次来进行总结。\nDijkstraDijkstra算法分为两种，一种是朴素版本的，另外一种是堆优化版本的。他们的区别就在于时间复杂度的不同。\n朴素DijkstraDijkstra求最短路的思想是这样的。我们需要定义两个集合，一个集合是我们已经确定好最短路的节点，另外一个集合就是我们没有确定好最短路的节点。我们进行n次循环，每次循环中我们从没有确定好最短路的节点中选择一个距离源点最近的节点，我们用这个节点去更新所有其他节点的距离值。那么具体来说怎么更新呢？事实上，我们所说的用这个节点去更新所有其他节点的值就是在 他本来的值 和 从源点到这个节点+这个节点到当前节点的距离 中选择距离最小的，来更新他自己的值。说明白点就是我们如果一定要要求从源点到当前这个节点要经过我们所选择的那个节点，看看这样做的距离和他自己本来的距离谁小。这就是他自己更新的过程。n次循环之后，我们就可以得到答案。那么这里我们其实可以发现，Dijkstra每次循环的时候，其实都是确定了一个点的最短距离。所以n次之后，每一个点的最短距离也就被确定了。事实上，我们n-1次就够用了，因为最后一个节点的距离在n-1次的时候已经被确定了，在进行第n次循环的时候，其实做的是冗余操作。因为dist[n]&#x3D;min(dist[n],dist[n]+d[n][n])这一步其实是没有操作的，而对于其他的节点，最短距离已经被确定了，那么min值肯定也是取不到的。这就是朴素Dijkstra的做法。题目\nac code:\n#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nconst int N &#x3D; 510;\nint d[N][N];\nint n,m;\nint dist[N];\nbool st[N];\nconst int INF &#x3D; 0x3f3f3f3f;\n\nvoid dijkstra()&#123;\n    memset(dist,INF,sizeof dist);\n    dist[1]&#x3D;0;\n    for(int i&#x3D;0;i&lt;n;i++)&#123;\n        int t &#x3D; -1;\n        for(int j&#x3D;1;j&lt;&#x3D;n;j++)&#123;\n            if(st[j]&#x3D;&#x3D;false&amp;&amp;(t&#x3D;&#x3D;-1||dist[j]&lt;dist[t]))&#123;\n                t&#x3D;j;\n            &#125;\n        &#125;\n        st[t]&#x3D;true;\n        for(int j&#x3D;1;j&lt;&#x3D;n;j++)&#123;\n            dist[j]&#x3D;min(dist[j],dist[t]+d[t][j]);\n        &#125;\n    &#125;\n&#125;\n\nint main()&#123;\n    cin&gt;&gt;n&gt;&gt;m;\n    memset(d,INF,sizeof d);\n    for(int i&#x3D;0;i&lt;m;i++)&#123;\n        int x,y,z;\n        cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;\n        if(x!&#x3D;y)&#123;\n            d[x][y]&#x3D;min(d[x][y],z);   \n        &#125;\n    &#125;\n    for(int i&#x3D;0;i&lt;&#x3D;n;i++)&#123;\n        d[i][i]&#x3D;0;\n    &#125;\n    dijkstra();\n    \n    if(dist[n]&lt;INF) cout&lt;&lt;dist[n]&lt;&lt;endl;\n    else cout&lt;&lt;-1&lt;&lt;endl;\n    return 0;\n&#125;\n\n堆优化的Dijkstra说起优化，那么我们就要思考，哪里可以优化？很显然我们发现，可以优化的地方就是，选择距离源点最近的点这个过程我们可以优化，因为我们需要选择的是dist值最小的点那么为了处理这一类的问题，我们一般会用到什么数据结构？对，就是堆。我们将结果都存入堆中再进行查询，从而能够将时间复杂度从n方降低到logn\n题目\nac code:\n#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nconst int N &#x3D;  1.5e5+10;\ntypedef pair&lt;int,int&gt; PII;\nint h[N],e[N],ne[N],d[N],idx;\nint n,m;\nconst int INF &#x3D; 0x3f3f3f3f;\nint dist[N];\nbool st[N];\n\nvoid add(int a,int b,int c)&#123;\n    e[idx]&#x3D;b,d[idx]&#x3D;c,ne[idx]&#x3D;h[a],h[a]&#x3D;idx++;\n&#125;\n\nvoid dijkstra()&#123;\n    memset(dist,INF,sizeof dist);\n    priority_queue&lt;PII,vector&lt;PII&gt;,greater&lt;PII&gt;&gt; work;\n    dist[1]&#x3D;0;\n    work.push(&#123;0,1&#125;);\n    while(work.size())&#123;\n        auto t &#x3D; work.top();\n        work.pop();\n        int dd &#x3D; t.first;\n        int node &#x3D; t.second;\n        if(st[node]) continue;\n        st[node]&#x3D;1;\n\n        \n        for(int i &#x3D; h[node];i!&#x3D;-1;i&#x3D;ne[i])&#123;\n            int j &#x3D;e[i];\n            if(dist[j]&gt;dd+d[i])&#123;\n                dist[j]&#x3D;dd+d[i];\n                work.push(&#123;dist[j],j&#125;);\n            &#125;\n        &#125;\n    &#125;\n    \n&#125;\n\nint main()&#123;\n    cin&gt;&gt;n&gt;&gt;m;\n    memset(h,-1,sizeof h);\n    for(int i&#x3D;0;i&lt;m;i++)&#123;\n        int a,b,c;\n        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;\n        add(a,b,c);\n    &#125;\n    \n    \n    \n    dijkstra();\n    if(dist[n]&lt;INF) cout&lt;&lt;dist[n]&lt;&lt;endl;\n    else cout&lt;&lt;-1&lt;&lt;endl;\n    \n    return 0;\n&#125;\n\n这里堆优化的做法，其实整体的写法和朴素做法是有大不相同的。首先可以看到的是，我们存储表的时候采用了领接表的形式。因为他已经不是稠密图了。其次可以看到的是，dijkstra函数中我们循环的主体是一个while循环，也就是没有确定最短路的集合。我们不但需要记录他的距离，同时还要记录当前这个距离是哪个节点的。所以我们需要用到PII用来存储这样成对的信息。那么这就是堆优化的dijkstra算法，整体的思路还是和朴素做法差不多的，但是写法上还是有很大的差别的。\n做个总结，dijkstra算法能够适用的场景只有图中仅有非负权边的时候，如果存在负环，这个算法是不能正常运作的。因为可能结果会偏大。\n那么针对有负权边的单源最短路问题，我们采用的算法是bellman-ford和SPFA。\nbellman-fordbellman-ford算法来求单源最短路的思路就是：\n进行n次循环每次循环去遍历所有的边a-&gt;b 边权为w我们更新dist[b]&#x3D;min(dits[b],dist[a]+w)\n这就是bellman-ford算法。其中我们更新dist数组的值的过程成为松弛操作。而且我们对于bellman-ford算法，我们存储边的方式是随意的，只要能够让我们遍历所有的边即可。\n这里我们需要了解一个东西，那就是我们一开始的n次循环意味着什么。bellman-ford中最外层是有一个循环的，这个循环的循环次数，实际上是和他求解的答案是有关的。这也就是bellman-ford所能处理的一类特殊的问题——有边数限制的最短路。边数限制至多多少条，就循环多少次。\n同时，我们要知道，bellman-ford是可以用来判断是否有负权回路的。因为n次循环之后，dist[n]一定就是最小值了。如果再一次进行松弛操作，dist[n]的值还能够减小，就说明存在负权回路。这个时候其实他的最短路是不一定存在的。\n题目\nac code:\n#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nconst int N &#x3D; 510,M &#x3D; 1e4+10;\nconst int INF &#x3D; 0x3f3f3f3f;\ntypedef struct edge&#123;\n    int a,b,w;\n&#125;;\nedge edges[M];\nint dist[N],backup[N];\nint n,m,k;\n\nbool bellmanford()&#123;\n    memset(dist,INF,sizeof dist);\n    dist[1]&#x3D;0;\n    for(int i&#x3D;0;i&lt;k;i++)&#123;\n        memcpy(backup,dist,sizeof dist);\n        for(int j&#x3D;0;j&lt;m;j++)&#123;\n            auto ele &#x3D; edges[j];\n            dist[ele.b]&#x3D;min(dist[ele.b],backup[ele.a]+ele.w);\n        &#125;\n    &#125;\n    if(dist[n]&lt;INF&#x2F;2) return true;\n    else return false;\n&#125;\n\nint main()&#123;\n    cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;\n    for(int i&#x3D;0;i&lt;m;i++)&#123;\n        int a,b,w;\n        cin&gt;&gt;a&gt;&gt;b&gt;&gt;w;\n        edges[i]&#x3D;&#123;a,b,w&#125;;\n    &#125;\n    \n    int res &#x3D; bellmanford();\n    if(res)&#123;\n        cout&lt;&lt;dist[n]&lt;&lt;endl;\n    &#125;\n    else&#123;\n        cout&lt;&lt;&quot;impossible&quot;&lt;&lt;endl;\n    &#125;\n    \n    \n    return 0;\n&#125;\n\n这里要注意一个问题，就是题解中我们使用了backup数组用来备份dist数组。为什么要用到这个数组呢？因为要防止出现串联的问题。为什么要防止串联式的更新？因为如果允许串联式的更新，那么我们n次循环之后的结果，dist的值一定是至少过了n条边的，而不是至多n条边。所以如果不是这道题的话，只是单纯的求最短路，那么这个backup数组是用不到的其实。\n总结，bellman-ford算法能够适用于存在负权边的图，并且他也能够求图中是否存在负权回路，总的来说功能还是比较强大的。但是唯一的缺点就是时间复杂度太大了。O(n*m)的时间复杂度导致他能够适用的数据量是特别小的。\nSPFASPFA的思想其实是优化了bellman-ford算法的。我们可以看到bellman-ford算法，他更新边的时候，是无脑更新所有的边的。那么很显然，我们可以发现，如果我们到一个节点的距离没有被更新成更短的话，他们这个节点他的后继节点也是没办法通过这个节点更新到更短的。所以我们的SPFA算法就解决了这样的一个问题。SPFA的思想其实就是，我们用更新过的节点，去更新他的后继节点的dist。啥意思呢？就是某个节点的dist值刚被更新过，说明他的值变小了对吧。那么我们可以用这个节点去更新他的后继节点，因为他是被更新过的，所以他的后继节点也是有机会被更新变短的。\n那么实际实现的时候，我们会先建立一个queue，用来存放dist值被更新过的点。然后我们每次用queue头的那个节点，去更新他的所有的后继节点，如果后继节点的值也被更新了，那么就把他放进去对吧。当然如果已经在里面的话，就不需要放了。\n题目\nac code:\n#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nconst int N &#x3D; 1e5+10;\nint e[N],ne[N],h[N],idx,w[N];\nint dist[N];\nbool st[N];\nint n,m;\nconst int INF &#x3D; 0x3f3f3f3f;\n\nvoid add(int a,int b,int c)&#123;\n    e[idx]&#x3D;b,w[idx]&#x3D;c,ne[idx]&#x3D;h[a],h[a]&#x3D;idx++;\n&#125;\n\nvoid spfa()&#123;\n    memset(dist,INF,sizeof dist);\n    queue&lt;int&gt; work;\n    dist[1]&#x3D;0;\n    st[1]&#x3D;0;\n    work.push(1);\n    while(work.size())&#123;\n        int t &#x3D; work.front();\n        work.pop();\n        st[t]&#x3D;false;\n        for(int i&#x3D;h[t];i!&#x3D;-1;i&#x3D;ne[i])&#123;\n            int j &#x3D; e[i];\n            if(dist[j]&gt;dist[t]+w[i])&#123;\n                dist[j]&#x3D;dist[t]+w[i];\n                if(!st[j])&#123;\n                    work.push(j);\n                    st[j]&#x3D;1;\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n&#125;\n\nint main()&#123;\n    cin&gt;&gt;n&gt;&gt;m;\n    memset(h,-1,sizeof h);\n    for(int i&#x3D;0;i&lt;m;i++)&#123;\n        int a,b,c;\n        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;\n        add(a,b,c);\n    &#125;\n    spfa();\n    if(dist[n]&lt;INF&#x2F;2) cout&lt;&lt;dist[n]&lt;&lt;endl;\n    else cout&lt;&lt;&quot;impossible&quot;&lt;&lt;endl;\n    return 0;\n&#125;\n\n\n其实我们看上面的代码，我们会发现。spfa的做法其实和堆优化的dijkstra还是很像的。不过堆优化的dijktra他的那个queue的意义是没有确定最短路的点，而spfa的意义是最短路被更新过的点。然后同样的操作都是，用队头的点去更新后继节点的dist值。这个算法的时间复杂度是很快的，一般为O(m)，最坏的情况下为O(n*m)\nfloydfloyd算法解决的是多源最短路问题。也就是说，我们query的时候，终点和起点是不一定的，并不是唯一的。那么这里，我们就不能够采用之前的任何一种算法了。因为之前的算法解决的都是单源的问题，也就是起点和终点是固定的。\nfloyd的算法思想也很简单，就是一个三重循环。先枚举k，然后枚举i和j，每次更新的是i节点到j节点的距离如果i-&gt;j，并且经过k节点的距离比直接i到j要短那么就更新这段距离。注意，这里的更新是直接在存储的地方更新的。一般我们会采用领接矩阵，所以相当于是直接对领接矩阵进行更新。\n这里我们需要注意的是，我们枚举的经过的中间节点k，必须是在最外层的循环。不然是会出问题的。\n题目链接\nac code:\n#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nint n,m,k;\nconst int N &#x3D; 210;\nint a[N][N];\n\n\nvoid floyd()&#123;\n    for(int k&#x3D;1;k&lt;&#x3D;n;k++)&#123;\n        for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;\n            for(int j&#x3D;1;j&lt;&#x3D;n;j++)&#123;\n                a[i][j]&#x3D;min(a[i][j],a[i][k]+a[k][j]);\n            &#125;\n        &#125;\n    &#125;\n&#125;\nint main()&#123;\n    cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;\n    memset(a,0x3f3f3f3f,sizeof a);\n    for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;\n        a[i][i]&#x3D;0;\n    &#125;\n    for(int i&#x3D;0;i&lt;m;i++)&#123;\n        int x,y,z;\n        cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;\n        a[x][y]&#x3D;min(a[x][y],z);\n    &#125;\n    floyd();\n    while(k--)&#123;\n        int x,y;\n        cin&gt;&gt;x&gt;&gt;y;\n        if(a[x][y]&gt;0x3f3f3f3f&#x2F;2) cout&lt;&lt;&quot;impossible&quot;&lt;&lt;endl;\n        else cout&lt;&lt;a[x][y]&lt;&lt;endl;\n    &#125;\n    \n    return 0;\n&#125;\n\n\n这个算法的时间复杂度为O(n^3)，可以看到时间复杂度还是很高的。\n好的，那么至此基础的最短路算法总结就到此为止了。也算了填了一个很久的坑了吧。终于填完了XD我们下次再见Bye~\n","slug":"ACM学习笔记day37","date":"2023-03-25T12:51:16.000Z","categories_index":"ACM","tags_index":"ACM,打卡,学习,最短路问题,Dijkstra,Bellman-ford,spfa,floyd","author_index":"Ausert"},{"id":"1429a762104f1c731f39acc20f00d741","title":"ACM学习笔记day36(树和图的DFS和BFS)","content":"水一篇blog（树和图的bfs和dfs。\n\n\n树和图的存储方式采用领接表或者是领接矩阵都可以。dfs和bfs的思路是一样的。bfs套用bfs的模板就可以了，定义一个工作队列。将没有访问过的领接点放入队列中，然后处理即可dfs就遍历他的所有领接点，然后如果没访问过的话就dfs下去。然后进行处理。当然这两个方法都要定义一个st数组来表示这个节点是否被访问过。\n树和图的dfs和bfs就是这样。\n然后要讲一个特别的东西，就是树的重心。重心定义：重心是指树中的一个结点，如果将这个点删除后，剩余各个连通块中点数的最大值最小，那么这个节点被称为树的重心。树的重心表示了这样的一个节点。就是某个节点将其删除之后，他说产生的子连通图要尽可能的支离破碎的，也就是各个子连通块中 点数的最大值最小。\n题目连接\n那么我们怎么求树的重心呢？我们根据定义来入手，将一个点删除之后剩余各个连通块中点数的最大值最小的。我们可以枚举所有的点，然后一个一个的去算他的各个连通块中点数的最大值那么我们需要算哪些部分的呢？首先不难发现，我们去掉了一个点之后。很显然他的父节点所连接的子图，除了被删掉的那个点都是在一个连通块内的。那么产生的子连通图就主要在被删除的点的孩子子节点连接的子树中。那么我们只需要递归的去求各个子连通图的点数，要用来算一个总和，然后还要取其中最大的那么他的父节点所在的连通子图就等于总的节点数n减去我们之前算的那个总和。然后再在取个最大的。就是目前来说删掉这个节点，剩余各个连通块中点数的最大值然后用这个去更新ans，ans取最小。最终结果就是ans了。\n当然真暴力枚举，肯定是不行的，那样的话会有很多重复算的。所以我们这里用到了dfs，并且其实是有一点树形DP的思想在里面的。我们在dfs的时候，每次dfs到一个节点，我们就假设删掉这个节点，然后去dfs他的领接节点，求出他的孩子和孙子节点有多少个，然后子连通块中数量最大的是多少求完之后去更新ans。dfs返回的是以当前节点为根节点的子树的节点数。\ncode如下:\n#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nconst int N &#x3D; 2e5+10;\nint h[N],e[N],ne[N],idx;\nbool st[N];\nint n;\nint ans&#x3D;N;\nvoid add(int a,int b)&#123;\n    e[idx]&#x3D;b,ne[idx]&#x3D;h[a],h[a]&#x3D;idx++;\n&#125;\n\nint dfs(int u)&#123;\n    st[u]&#x3D;true;\n    \n    int sum&#x3D;1,res&#x3D;0;\n    for(int i&#x3D;h[u];i!&#x3D;-1;i&#x3D;ne[i])&#123;\n        int j&#x3D;e[i];\n        if(!st[j])&#123;\n            int t &#x3D; dfs(j);\n            res&#x3D;max(res,t);\n            sum+&#x3D;t;\n        &#125;\n    &#125;\n    res&#x3D;max(res,n-sum);\n    ans&#x3D;min(ans,res);\n    return sum;\n&#125;\nint main()&#123;\n    \n    cin&gt;&gt;n;\n    memset(h,-1,sizeof h);\n    for(int i&#x3D;0;i&lt;n-1;i++)&#123;\n        int a,b;\n        cin&gt;&gt;a&gt;&gt;b;\n        add(a,b),add(b,a);\n    &#125;\n    \n    dfs(1);\n    \n    cout&lt;&lt;ans&lt;&lt;endl;\n    \n    return 0;\n&#125;\n\n\n关于图的bfs，在边上的权值都是1的时候，我们求最短路其实是可以用bfs的，而且这样的时间复杂度是很低的，因为就扫一遍图嘛为什么可以用bfs求最短路呢？很简单因为bfs是一层一层来求的，如果bfs先扫到了终点，那么显然这一定是最短的距离。直接break输出结果就可以了。\nThat’s all;\n","slug":"ACM学习笔记day36","date":"2023-03-25T12:50:55.000Z","categories_index":"ACM","tags_index":"ACM,学习,图论,dfs,bfs,树,图","author_index":"Ausert"},{"id":"f4b8c236f24c3289ca5c3e33420c6ba4","title":"ACM学习笔记day35(拓扑序列)","content":"今天的内容是拓扑排序。\n\n\n\n若一个由图中所有点构成的序列A满足：对于图中的每条边 (x,y) x 在 A 中都出现在 y 之前，则称 A 是该图的一个拓扑序列。注意：图的拓扑序并不一定唯一所以题目的答案并不唯一。\n那么我们应该怎么去求拓扑序列呢？很显然，我们从定义出发，我们需要保证序列中的一个点，一定出现在他后面的点之前。那我们就可以这样子来选择出来一条拓扑序列。我们每次选择入度为零的点，将其放入我们的拓扑序列中去，然后将这个点删掉，同时将相关的边也删掉。重复这个过程直到所有点都被删掉。那么我们实际实现的时候，我们就需要额外记录一下每一个节点的入度。然后每次选择入度为零的，并且没有被选过的点，放入拓扑序列中去就可以了。然后更新这个点所有的领接点的入度就可以了。\n下面为ac code：\n#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nconst int N &#x3D; 1e5+10;\nint e[N],ne[N],h[N],idx;\nint d[N];\nbool st[N];\nvector&lt;int&gt; res;\nint n,m;\n\nvoid add(int a,int b)&#123;\n    e[idx]&#x3D;b,ne[idx]&#x3D;h[a],h[a]&#x3D;idx++;\n&#125;\n\nbool topsort()&#123;\n    queue&lt;int&gt; work;\n    for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;\n        if(d[i]&#x3D;&#x3D;0)&#123;\n            work.push(i);\n            st[i]&#x3D;true;\n        &#125;\n    &#125;\n    while(work.size())&#123;\n        int t &#x3D;work.front();\n        work.pop();\n        for(int i&#x3D;h[t];i!&#x3D;-1;i&#x3D;ne[i])&#123;\n            int j&#x3D;e[i];\n            d[j]--;\n            if(d[j]&#x3D;&#x3D;0&amp;&amp;!st[j])&#123;\n                work.push(j);\n            &#125;\n        &#125;\n        res.push_back(t);\n    &#125;\n    if(res.size()&#x3D;&#x3D;n)&#123;\n        return true;\n    &#125;\n    else&#123;\n        return false;\n    &#125;\n&#125;\nint main()&#123;\n    cin&gt;&gt;n&gt;&gt;m;\n    memset(h,-1,sizeof h);\n    for(int i&#x3D;0;i&lt;m;i++)&#123;\n        int a,b;\n        cin&gt;&gt;a&gt;&gt;b;\n        add(a,b);\n        d[b]++;\n    &#125;\n    if(topsort())&#123;\n        for(int i&#x3D;0;i&lt;n;i++)&#123;\n            cout&lt;&lt;res[i]&lt;&lt;&#39; &#39;;\n        &#125;\n        cout&lt;&lt;endl;\n    &#125;\n    else&#123;\n        cout&lt;&lt;-1&lt;&lt;endl;\n    &#125;\n    \n    return 0;\n&#125;\n\n\n好的，那么这里就是拓扑排序的全部内容了。我么下次再见。\n","slug":"ACM学习笔记day35","date":"2023-03-21T14:49:38.000Z","categories_index":"ACM","tags_index":"ACM,打卡,学习,图论,dfs,bfs,拓扑排序","author_index":"Ausert"},{"id":"61b5f3ff4f3925a999a96e334e6690e1","title":"Django使用日志1","content":"wc，后端开发可太cooooool了！\n\n\ndjango-admin startproject &lt;name&gt;\n\n\n这条指令用于在当前文件夹下产生一个 &lt;name&gt; 的django默认框架的文件\n这样做了之后，其实目前就已经可以作为一个网页的后端了，我们可以尝试部署在本地上。\npython manage.py runserver 0.0.0.0:80\n\n这样就可以通过访问0.0.0.0:80来访问我们这个用django框架生成的web了。虽然是默认网页。\n","slug":"Django使用日志1","date":"2023-03-11T15:02:23.000Z","categories_index":"Django","tags_index":"后端,backend,Django,开发,项目","author_index":"Ausert"},{"id":"f0263da8eb494789f12ee807a4dcd631","title":"Python学习日志day4","content":"有关一些if条件判断的东西\n检查一个元素是否在列表里面可以直接使用\nvalue in array_name 返回的是True or False\n如果查询是否不在，那就是not in\n\n列表名可以直接作为if条件句的判断，如果为空则为false，反之为true。\n\n\n\n\n关于字典","slug":"Python学习日志day4","date":"2023-03-05T14:00:31.000Z","categories_index":"Python","tags_index":"学习,Python,编程,萌新","author_index":"Ausert"},{"id":"864fc2c6f57dbf62e38e8d5dfd7c13f6","title":"Python学习日志day3","content":"关于range()用法range()参数说明调用range()如果有两个参数，就表示从第一个参数到第二个参数的中间的所有的数字，左闭右开。如果只有一个参数则就是从0到这个参数的所有数字，左闭右开。如果有三个参数，那么前两个参数和上面这个第一条一样，第三条参数则是他的步长，比如range(1,3)&#x3D;[1,2]range(1,3,2)&#x3D;[1](下一个数字应该是3但是因为3不在范围内，所以就没有了3)\n\n\n使用list和range生成列表我们使用list()函数和range()来自动生成列表。number&#x3D;list(range(3))这样我们就会生成[0,1,2]这样的一个列表。\n或者我们可以直接在[]中使用range函数来生成内容值。\n如下：\na &#x3D; [vals for vals in range(10)]\n\n\n这样我们就生成了一个列表，里面的值就是从0~9的一个permutation。\n这个方法也叫列表解析。\n切片（也就是subsegment)对于列表名后面加[begin:end]\n就可以返回一个列表，这个列表就是当前这个列表从begin开始的，到end前面一个位置的subsegment\n不难理解，举个例子:\nlist &#x3D; [1,2,3,4]\nlist[0:3]&#x3D;[1,2,3]\n如果冒号左边空了，那就是默认从头开始，如果冒号右边空了，那就默认一直到最后。\n如果两头都没有，那就是全部了。\n关于元组元组其实就是const修饰的列表，也就是无法修改值的。\n元组的定义和列表类似，只不过是将[]改为了()，其他的和列表都是类似的。\n虽然无法改变值，但是可以重新赋值。\n","slug":"Python学习日志day3","date":"2023-03-01T14:49:10.000Z","categories_index":"Python","tags_index":"学习,python,语言,基础","author_index":"Ausert"},{"id":"2c6fdca36eef66c662c85d61e609fdfd","title":"ACM学习笔记day33 (状态压缩DP)","content":"状态压缩DP，其实就是线性DP的基础上加上了状态压缩。\n\n\n那么什么是状态压缩呢？其实就是将状态的集合，通过一种特定的方式来便利的表示出来，同时也降低了时间复杂度。一般的，我们会将很多种取或者不取的状态集合，用一个01串来表示。这样也就是通过状态压缩来实现这种功能了。\n例如在蒙德里安的梦想中状态压缩了什么？就是将每一列中的每一行他是否突出来了，用01串来表示。当然实际在存的是用十进制数字来表示的。\n又如在最短汉密尔顿路径中状态压缩了什么？就是我们遍历到第j个节点后，对于这n个节点，哪些节点是我们已经遍历过的，哪些是没有遍历过的。这样的很多的状态，用01串来表示。这就是状态压缩。当然这里多提一嘴，这个最短汉密尔顿路径好像是NP问题，也就是说，目前为止是没有一个时间复杂度是多项式表达式的算法来解决这个问题的。\nOK，状态压缩DP先这样吧，DP快完结了。之后出个DP总结的东西。XD\n","slug":"ACM学习笔记day33","date":"2023-02-28T14:11:30.000Z","categories_index":"ACM","tags_index":"ACM,打卡,学习,DP,动态规划,状态压缩DP,状态压缩","author_index":"Ausert"},{"id":"a7b5056260bafa19bfefd98278cc6498","title":"Python学习日志day2","content":"emm，是学习py的第二天力。\n下周就要开始搞数据库课设力！\n要G力\nanyway,之后py还是要学的，毕竟想自己搞个bot玩玩XD\n\n\n关于sort方法sort()方法py中的sort使用方法和cpp中的有略微的不同。\ncpp中是直接使用sort函数，然后里面放入形参就是了，\n但是py中的是调用列表中的sort函数，进行排序。\n默认情况下，排序方式是升序排序，如果有字符类型的数据的话，是按照字典序的升序排序的。\n当然也可以倒序，只需要把reverse值改为true就可以了，具体要这么写才行。\n\n\n\n\n\n\n\n\n\narray_name.sort(reverse&#x3D;True)\n当然这种方法，会修改原来的数组，也就是说，我们会使得原来的数组变得有序。\n那么接下来的就是sorted()方法，他会生成另外一份有序的数组，但是不会改变原来的数组的顺序。\nsorted()方法sorted的用法就和cpp中sort的用法差不多了。\n\n\n\n\n\n\n\n\n\nsorted(array_name)\n就可以了，当然如果要降序的话，就类似方法就可以了\n\n\n\n\n\n\n\n\n\nsorted(array_name,reverse&#x3D;True)\n这种方法呢，他会返回一个列表，这个列表是排序好的，而被排序的那个原来的列表是不会被修改顺序的。\n反转列表方法类似，都是使用reverse函数，不过py的使用是通过数组去调用。\n\n\n\n\n\n\n\n\n\narray_name.reverse()\n这样来使用的。(好怪)\n获取长度使用len函数\n\n\n\n\n\n\n\n\n\nlen(array_name)\n他就会返回列表的长度了。(也好怪)\n关于操作列表通过for in array_name循环来获取列表中的每一个元素比如说我们有一个cats的列表。\n那么我们要一个一个获取列表中的元素\n就可以这么写。\n\n\n\n\n\n\n\n\n\nfor cat in cats:\n这里cat是cats中的元素。\n哦当然，for循环内部的语句，注意要严格对齐，py对于格式的要求是很严格的。\n这样写的意思其实类似于for(auto cat : cats)C ++ 中的这种写法。\n是基于元素的遍历方式。\n","slug":"Python学习日志day2","date":"2023-02-26T14:02:34.000Z","categories_index":"Python","tags_index":"学习,python,语言,基础","author_index":"Ausert"},{"id":"9440b99fb66535a63cc60a8f05ed5e66","title":"Python学习日志day1","content":"emm，因为导师要求，所以需要学习一下py，同时可能要为数据库的课设作语言准备，所以就另外开了这样的一个日志。\n不过虽说是学习日志，这里我也基本上只会放一些容易忘记的函数啥的。\n不会有其他的东西了。qwq\n\n\n关于字符串\n字符串.title()这个函数可以使得字符串里面每一个单词的首字母大写。 e.g “abc hi!”.title()就变成了”Abc Hi!”而对应的lower()函数和upper()函数，可以使得字符串内部的每一个字母都小写或者大写。\nf”{string}{string}”可以实现字符串相加的功能，其实就是一样的（那我干嘛不用相加对了，f”string{string}”这个也可以这么用，就是相当于你造了个句子，然后用{}表示里面要填入特定位置的一些内容，这样的话会比直接用加法要方便的。\nstring.rstrip()操作是将字符串的右边空格给去掉，当然他不是直接修改原来的值，而是将修改后的string作为返回值的。也就是说如果只是调用这个函数，那么输出的就是删除之后的结果，而原来的string是不会被改变的，如果要改变，需要更新到原来的string上去。lstrip()就是去掉左边的空格，strip()是去掉两边的空格。其他的和上面那个一样的。\n\n关于列表\n在给数字赋值的时候如果数字里面有下划线，没关系，py会自动忽视这个下换线。e.g a&#x3D;1_000_000_000，实际上a就赋值成了1000000000。当然这个下划线不能出现在数字的一开始（\n列表中尾部加入元素使用append()函数。插入函数insert(index,value)插入的位置是index的前面的地方。如果要删除一个数据的话，知道下标的可以使用del语句,e.g del array_name[index]这样。如果不知道下标，那么可以使用pop函数，他默认删除的是列表的最后一个元素，同时函数会返回这个元素的值。array_name.pop()删除最后一个元素，同时返回它。当然如果括号里面写入index的话，就可以删除任意一个元素了。如果不知道要删除的下标，只是要删除对应的值，那么可以使用remove()方法。e.g array_name.remove(value)，注意remove只会删除第一个对应值的元素，如果有多个，只会删掉第一个。\n\n","slug":"Python学习日志day1","date":"2023-02-23T05:38:44.000Z","categories_index":"Python","tags_index":"学习,python,语言,基础","author_index":"Ausert"},{"id":"0c3e2aa6872231e13fd503f7a08ea40b","title":"ACM学习笔记day32 (数字三角形，最长上升子序列)","content":"今天的内容是数字三角形，和最长上升子序列。其中最长上升子序列可以说是dp问题里面非常经典的问题了。\n\n\n\n数字三角形对于这个题，我们的dp思路其实很简单。当然在此之前，我们需要定义一下这个三角形的行和列。给的三角形是这样的:\n       7\n      3   8\n    8   1   0\n  2   7   4   4\n4   5   2   6   5\n\n我们稍微移动一下位置，使得他便于在数组中存储\n7\n3   8\n8   1   0\n2   7   4   4\n4   5   2   6   5\n变成这样之后也是一个三角形的。事实上，我们所定义的行是一般意义上的行，但是列，是从右上角到左下角的一个列叫列。那么我们稍微排一下其实就是这样子的。\n那么我们的DP思路其实就是。对于第i行，第j列的数字，我们从顶部下来到这个位置，sum最大的值。而最终我们要得到答案，就是取我们dp数组最后一行中最大第一个值就是了。那么dp[i][j]应该怎么求呢？我们发现，要到第i行第j列，来源只有两个地方，第i-1行第j-1列，第i-1行第j列。那么我们对于这两个来源。取一个大的就可以了，然后再加上a[i][j]的值就可以了。即状态转移方程为：\n\n\n\n\n\n\n\n\n\ndp[i][j]&#x3D;max(dp[i-1][j-1],dp[i-1][j])+a[i][j];\n当然如果此时这个位置在最左边或者最右边，上一层只有一条路可以过来，所以不用判断，直接赋值就可以了。这是一种需要特判的情况。\nac code:\n#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nconst int N &#x3D; 510, M &#x3D; 1e4+10;\nconst int INF &#x3D; 0x3f3f3f3f;\nint a[N][M];\nint f[N][M];\n\nint main()&#123;\n    int n;\n    cin&gt;&gt;n;\n    for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;\n        for(int j&#x3D;0;j&lt;i;j++)&#123;\n            cin&gt;&gt;a[i][j];\n        &#125;\n    &#125;\n    for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;\n        for(int j&#x3D;0;j&lt;i;j++)&#123;\n            if(j&#x3D;&#x3D;0)&#123;\n                f[i][j]&#x3D;f[i-1][j]+a[i][j];\n            &#125;\n            else if(j&#x3D;&#x3D;i-1)&#123;\n                f[i][j]&#x3D;f[i-1][j-1]+a[i][j];\n            &#125;\n            else&#123;\n                f[i][j]&#x3D;max(f[i-1][j]+a[i][j],f[i-1][j-1]+a[i][j]);\n            &#125;\n        &#125;\n    &#125;\n    int ans&#x3D;-INF;\n    for(int i&#x3D;0;i&lt;n;i++)&#123;\n        ans&#x3D;max(ans,f[n][i]);\n    &#125;\n    cout&lt;&lt;ans&lt;&lt;endl;\n    \n    \n    \n    return 0;\n&#125;\n\n\n最长上升子序列这是一个非常经典的问题了。我们为了求出最终的最长上升子序列的长度。运用dp的方法是从头到尾的递推过去。我们定义dp[i]为以a[i]为结尾的一个子序列他的最大上升子序列是多长。当到dp[i]的时候，我们看看他可以作为哪一个子序列的后缀。也就是从dp[0]到dp[i-1]中找，加上这个数字之后，哪个的长度最长。那么我们就容易得出，这是一个双重循环。状态转移方程就是\n\n\n\n\n\n\n\n\n\ndp[i]&#x3D;max(dp[0]+1,dp[1]+1,…..dp[i-1]+1);\n当然这里有一个前提，就是a[i]的值要大于前面子序列的末尾的值。不然不满足条件了。\n这个算法的时间复杂度是$O(n^2)$\nac code:\n#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\n\n\nint main()&#123;\n    int n;\n    cin&gt;&gt;n;\n    vector&lt;int&gt; a(n);\n    for(int i&#x3D;0;i&lt;n;i++)&#123;\n        cin&gt;&gt;a[i];\n    &#125;\n    vector&lt;int&gt; f(n);\n    f[0]&#x3D;1;\n    for(int i&#x3D;0;i&lt;n;i++)&#123;\n        f[i]&#x3D;1;\n        for(int j&#x3D;0;j&lt;i;j++)&#123;\n            if(a[j]&lt;a[i])&#123;\n                f[i]&#x3D;max(f[i],f[j]+1);\n            &#125;\n        &#125;\n    &#125;\n    int res&#x3D;0;\n    for(int i&#x3D;0;i&lt;n;i++)&#123;\n        res&#x3D;max(res,f[i]);\n    &#125;\n    cout&lt;&lt;res&lt;&lt;endl;\n    return 0;\n&#125;\n\n接下来是这题的一种优化做法，因为n方的复杂度还是比较高的。题目连接\n优化做法下，我们将时间复杂度控制在了$O(nlogn)$下。我们再回过去看一下前面的朴素dp做法，看看哪里可以优化的。我们发现，从头遍历到尾，这里似乎优化不了。那么就只能对内层循环动手脚了。这里我们需要额外开一个数组，来记录一个信息。就是当我们迭代到第i位的时候。前面长度为1的，长度为2的，3的….长度为目前能得到的上升子序列他的最后一个最小的数字是多少？\n比如说:长度为1的上升子序列，最后一个数字最小的是1长度为2的上升子序列，最后一个数字最小的是2长度为3的上升子序列，最后一个数字最小的是3长度为4的上升子序列，最后一个数字最小的是4长度为5的上升子序列，最后一个数字最小的是5...\n当然这里这个数字的值一定是递增的。具体证明可以用反证法。假设有一个不是递增的。这里就不多说明了。\n那么我们得到了这个数组之后，我们再来看ai，我们发现，可以使用二分来查找我们这个ai可以放在哪里。同时使得子序列的长度最大。那么这样，我们就解决了这个问题，在nlogn的时间内。\nac code:\n#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\n\nint main()&#123;\n    int n;\n    cin&gt;&gt;n;\n    int len&#x3D;0;\n    vector&lt;int&gt; a(n);\n    vector&lt;int&gt; q(n);\n    for(int i&#x3D;0;i&lt;n;i++)&#123;\n        cin&gt;&gt;a[i];\n    &#125;\n    q[0]&#x3D;-2e9;\n    for(int i&#x3D;0;i&lt;n;i++)&#123;\n        int l&#x3D;0,r&#x3D;len;\n        while(l&lt;r)&#123;\n            int mid&#x3D;l+r+1&gt;&gt;1;\n            if(q[mid]&lt;a[i])&#123;\n                l&#x3D;mid;\n            &#125;\n            else&#123;\n                r&#x3D;mid-1;\n            &#125;\n        &#125;\n        len&#x3D;max(len,r+1);\n        q[r+1]&#x3D;a[i];\n    &#125;\n    cout&lt;&lt;len&lt;&lt;endl;\n    return 0;\n&#125;\n\nOK，这就是全部的内容了。qwq\n","slug":"ACM学习笔记day32","date":"2023-02-20T14:18:20.000Z","categories_index":"ACM","tags_index":"ACM,打卡,学习,DP,动态规划","author_index":"Ausert"},{"id":"c4215acd2eabdb6df78cd852601c9d9a","title":"ACM学习笔记day31 (多重背包(二进制优化)，分组背包)","content":"今天的内容是多重背包的二进制优化解法和分组背包。\n一开始听多重背包的二进制优化的时候还是蛮难的， 后来知道一个关键点之后就容易了。至于分组背包，其实和多重背包差不多的，只不过选择上稍微变了点。\n\n\n\n多重背包（二进制优化）关于多重背包的一个二进制优化。我们原来的朴素做法就是，枚举第i个物品是拿几个的。比如一个两个之类的。但是这个算法是n三次方的时间复杂度，时间复杂度太高了。那么我们采取的一个策略就是，将多重背包转化为01背包问题。也就是说我们把si个第i个物品，分成若干个整体，然后拆开后放入物品中去。就是说我们原来有n个物品，每个物品有si个，我们将这个si拆开来，也放入这n个物品中去，那么物品就显然不止n个了，会更多。问题在于怎么拆？要既能确保最后选来选去不会超过他本来的si，又要保证选来选取能够涵盖0si这所有的取第i个物品的数量。当然我们可以拆成1 1 1 1 1 1 ….这种做法无论如何肯定可以，但是这样的话，物品的个数就会变得特别多，根据给定的数据来看，n的大小会变成2e6，这样再当01背包做，显然也是会超时的。那么我们怎么拆？采用的办法是二进制拆法。比如对于si&#x3D;7；我们把7拆成1 2 4 这样，我们就可以用这三个数字去表示07之间的任意一个数字。因为7的二进制表示为111，而显然100,10,1这三个二进制数字能够表示0~7之间的任意一个数字.那么我们就相当于对于每一种物品，我们拆分出了logsi个物品最终的物品数量就是所有logsi相加，log向上取整。比如11拆到1 2 4 如果选择总的和会超过11，为了确保和是正确的，所以我们最后要加上个4我们拆完之后，得到一个新的物品组，然后按照01背包做就可以了。\nac code:\n#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nconst int N &#x3D; 2e6+10;\nint n,m;\n\nint f[N];\n\nstruct Good&#123;\n    int v,w;\n&#125;;\nvector&lt;Good&gt; goods;\n\nint main()&#123;\n    cin&gt;&gt;n&gt;&gt;m;\n    goods.push_back(&#123;0,0&#125;);\n    for(int i&#x3D;0;i&lt;n;i++)&#123;\n        int v,w,s;\n        cin&gt;&gt;v&gt;&gt;w&gt;&gt;s;\n        for(int k&#x3D;1;k&lt;&#x3D;s;k&lt;&lt;&#x3D;1)&#123;\n            s-&#x3D;k;\n            goods.push_back(&#123;k*v,k*w&#125;);\n        &#125;\n        if(s&gt;0)&#123;\n            goods.push_back(&#123;s*v,s*w&#125;);\n        &#125;\n    &#125;\n    for(int i&#x3D;1;i&lt;&#x3D;goods.size();i++)&#123;\n        for(int j&#x3D;m;j&gt;&#x3D;goods[i].v;j--)&#123;\n           \n            f[j]&#x3D;max(f[j],f[j-goods[i].v]+goods[i].w);\n            \n        &#125;\n    &#125;\n    cout&lt;&lt;f[m]&lt;&lt;endl;\n    return 0;\n&#125;\n\n\n\n分组背包分组背包就是，给你n组物品，每一组物品有s个，然后每一组物品里面只能拿一个。那么我们其实发现，这个问题和多重背包是类似的。只不过多重背包枚举的是一个物品拿多少个，而分组背包是每个组里面拿哪一个。拿的时候判断一下就可以了。\nac code:\n#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nint n,m;\nconst int N &#x3D; 1000+10;\nstruct Good &#123;\n    int v,w;\n&#125;;\n\nvector&lt;vector&lt;Good&gt;&gt; a(n);\nint f[N];\n\nint main()&#123;\n    cin&gt;&gt;n&gt;&gt;m;\n    a.resize(n+1);\n    for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;\n        int s;\n        cin&gt;&gt;s;\n        while(s--)&#123;\n            int v,w;\n            cin&gt;&gt;v&gt;&gt;w;\n            a[i].push_back(&#123;v,w&#125;);\n        &#125;\n    &#125;\n    for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;\n        for(int j&#x3D;m;j&gt;&#x3D;0;j--)&#123;\n            f[j]&#x3D;f[j];\n            for(int k&#x3D;0;k&lt;a[i].size();k++)&#123;\n                if(j-a[i][k].v&gt;&#x3D;0) f[j]&#x3D;max(f[j],f[j-a[i][k].v]+a[i][k].w);\n            &#125;\n        &#125;\n    &#125;\n    cout&lt;&lt;f[m]&lt;&lt;endl;\n    return 0;\n&#125;\n\n\n那么这个就是今天的全部内容了。下次再见捏Bye~~~\n","slug":"ACM学习笔记day31","date":"2023-02-18T08:34:37.000Z","categories_index":"ACM","tags_index":"打卡,学习,DP,动态规划,背包问题,背包,多重背包,分组背包","author_index":"Ausert"},{"id":"26c83eef7dc2b42905d68bf63d792926","title":"ACM学习笔记day30 (01背包，完全背包,多重背包(朴素解法))","content":"今天的内容是01背包多重背包完全背包。算是开启DP专题了。01背包是作为最关键的一个题目。其他完全背包和多重背包其实就是他的扩展。理解了01背包，理解其他的背包其实不难。\n\n\n01背包01背包问题的解法，先从朴素开始。我们定义一个二维数组作为我们dp的数组。f[i][j]的意义为从前i个物品中拿，背包容量为j的情况下最大的价值量。那么我们容易得到，对于第i个物品，我们可以拿或者不拿。因为只有一件所以只有这两个选项。如果不拿，那么简单,f[i][j]&#x3D;f[i-1][j]。如果拿，那么f[i][j]&#x3D;f[i-1][j-v[i]]+w[i];当然这里j要大于等于v[i]的。所以我们背包的code也就非常自然的得出来了。\nac code:\n#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nconst int N &#x3D;  1010;\nint f[N][N];\nint n,m;\nint w[N],v[N];\n\nint main()&#123;\n    cin&gt;&gt;n&gt;&gt;m;\n    for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;\n        cin&gt;&gt;v[i]&gt;&gt;w[i];\n    &#125;\n    for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;\n        for(int j&#x3D;0;j&lt;&#x3D;m;j++)&#123;\n            f[i][j]&#x3D;f[i-1][j]; &#x2F;&#x2F;这边从0开始和从1开始都是可以的，j&#x3D;0的时候相当于初始化了背包为零的时候所有的值，也就是都是零。\n                               &#x2F;&#x2F;不过这里因为数组开在堆里面，所以都一样的。\n            if(j&gt;&#x3D;v[i])&#123;\n                f[i][j]&#x3D;max(f[i][j],f[i-1][j-v[i]]+w[i]);\n            &#125;\n        &#125;\n    &#125;\n    int res&#x3D;0;\n    for(int i&#x3D;0;i&lt;&#x3D;m;i++)&#123;\n        res&#x3D;max(res,f[n][i]);\n    &#125;\n    cout&lt;&lt;res&lt;&lt;endl;\n    return 0;\n&#125;\n\n\n那么我们可不可以将这个二维数组降低一个维度，从而减少空间复杂度呢？答案是可以的。我们可以从递推式中发现，我们需要的只是第i层的数据和第i-1层的数据。所以说我们可以使用滚动数组来做。不断维护第i层和第i-1层就可以了。\n降低维数之后的code为：\n#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nconst int N &#x3D; 1010;\nint w[N],v[N];\nint n,m;\nint dp[N];\n\nint main()&#123;\n    cin&gt;&gt;n&gt;&gt;m;\n    for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;\n        cin&gt;&gt;v[i]&gt;&gt;w[i];\n    &#125;\n    for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;\n        for(int j&#x3D;m;j&gt;&#x3D;0;j--)&#123;\n            dp[j]&#x3D;dp[j];\n            &#x2F;&#x2F;这里原来是dp[i][j]&#x3D;dp[i-1][j];去掉一维之后，dp[j]的值就是没更新前的值。实际上没啥意义（\n            if(j-v[i]&gt;&#x3D;0)&#123;\n                dp[j]&#x3D;max(dp[j],dp[j-v[i]]+w[i]); \n                &#x2F;&#x2F;这里原来是dp[i][j]&#x3D;max(dp[i][j],dp[i-1][j-v[i]]+w[i])。\n                &#x2F;&#x2F;因为我们第二个式子中我们要的是上一行的j-v[i]的值。而如果我们还是按照原来的做法，j从0开始遍历的话，每次访问j-v[i]的时候都是更新之后的，所以我们要倒着遍历。从而确保\n                &#x2F;&#x2F;我们访问的是i-1行的j-v[i]的值而不是i行的。\n            &#125;\n        &#125;\n    &#125;\n    cout&lt;&lt;dp[m]&lt;&lt;endl;\n    return 0;\n&#125;\n\n\n完全背包问题完全背包问题就是使得每一件物品都可以拿无限多个。\n那么其实我们基于01背包的做法，对于第i个物品。我们有若干个选择，可以拿0个，拿1个，2个….直到背包里面放不下了。也就是说那么我们按照思路来做，只需要在01背包的二维实现中在最里面再套一个循环就可以了。但是这样会使得时间复杂度变为O(n^3)。对于1000个数据是会超时的。所以我们要优化。注意到：\n\n\n\n\n\n\n\n\n\nf[i][j]&#x3D;max(f[i-1][j],f[i-1][j-v[i]]+w[i],f[i-1][j-2v[i]]+2w[i]….)而我们对j进行一个换元。j&#x3D;j-v[i];f[i][j-v[i]]&#x3D;max(f[i-1][j-v[i]],f[i-1][j-2*v[i]]+w[i]…..)\n上面那条等式max的除了第一个元素的部分，其实就是f[i][j-v[i]]+w[i]。所以我们不用里面再套一个循环，直接用\n\n\n\n\n\n\n\n\n\nf[i][j]&#x3D;max(f[i-1][j],f[i][j-v[i]]+w[i])即可。\nac code:\n#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nconst int N &#x3D; 1010;\nint n,m;\nint v[N],w[N];\nint dp[N][N];\n\nint main()&#123;\n    cin&gt;&gt;n&gt;&gt;m;\n    for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;\n        cin&gt;&gt;v[i]&gt;&gt;w[i];\n    &#125;\n    for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;\n        for(int j&#x3D;0;j&lt;&#x3D;m;j++)&#123;\n            dp[i][j]&#x3D;dp[i-1][j];\n            if(j&gt;&#x3D;v[i])&#123;\n                dp[i][j]&#x3D;max(dp[i][j],dp[i][j-v[i]]+w[i]);\n            &#125;\n        &#125;\n    &#125;\n    cout&lt;&lt;dp[n][m]&lt;&lt;endl;\n    return 0;\n&#125;\n\n那么对于完全背包我们能不能也优化到一维数组呢？也是可以的。\n注意到：\n\n\n\n\n\n\n\n\n\ndp[i][j]&#x3D;max(dp[i][j],dp[i][j-v[i]]+w[i]);\n和01背包类似，如果我们把i这一维优化了，我们需要使用的是dp[i][j-v[i]]也就是说我们已经更新过的数据。那么和01背包的优化类似，但是相反，我们这里需要从头开始遍历，而不是倒过来遍历j。\n优化的code:\n#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nconst int N &#x3D; 1010;\nint n,m;\nint v[N],w[N];\nint dp[N];\n\nint main()&#123;\n    cin&gt;&gt;n&gt;&gt;m;\n    for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;\n        cin&gt;&gt;v[i]&gt;&gt;w[i];\n    &#125;\n    for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;\n        for(int j&#x3D;v[i];j&lt;&#x3D;m;j++)&#123;\n            \n                dp[j]&#x3D;max(dp[j],dp[j-v[i]]+w[i]);\n            \n        &#125;\n    &#125;\n    cout&lt;&lt;dp[m]&lt;&lt;endl;\n    return 0;\n&#125;\n\n多重背包I多重背包就是完全背包的基础上，给你限制了每个物品拿的个数。因为这个I是朴素版本的，也就是说给的n和m比较小，n三次方的复杂度可以过。所以按照完全背包的朴素做法去做就可以了。当然要注意，循环的上限是有两个，一个是背包容量，一个是物品件数限制。\n下面为ac code:\n#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nint n,m;\nconst int N &#x3D; 110;\nint dp[N][N];\nint v[N],w[N],s[N];\n\nint main()&#123;\n    cin&gt;&gt;n&gt;&gt;m;\n    for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123; \n        cin&gt;&gt;v[i]&gt;&gt;w[i]&gt;&gt;s[i];\n    &#125;\n    for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;\n        for(int j&#x3D;0;j&lt;&#x3D;m;j++)&#123;\n            dp[i][j]&#x3D;dp[i-1][j];\n            for(int k&#x3D;1;k&lt;&#x3D;s[i]&amp;&amp;j&gt;&#x3D;k*v[i];k++)&#123;\n              dp[i][j]&#x3D;max(dp[i][j],dp[i-1][j-k*v[i]]+k*w[i]);  \n            &#125;\n        &#125;\n    &#125;\n    cout&lt;&lt;dp[n][m]&lt;&lt;endl;\n    return 0;\n&#125;\n\n接下来还有一个用二进制优化的多重背包，下次再写XD。我们下次见捏。Bye.\n","slug":"ACM学习笔记day30","date":"2023-02-11T11:53:11.000Z","categories_index":"ACM","tags_index":"ACM,打卡,学习,蒟蒻,DP,动态规划","author_index":"Ausert"},{"id":"de8de93bec780c9d57906902a53cb751","title":"Chicken McNugget Theorem","content":"麦乐鸡定理(bushi)链接\n\n\n\n\n\n\n\n\n\nThe Chicken McNugget Theorem (or Postage Stamp Problem or Frobenius Coin Problem) states that for any two relatively prime positive integers $m,n$,the greatest integer that cannot be written in the form $am + bn$ for nonnegative integers $a, b$ is $mn-m-n$.\n就是说对于任意两个互质的正整数x,y，最大的不能用ax+by来表示的非负整数是xy-x-y。也就是说大于xy-x-y的数字一定能够用ax+by来表示。小于的则不一定。\n","slug":"Chicken-McNugget-Theorem","date":"2023-02-09T07:50:47.000Z","categories_index":"数学","tags_index":"数学,定理","author_index":"Ausert"},{"id":"8af78f8e46bb9ac28caa93ffafd43362","title":"ACM学习笔记day29 (Nim游戏，台阶-Nim游戏)","content":"今天的内容是博弈论的一部分（后面有涉及到SG函数和MEX函数的额，还没听懂（所以只有这两个了。两个一个是Nim游戏是最基础的模型，台阶-Nim游戏是Nim游戏的进阶版本。\n\n\n\nNim游戏就是两个人轮流拿，随便拿几个，随便拿哪一堆的，拿到最后谁不能操作了，谁就输了。这里我们要讲两个概念，一个是先手必胜状态，一个是先手必败状态。什么意思呢？就是先手必胜的状态下，先手是必胜的（这不废话。必败同理。然后这个先后手不是绝对的，是相对的。比如说A和B Van游戏一开始的时候A是先手必败的，然后A做了一堆nb的操作。然后turn转到了B这里，这个时候B就可以看成是先手的，因为A做了很多nb的操作，导致了轮到B的时候B进入了先手必败的状态。这就是这两个概念。\n知道了这两个概念，我们看这个问题。首先我们抛出个结论。a1^a2^a3^a4…..^an&#x3D;0 先手必败。a1^a2^a3^a4…..^an!&#x3D;0 先手必胜。\n为什么？\n\n首先我们来看0^0^0^…..^0&#x3D;0的状态，因为石子啥都没有，所以先手是必败的。没法操作了。\n然后我们设a1^a2^a3^a4…..^an&#x3D;x!&#x3D;0。 对于x的二进制表达式中，我们令k为最左边的那个1的位置，那么对于所有的ai，一定存在某个ai他的第k为是1的。不然第k位的结果肯定是零。 那么我们就可以得到ai^x&lt;ai 为什么？其实很简单，因为第k位变成零了，前面的位数最小就是全是零，不然的话肯定会变大的。 那么我们这个时候先手的这个人，就可以通过把这个ai变成ai^x，因为ai^x&lt;ai的所以是肯定合法的。 此时的异或结果为a1^a2….^ai^x^…..an&#x3D;x^x&#x3D;0。此时因为先手人操作完了，此时留给后手的那个人是后手必败状态，那么也就说明了。 为什么异或结果不为零先手一定必胜。 因为先手一定有办法可以把结果变成0然后交给后手的那个人。\n然后我们再来看a1^a2^a3^a4…..^an&#x3D;0的情况，这个时候因为先手是必败的。那么先手 有没有什么办法操作一下，可以使得传给后手的时候异或值还是零呢？ 答案是没有的。 我们用反证法来证明。 如果存在一个ai，使得我们把ai的值变成ai’，并且结果还是零的。 也就是说 a1^a2….^ai…..an&#x3D;0。 a1^a2….^ai’…..an&#x3D;0。 我们将两式一起异或一下。 因为除了ai其他都是有一样的，所以结果就是 ai^ai’&#x3D;0。 而要让这个式子等于0，只有让ai等于ai’，而因为不能不进行操作，所以这个式子是不成立的。 所以我们没有把饭把这个先手必败的状态传递下去。\n\n综上就是这个结论的证明了。知道了证明之后，代码是很简单的。\nac code:\n#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\n\n\nint main()&#123;\n    int n;\n    cin&gt;&gt;n;\n    int res&#x3D;0;\n    for(int i&#x3D;0;i&lt;n;i++)&#123;\n        int x;\n        cin&gt;&gt;x;\n        res^&#x3D;x;\n    &#125;\n    if(!res)&#123;\n        cout&lt;&lt;&quot;No&quot;&lt;&lt;endl;\n    &#125;\n    else&#123;\n        cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl;\n    &#125;\n    return 0;\n&#125;\n\n台阶-Nim游戏这个是上面Nim游戏的一个变体。石子还是可以随便拿多少个的，只不过不是拿掉了，而是放到下面一个台阶上，地面上的就不允许碰了。其实我们发现，只要石子还在台阶上，那么其实不管在哪个台阶上都是没关系的。只有第一个台阶，才会把石子真正带出去。所以我们其实发现，偶数台阶是无关结果的。因为当一个人将偶数台阶的部分石子带到奇数台阶上的时候，另外一个是可以做这样的镜像操作。相当于啥都没干，而奇数台阶的话就不一定了，我们一个人把第一层的拿到了地板上，那么另外一个人显然不能做镜像操作了。\n接下来抛出结论:a1^a3^a5….a2n-1&#x3D;0 先手必败。a1^a3^a5….a2n-1!&#x3D;0 先手必胜。\n关于为什么只看奇数的，不看偶数的，前面已经讲了，偶数的话，另外一个人就可以做镜像操作，从而让这个异或值保持不变。然后其他的部分的话，和Nim游戏是一样的，异或值不等于零的话，总有办法可以让异或值为零，然后让对手必败。证明方法是类似的。\n下面为ac code:\n#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\n\n\nint main()&#123;\n    int n;\n    cin&gt;&gt;n;\n    int res&#x3D;0;\n    for(int i&#x3D;0;i&lt;n;i++)&#123;\n        int x;\n        cin&gt;&gt;x;\n        if(i%2&#x3D;&#x3D;0)&#123;\n            res^&#x3D;x;\n        &#125;\n    &#125;\n    if(res&#x3D;&#x3D;0)&#123;\n        cout&lt;&lt;&quot;No&quot;&lt;&lt;endl;\n    &#125;\n    else&#123;\n        cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl;\n    &#125;\n&#125;\n\n\n好的 ，那么这些就是这个blog的全部内容了。实际上博弈论的重要内容还没出来。鳖问，问就是我没看懂（之后懂了再写吧。Bye~\n","slug":"ACM学习笔记day29","date":"2023-02-08T08:10:48.000Z","categories_index":"ACM","tags_index":"ACM,打卡,学习,数学,博弈论,Nim游戏","author_index":"Ausert"},{"id":"cd92aa8f26118d15f6c9920aff860d6f","title":"ACM学习笔记day28 (组合数的应用——满足条件的01序列，容斥原理)","content":"今天的内容是组合数的应用——满足条件的01序列和容斥原理。关于这个满足条件的01序列，其实涉及到了一个特殊的数字卡特兰数。这个我们等会会讲这个。\n\n\n\n满足条件的01序列题目意思就是给你n个0，n个1，让你排出来一个序列，使得对于任意的前缀，0的数量是大于等于1的数量的。问你这样的序列有多少个？对于这个问题，我们要进行转化。接下里，我们给出一个例子来进行讲解，怎么转化。比如给你6个0,6个1。我们在平面直角坐标系中从(0,0)开始走到(6,6)。按照方格子来走的。我们规定0是向右走一格，1是向上走一格。那么任意一条(0,0)-&gt;(6,6)的路径都可以用01序列来表示。也就是说，题目要求我们的序列，就转化为了图上的一条路径。\n\n比如一条路径是000000111111就是如下所示：\n\n因为题目中要求任意一段前缀中，0的个数必须大于等于1的个数。也就是说在图中，我们走过的每一段路，向右的步数要大于向上的步数。也就是说我们的每一段路要在副对角线下方，当然擦边是可以的。这个时候正好相等呗。\n\n好，接下来我们看图中，如果一条从(0,0)到(6,6)的路径越过了绿线，那他就是一条非法路径，也就是不满足条件的序列。反之就是合法的路径。那么总的路径是多少条？很显然，相当于12个格子，里面填6个1，6个0，C[12][6]条路径。总共是这么多的路径。那么我们要求合法路径，不就等于总的路径-非法路径吗？接下来。我们取任何一条非法路径来看一下。\n\n那根红线代表的就是非法线，如果路径碰到了红线就非法了。橙色的一条线为任意的一条非法路径。我们将这条路径第一次碰到红线往后的部分，按照绿线进行轴对称过去。\n\n后半部分就变成了这里的这根绿色粗线。他最终到达的地方是(5,7)。这里我们发现任何一条非法路径轴对称过去一定是对应一条到(5,7)的路径的。那么反过来，任何一条到(5,7)的路径一定是对应一条非法路径的。那么其实，我们要求有多少非法路径，也就是求到(5,7)的路径有多少条。而这个很好求，就是12个格子里面选5个位置来放0其他是1，自然就是C[12][5];那么对于(6,6)这种情况，结果就是C[12][6]-C[12][5]。那么对于任意的n，结果就是C[2n][n]-C[2n][n-1]。化简一下就是C[2*n][n]&#x2F;(n+1)。而这个东西就是卡特兰数。很多方案类的问题的结果都是卡特兰数。\n下面是 ac code：\n#include&lt;bits&#x2F;stdc++.h&gt;\nusing  namespace std;\ntypedef long long ll;\nconst int mod &#x3D; 1e9+7;\n\nll qmi(ll a,ll k,ll p)&#123;\n    ll res&#x3D;1;\n    while(k)&#123;\n        if(k&amp;1)&#123;\n            res&#x3D;res*a%p;\n        &#125;\n        a&#x3D;a*a%p;\n        k&gt;&gt;&#x3D;1;\n    &#125;\n    return res;\n&#125;\nll C(ll a,ll b,ll p)&#123;\n    ll res&#x3D;1;\n    for(int i&#x3D;1,j&#x3D;a;i&lt;&#x3D;b;i++,j--)&#123;\n        res&#x3D;res*j%mod;\n        res&#x3D;res*qmi(i,mod-2,mod)%mod;\n    &#125;\n    return res;\n&#125;\nint main()&#123;\n    int n;\n    cin&gt;&gt;n;\n    cout&lt;&lt;C(2*n,n,mod)*qmi(n+1,mod-2,mod)%mod&lt;&lt;endl;\n    return 0;\n&#125;\n\n能被整除的数这个题是容斥原理的一个体现。容斥原理是啥这里不多说了。也是离散的基础内容。对于这题来说，要求1n中能被给的质数中任意一个数字整除的个数。也就是说：1n中能被p1,p2,p3整除的加起来，再减掉能被p1*p2,p1*p3,p1*p4,…..pn-1*pn整除的，再加上能被p1*p2p3,p1*p2*p4…..等等整除的。后面的依次类推。按照上述规律进行求解即可。注意这里因为我们要模拟一下这个过程，所以时间复杂度会根据质数的个数m呈指数级的往上涨。为什么呢？对于这么多pi的任意项乘积，我们可以使用dfs来做，每一位都dfs过去就可以了。我们也可以用位运算来看。每个数字都有取或者不取的两种状态，那么每一个pi任意项的乘积我们就可以表示为一个01序列而这个序列可以视作二进制数字从而转化为二进制数字。从而总的数字数量为1&lt;&lt;m。我们对于每一个枚举过去的i，进行二进制拆解，而这个拆解的最大长度就是m，质数的个数。所以时间复杂度是O(m2^m)。这题数据的是正好算好的，是不会超时的。哦对了，对于1~n中能被p整除的数字的数量就是n&#x2F;p。这个稍微自己想一下就可以了，不难理解的。\n下面为ac code:\n#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\n\nint main()&#123;\n    ll n,m;\n    cin&gt;&gt;n&gt;&gt;m;\n    vector&lt;ll&gt; a(m);\n    for(int i&#x3D;0;i&lt;m;i++)&#123;\n        cin&gt;&gt;a[i];\n    &#125;\n    ll res&#x3D;0;\n    for(int i&#x3D;1;i&lt;1&lt;&lt;m;i++)&#123;\n        ll cnt&#x3D;0,ans&#x3D;1;\n        for(int j&#x3D;0;j&lt;m;j++)&#123;\n            if(i&gt;&gt;j&amp;1)&#123;\n                cnt++;\n                ans*&#x3D;a[j];\n                if(ans&gt;n)&#123; &#x2F;&#x2F;注意这里如果n已经比ans小的话，直接就可以结束了，不然之后的话可能结果会爆longlong。\n                    ans&#x3D;-1;\n                    break;\n                &#125;\n            &#125;\n        &#125;\n        if(ans&#x3D;&#x3D;-1)&#123;\n            continue;\n        &#125;\n        if(cnt%2&#x3D;&#x3D;1)&#123;\n            res+&#x3D;n&#x2F;ans;\n        &#125;\n        else&#123;\n            res-&#x3D;n&#x2F;ans;\n        &#125;\n    &#125;\n    cout&lt;&lt;res&lt;&lt;endl;\n    return 0;\n&#125;\n\nOK。这次内容就那么多，接下来的一个博弈论的话，我准备放到写到一个blog里面去。Bye~\n","slug":"ACM学习笔记day28","date":"2023-02-07T09:31:39.000Z","categories_index":"ACM","tags_index":"ACM,打卡,学习,数学,组合数,容斥原理","author_index":"Ausert"},{"id":"ee586e84b57b3261ae39e785bb3a8c62","title":"ACM学习笔记day27(求组合数的四种办法)","content":"今天的内容是求组合数の四种办法。前三种是逐渐应对给的数据量变大的情况的。第四种是应对得到的结果太大会把longlong都爆掉的情况的。\n\n\n注意：本篇中，涉及C[a][b]的均是以下组合数表达式。\n\n因为这个blog主题不支持latex语言，所以也没办法现敲公式。\n求组合数I这种求组合数的办法是很简单的方法，也就是预处理的办法，来实现O(1)的查询。如何预处理？题目要我们求c[a][b]，a,b最大就是2000，那我们把C[1][0]~C[2000][2000]全部算出来不就可以了。然后每次询问的时候直接去数组里面查找就可以了。这种方法的时间复杂度取决于a和b的大小，设最大为N，那么时间复杂度自然就是O(N^2)。那么我们要如何在N^2的限制下求完全部的组合数呢？其实存在以下这个递推式。\n\n\n\n\n\n\n\n\n\nc[a][b]&#x3D;c[a-1][b]+c[a-1][b-1]\n这个式子也很好理解，从a个东西中拿b个，总共就分为两种情况。对于其中的任何一个特定的东西，我们有拿他和不拿两种，如果拿他，那么我们就在剩下的a-1个中拿b-1个，反之，就在剩下的a-1个中拿b个。严格的数学证明就是用定义去证明，写成阶乘的形式，然后化简就可以了。\n因此有了这个递推式之后，我们就可以直接预处理出所有组合数的值了，当然别忘了取余。\nac code:\n#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nconst int N &#x3D; 2010,mod &#x3D; 1e9+7;\nint n;\nint c[N][N];\n\nvoid init()&#123;\n    for(int i&#x3D;0;i&lt;N;i++)&#123;\n        for(int j&#x3D;0;j&lt;&#x3D;i;j++)&#123;\n            if(j&#x3D;&#x3D;0)&#123;\n                c[i][j]&#x3D;1; &#x2F;&#x2F;如果j为零的话，组合数的值固定为1的，这里就是边界问题。\n            &#125;\n            else&#123;\n                c[i][j]&#x3D;(c[i-1][j]+c[i-1][j-1])%mod;\n            &#125;\n        &#125;\n    &#125;\n&#125;\nint main()&#123;\n    cin&gt;&gt;n;\n    init();\n    while(n--)&#123;\n        int a,b;\n        cin&gt;&gt;a&gt;&gt;b;\n        cout&lt;&lt;c[a][b]&lt;&lt;endl;\n    &#125;\n    return 0;\n&#125;\n\n求组合数II这个情况下呢，给的a和b他的最大值N，已经比较大了。如果再沿用上面的做法，是行不通的，因为N^2肯定会超时的。那么这里我们也是使用预处理的办法，不过我们不是把所有的组合数结果直接预处理出来。而是预处理出来阶乘的结果。然后我们对于每一个询问，按照定义，用已经知道的阶乘的结果去计算就可以了。当然这里会有一个问题。结果是要求取模的。我们预处理阶乘的时候也是要取模的。不然肯定会爆longlong的。那么如果我们直接用阶乘去作除法的话，很明显是不对的。因为两个数相除的取模结果是不等于分别取模然后相除的结果的。那么这里我们就要用到一个数的逆元。逆元其实就是同余一个数的情况下，一个数的倒数而已。也就是说对于我们求到的每一个阶乘，我们同时要求一个他的同余mod的逆元。比如我们求导3!的时候，我们要求一下他的同余mod的逆元，然后存起来。最后我们求C[a][b]的时候原本应该是a!&#x2F;b!&#x2F;(a-b)!这里的除以b!就可以改成乘以b!的逆元，从而保证了计算的正确性。(a-b)!同理。当然这题他给的模数1e9+7是质数，所以可以用费马小定理用快速幂去求逆元，不然的话就只能是扩欧了。\nac code:\n#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\nconst int N &#x3D; 1e5+10;,mod&#x3D;1e9+7;\nint n;\nll fact[N],infact[N];\n\nll qmi(ll a,ll b,ll c)&#123;\n    ll res&#x3D;1;\n    while(b)&#123;\n        if(b&amp;1)&#123;\n            res&#x3D;res*a%c;\n        &#125;\n        a&#x3D;a*a%c;\n        b&gt;&gt;&#x3D;1;\n    &#125;\n    return res;\n&#125;\nint main()&#123;\n    cin&gt;&gt;n;\n    fact[0]&#x3D;infact[0]&#x3D;1;\n    for(int i&#x3D;1;i&lt;N;i++)&#123;\n        fact[i]&#x3D;fact[i-1]*i%mod;\n        infact[i]&#x3D;infact[i-1]*qmi(i,mod-2,mod)%mod; &#x2F;&#x2F;这里阶乘的逆元也满足递推关系式的。\n        &#x2F;&#x2F;e.g 1&#x2F;3!是不是就是1&#x2F;2!*1&#x2F;3?只不过这里都是对应数字的逆元罢了。这里的qmi就是i的模mod下的逆元。\n    &#125;\n    while(n--)&#123;\n        ll a,b;\n        cin&gt;&gt;a&gt;&gt;b;\n        cout&lt;&lt;fact[a]*infact[b]%mod*infact[a-b]%mod&lt;&lt;endl;\n    &#125;\n    return 0;\n&#125;\n算法的时间复杂度是O(N*log(mod-2))。这里这个N是a和b的最大值，mod是他给的模数。\n求组合数III这题的话，给的a和b的数据范围特别大，N都一定到了longlong类型的上限了。那么很显然上一个预处理阶乘的办法肯定是不行的了。这里我们就不能够预处理的。因为数据太大了。同时我们注意到他给的询问次数很少就20次。那么其实我们可以边询问边计算。那么怎么才能够快速的计算出来这个结果呢？这里我们要使用到Lucas定理。什么是卢卡斯定理？如下：\n\n对于乘积的左边，我们可以直接用组合数的定义去求，对于右边我们可以递归的使用Lucas定理。这样我们就使用了Lucas定理解决了这个问题。关于Lucas定理的证明，理解起来不难的，就是一个构造性的证明。不做要求，会用Lucas就可以了。证明如下：\n\n既然知道了Lucas定理，那么我们接下来做这题就很很简单了。公式怎么说就怎么写就可以了。\n当然在用定义求组合数的时候，因为涉及到了除法，在同余的情况下，就是乘上一个他的逆元就行了。同样，因为p为质数，所以求逆元用快速幂就可以了。不要真的做除法会出问题的（\nac code:\n#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\nint n;\nint p;\n\nll qmi(ll a,ll b,ll c)&#123;\n    ll res&#x3D;1;\n    while(b)&#123;\n        if(b&amp;1)&#123;\n            res&#x3D;res*a%c;\n        &#125;\n        a&#x3D;a*a%c;\n        b&gt;&gt;&#x3D;1;\n    &#125;\n    return res;\n&#125;\n\nll C(ll a,ll b)&#123;\n    ll res&#x3D;1;\n    for(int i&#x3D;1,j&#x3D;a;i&lt;&#x3D;b;j--,i++)&#123;\n        res&#x3D;res*j%p;\n        res&#x3D;res*qmi(i,p-2,p)%p;\n    &#125;\n    return res; \n&#125;\n\nll lucas(ll a,ll b)&#123;\n    if(a&lt;p&amp;&amp;b&lt;p) return C(a,b);\n    else&#123;\n        return C(a%p,b%p)*lucas(a&#x2F;p,b&#x2F;p)%p;\n    &#125;\n&#125;\n\nint main()&#123;\n    cin&gt;&gt;n;\n    while(n--)&#123;\n        ll a,b;\n        cin&gt;&gt;a&gt;&gt;b&gt;&gt;p;\n        cout&lt;&lt;lucas(a,b)&lt;&lt;endl;\n    &#125;\n    return 0;\n&#125;\n我们设N为给的数据的最大值。这个算法的时间复杂度是\n\n对于后面的两个log函数，如果p很大，那么乘积前面那个就会很小，反之亦然。所以总的来说，时间复杂度不会超过1e8的。\n求组合数IV这个第四种求组合数的方法呢。是对于没有让你取模的情况下的方法。也就是涉及到了高精度计算。d如果我们就顺其自然的去做，就会涉及到了高精度乘除法。并且时间复杂度也会比较高。所以我们采用的办法是，将组合数的结果拆分成质因数的次幂乘积式。然后用高精度乘法来一个一个计算过去。那么怎么得到这个式子就是一个难点。我们按照组合数计算的定义，组合数等于三个阶乘的乘除的式子。那么我们求出阶乘的质因数次幂表达式，不就可以得出来组合数的了？如何来得到阶乘的质因数次幂表达式？\n这里，我们需要采用筛质数的办法，把所有范围内的质数全部筛出来，然后一个一个去检查阶乘中有几个这个数。那么如何检查？\n对于n! 他分解质因数之后质数p的次幂就等于以下表达式\n\n其中n&#x2F;p就代表了什么？n!中1个p，2个p…的个数。p^2同理，这样我们就能够把n!里面所有的p的个数求出来了，也就是我们要求的p的次幂。我们求出了一个阶乘的，对于阶乘相除的，就把对应次幂的相减就是了，因为是乘除法。\nac code:\n#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nvector&lt;int&gt; primes;\nconst int N &#x3D; 5010;\nbool flag[N];\nint cimi[N];\n\nint getcimi(int n,int p)&#123;\n    int res&#x3D;0;\n    while(n)&#123;\n        res+&#x3D;n&#x2F;p;\n        n&#x2F;&#x3D;p;\n    &#125;\n    return res;\n&#125;\nvoid getprimes(int a)&#123;\n    for(int i&#x3D;2;i&lt;&#x3D;a;i++)&#123;\n        if(!flag[i])&#123;\n            primes.push_back(i);\n        &#125;\n        for(int j&#x3D;0;primes[j]*i&lt;&#x3D;a;j++)&#123;\n            flag[primes[j]*i]&#x3D;true;\n            if(i%primes[j]&#x3D;&#x3D;0) break;\n        &#125;\n    &#125;\n&#125;\n\nvector&lt;int&gt; mulp(vector&lt;int&gt; a,int b)&#123;\n    int t&#x3D;0;\n    vector&lt;int&gt; res;\n    for(int i&#x3D;0;i&lt;a.size();i++)&#123;\n        t+&#x3D;a[i]*b;\n        res.push_back(t%10);\n        t&#x2F;&#x3D;10;\n    &#125;\n    while(t)&#123;\n        res.push_back(t%10);\n        t&#x2F;&#x3D;10;\n    &#125;\n    return res;\n&#125;\n\nint main()&#123;\n    int a,b;\n    cin&gt;&gt;a&gt;&gt;b;\n    getprimes(a);\n    \n    for(int i&#x3D;0;i&lt;primes.size();i++)&#123;\n        int p&#x3D;primes[i];\n        cimi[i]&#x3D;getcimi(a,p)-getcimi(b,p)-getcimi(a-b,p);\n    &#125;\n    vector&lt;int&gt; res;\n    res.push_back(1);\n    for(int i&#x3D;0;i&lt;primes.size();i++)&#123;\n        for(int j&#x3D;0;j&lt;cimi[i];j++)&#123;\n            res&#x3D;mulp(res,primes[i]);\n        &#125;\n    &#125;\n    \n    for(int i&#x3D;res.size()-1;i&gt;&#x3D;0;i--)&#123;\n        cout&lt;&lt;res[i];\n    &#125;\n    cout&lt;&lt;endl;\n    \n\n    \n    return 0;\n&#125;\n\nOK,那么至此就是求组合数的四种办法了，前三种是一种比一种优化，第四种是专门应对不求模的情况的。我们下次再见Bye~\n","slug":"ACM学习笔记day27","date":"2023-02-05T09:20:05.000Z","categories_index":"ACM","tags_index":"ACM,打卡,学习,数学,组合数","author_index":"Ausert"},{"id":"1a520a07ea86cfe9d127f0b6811d1363","title":"ACM学习笔记day26 (高斯消元解线性方程组和异或方程组)","content":"今天的内容是使用高斯消元解线性方程组和异或方程组。什么是高斯消元，不多说，线代的基本内容。\n\n\n高斯消元解线性方程组用高斯消元解线性方程组的时候，编程解决其实就是一个模拟的事情。我们写程序去模拟我们的实际进行的步骤。该模板的时间复杂度为O(n^3)。可以看到时间复杂度还是很高的。如果有1k条方程的话，1s铁超时了。接下来就是我们编程模拟高斯消元的步骤。\n消元的最终目的是把增广矩阵消成阶梯型矩阵，因为是n条方程n个未知数，所以也就是化成上三角的形式。这里我们使用c和r来表示我们消到了第r行，第c列，r行往上的，c列往左的都是已经完事的了。\n\n\n\n\n\n\n\n\n\nstep1: 在第c列，r行及以下的地方寻找绝对值最大一个数。step2: 找到那个数字之后，将他这一行和第r行交换数据。step3: 将现在的第r行，第c列的数据化成1，当然第r行的所有数据都要改变的。step4: 用第r行的数据，去消r行往下的数据，将r+1，r+2,….n-1行的第c列的数据都消成零。step5: r++，代表解决了一行，for循环中也会有c++，代表解决了一列。\nNote：\n\n\n\n\n\n\n\n\n\n\n实际上，我们进行的过程是一列一列的去消的，所以我们要枚举这个列。\n在step1之后，如果发现这个最大数的值是0，说明这一列都是零，直接continue去下一行就可以了。\n在消完了n列之后，如果r的值小于n，说明有零行，这个时候要判断一下时候会是无穷解或者是无解的情况了。\n事实上，这个r有点像是这个矩阵的秩的。可以辅助你的理解。为什么r&lt;n就一定不是只有唯一解了。\n\n结果上来看，我们使用0来代表有唯一解，-1代表无解，1,代表无穷多解。\n下面为题目的ac code:\n#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nconst int N &#x3D; 110;\nconst double eps&#x3D;1e-8;\ndouble a[N][N];\nint n;\n\nint gauss()&#123;\n    int r,c;\n    for(c&#x3D;0,r&#x3D;0;c&lt;n;c++)&#123;\n        int maxi&#x3D;r;\n        for(int i&#x3D;r;i&lt;n;i++)&#123;\n            if(abs(a[i][c])&gt;abs(a[maxi][c]))&#123;\n                maxi&#x3D;i;\n            &#125;\n        &#125;\n        if(abs(a[maxi][c])&lt;eps)&#123;\n            continue;\n        &#125;\n        for(int i&#x3D;c;i&lt;n+1;i++) swap(a[maxi][i],a[r][i]);\n        for(int i&#x3D;n;i&gt;&#x3D;c;i--) a[r][i]&#x2F;&#x3D;a[r][c];\n        for(int i&#x3D;r+1;i&lt;n;i++)&#123;\n            if(abs(a[i][c])&gt;eps)&#123;\n                for(int j&#x3D;n;j&gt;&#x3D;c;j--)&#123;\n                    a[i][j]-&#x3D;a[r][j]*a[i][c];\n                &#125;\n            &#125;\n        &#125;\n        r++;\n    &#125;\n    if(r&lt;n)&#123;\n        for(int i&#x3D;r;i&lt;n;i++)&#123;\n            if(abs(a[i][n])&gt;eps)&#123;\n                return -1;\n            &#125;\n        &#125;\n        return 1;\n    &#125;\n    for(int i&#x3D;n-1;i&gt;&#x3D;0;i--)&#123;\n        for(int j&#x3D;n-1;j&gt;i;j--)&#123;\n            a[i][n]-&#x3D;a[i][j]*a[j][n];\n        &#125;\n    &#125;\n    \n    return 0;\n&#125;\nint main()&#123;\n    cin&gt;&gt;n;\n    for(int i&#x3D;0;i&lt;n;i++)&#123;\n        for(int j&#x3D;0;j&lt;&#x3D;n;j++)&#123;\n            cin&gt;&gt;a[i][j];\n        &#125;\n    &#125;\n    int res&#x3D;gauss();\n    if(res&#x3D;&#x3D;-1) cout&lt;&lt;&quot;No solution&quot;&lt;&lt;endl;\n    else if(res&#x3D;&#x3D;1) cout&lt;&lt;&quot;Infinite group solutions&quot;&lt;&lt;endl;\n    else&#123;\n        for(int i&#x3D;0;i&lt;n;i++)&#123;\n            if(abs(a[i][n])&lt;eps) a[i][n]&#x3D;0;\n            cout&lt;&lt;setiosflags(ios::fixed)&lt;&lt;setprecision(2)&lt;&lt;a[i][n]&lt;&lt;endl;\n        &#125;\n    &#125;\n    return 0;\n&#125;\n\n\n高斯消元解异或方程组什么是异或方程组?\n形如下面的方程我们称之为异或方程：\n\n\n\n\n\n\n\n\n\n1^0^1^x&#x3D;3\n这题中，已经明确说明了数据只会是0和1。那么解这样的异或方程组，我们同理也是使用高斯消元法来解决。这里因为系数已经是1了，所以没有将系数化为1的做法。并且，由于异或有结合律和交换律，所以我们对进行两条方程的异或是完全可以的。也就是可以做到消参的过程。这也就是为什么异或方程组也可以用高斯消元来解。步骤和上面类似，甚至少了几步。\n下面为ac code:\n#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nconst int N &#x3D; 110;\nint a[N][N];\nint n;\nint gauss()&#123;\n    int c,r;\n    for(c&#x3D;0,r&#x3D;0;c&lt;n;c++)&#123;\n        int t&#x3D;r;\n        for(int i&#x3D;r;i&lt;n;i++)&#123;\n            if(a[i][c]&#x3D;&#x3D;1)&#123;\n                t&#x3D;i;\n                break;\n            &#125;\n        &#125;\n        if(a[t][c]&#x3D;&#x3D;0)&#123;\n            continue;\n        &#125;\n        for(int i&#x3D;c;i&lt;&#x3D;n;i++) swap(a[t][i],a[r][i]);\n        &#x2F;&#x2F;这里没有了系数化为1的操作。因为没必要。肯定为1.\n        for(int i&#x3D;r+1;i&lt;n;i++)&#123;\n            if(a[i][c]&#x3D;&#x3D;1)&#123;\n                for(int j&#x3D;c;j&lt;&#x3D;n;j++)&#123;\n                    a[i][j]^&#x3D;a[r][j];\n                &#125;\n            &#125;\n        &#125;\n        r++;\n    &#125;\n    if(r&lt;n)&#123;\n        for(int i&#x3D;r;i&lt;n;i++)&#123;\n            if(a[i][n]!&#x3D;0)&#123;\n                return -1;\n            &#125;\n        &#125;\n        return 1;\n    &#125;\n    for(int i&#x3D;n-1;i&gt;&#x3D;0;i--)&#123;\n        for(int j&#x3D;i+1;j&lt;n;j++)&#123;\n            a[i][n]^&#x3D;a[i][j]*a[j][n];\n        &#125;\n    &#125;\n    return 0;\n&#125;\n\nint main()&#123;\n    cin&gt;&gt;n;\n    for(int i&#x3D;0;i&lt;n;i++)&#123;\n        for(int j&#x3D;0;j&lt;&#x3D;n;j++)&#123;\n            cin&gt;&gt;a[i][j];\n        &#125;\n    &#125;\n    int res&#x3D;gauss();\n    if(res&#x3D;&#x3D;0)&#123;\n        for(int i&#x3D;0;i&lt;n;i++)&#123;\n            cout&lt;&lt;a[i][n]&lt;&lt;endl;\n        &#125;\n    &#125;\n    else if(res&#x3D;&#x3D;1)&#123;\n        cout&lt;&lt;&quot;Multiple sets of solutions&quot;&lt;&lt;endl;\n    &#125;\n    else&#123;\n        cout&lt;&lt;&quot;No solution&quot;&lt;&lt;endl;\n    &#125;\n    \n    return 0;\n&#125;\n\nOK。那么这就是这天的全部内容了。Bye~\n","slug":"ACM学习笔记day26","date":"2023-02-04T13:00:01.000Z","categories_index":"ACM","tags_index":"ACM,打卡,学习,数学,高斯消元,解方程组","author_index":"Ausert"},{"id":"3f5d2f03fa2075448efe1519bfee1297","title":"ACM学习笔记day25(扩展中国剩余定理)","content":"大标题就是题目链接。这节的内容是扩展CRT。其实就是在原来的基础上去掉了模数两两互质的条件。这样的话CRT就不能用了，得用扩展中国剩余定理。虽然说是扩展CRT，但是其实和CRT没什么关系，是一种解决这类问题的方法罢了\n\n\nCRT解决的是什么问题，可以看我的上一篇博客，就在上面一篇。这里我们不在赘述啥是中国剩余定理。\n对于模数不两两的互质的情况，这个时候我们无法再使用CRT来直接求出来结果了。我们对此的思想是，将方程组中的方程的数量逐渐减少，最后就剩一条方程，那样的话，结果不就很好求了吗？问题来了，怎么使得方程数量逐渐减少呢？这里我们使用的方法是将两条方程合并。不断的进行这个过程，最终得到的结果就能够很容易的得出来解了。如何合并？因为过程比较复杂，码字太麻烦了，直接看草稿吧。这里我们只举例第一条方程和第二条方程，其他的同理。如下：\n\n通过这种方法，我们就把两条方程化成了一条方程。\n下面针对acwing上这题作出点小note。题目给的数据范围比较极限，所以取k1的值的时候要取最小正整数，不然会爆long long其次结果要取最小正整数，这个是题目要求的。\n实际程序中，我们只需要两组对应的a和m就够了，一个不断维护，作为新的a和m，一个用来接收新的a和m。\n下面为ac code：\n#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\n\nll exgcd(ll a,ll b,ll&amp; x,ll&amp; y)&#123;\n    if(b&#x3D;&#x3D;0)&#123;\n        x&#x3D;1,y&#x3D;0;\n        return a;\n    &#125;    \n    ll t&#x3D;exgcd(b,a%b,y,x);\n    y-&#x3D;a&#x2F;b*x;\n    return t;\n&#125;\n\nint main()&#123;\n    int n;\n    cin&gt;&gt;n;\n    ll a1,m1;\n    cin&gt;&gt;a1&gt;&gt;m1;\n    n--;\n    while(n--)&#123;\n        ll a2,m2;\n        cin&gt;&gt;a2&gt;&gt;m2;\n        ll k1,k2;\n        ll d&#x3D;exgcd(a1,a2,k1,k2);\n        if((m2-m1)%d!&#x3D;0)&#123;\n            cout&lt;&lt;-1&lt;&lt;endl;\n            return 0;\n        &#125;\n        k1*&#x3D;(m2-m1)&#x2F;d;\n        ll t&#x3D;a2&#x2F;d;\n        k1&#x3D;(k1%t+t)%t;&#x2F;&#x2F;这里k1要为最小的正整数。\n        &#x2F;&#x2F;然后更新a和m的值就可以了。\n        m1&#x3D;k1*a1+m1;\n        a1&#x3D;a1*a2&#x2F;d;\n    &#125;\n    &#x2F;&#x2F;结果的x就是x&#x3D;k*a1+m1;\n    &#x2F;&#x2F;要取最小的正整数。\n    cout&lt;&lt;(m1%a1+a1)%a1&lt;&lt;endl;\n    return 0;\n&#125;\n\n这个扩展欧几里得算法还是比较难理解的。不过也海星，毕竟就是数学的东西。qwq我觉得这个确实挺难的，所以单独发了个blog来写这个笔记。那我们下次再见捏bye~\n","slug":"ACM学习笔记day25","date":"2023-02-03T10:09:28.000Z","categories_index":"ACM","tags_index":"打卡,学习,数论,扩展中国剩余定理,数学","author_index":"Ausert"},{"id":"e8f352fc1ae41c272b21fc150a45992f","title":"ACM学习笔记day24(扩展欧几里得算法，线性同余方程，中国剩余定理)","content":"emm，好像距离上次写博客好像是很久以前了呢(懒狗，摆烂王是吧)话不多说，直接进入正题，今天的内容是扩展欧几里得算法和CRT，也就是中国剩余定理，或者也叫孙子定理。\n\n\n扩展欧几里得算法这个算法其实和欧几里得算法很像，都是用到了辗转相除法。只不过在辗转相除的同时，一边算了一个GCD，一边又解决了一个解二元一次方程的问题。我们使用扩展欧几里得算法，想要解决的是这样一个方程。其中只有x和y是未知数。\n其中我们要涉及到一个裴蜀定理。对于方程\n\n该方程，x和y是一定有解的，那么对于上面一条方程而言，当且仅当c能够正好被gcd(a,b)整除的时候，才有解。也就是说：\n\n我们接下来给出扩欧的代码，结合代码来讲解。注意，讲解只是辅助理解的，具体的原理以及严格的数学证明，这里不多赘述(其实是我不会)\nint exgcd(int a,int b,int&amp; x,int&amp; y)&#123;\n    if(b&#x3D;&#x3D;0)&#123;\n        x&#x3D;1,y&#x3D;0;\n        return a;\n    &#125;\n    int t &#x3D; exgcd(b,a%b,y,x);\n    y-&#x3D;a&#x2F;b*x;\n    return t;\n&#125;\n\n\n代码中，四个参数对应的方程就是a*x+b*y记住这个关系。我们每次辗转相除的时候，会交换a，b的位置，所以这里x和y也要交换。不交换也可以的，不过下面x和y更改的数值就要麻烦点了。这里讲解交换位置的，不交换位置的不讲解。首先我们对于辗转相除到最后一步的时候，这个时候，a是a，b是0，很明显，有一组解，x&#x3D;1,y&#x3D;0。这个当然是一个解。然后我们来到中间步骤，我们发现，此时的表达式为\n\n不难发现，a%b可以写成a-a&#x2F;b*b(这里a&#x2F;b是计算机中的除法，也就是向下取整)那么原式子化为：\n\n将式子对于a和b合并一下同类项。\n\n让我们再回想一下，原式子的关系，是a*x+b*y对吧。所以我们发现，在每次辗转的过程中，x没有变，y每次都要减去a&#x2F;b*x。因此模板中，return上面一句是y-&#x3D;a&#x2F;b*x;\n综上就是对于这个模板的辅助理解内容了。注意这个只是辅助理解，同时帮助记忆这个公式。非原理，别杠。\n下面为acwing上这题的ac code：\n#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\n\nint exgcd(int a,int b,int&amp; x,int&amp; y)&#123;\n    if(b&#x3D;&#x3D;0)&#123;\n        x&#x3D;1,y&#x3D;0;\n        return a;\n    &#125;\n    int t &#x3D; exgcd(b,a%b,y,x);\n    y-&#x3D;a&#x2F;b*x;\n    return t;\n&#125;\n\nint main()&#123;\n    int n;\n    cin&gt;&gt;n;\n    while(n--)&#123;\n        int a,b;\n        cin&gt;&gt;a&gt;&gt;b;\n        int x,y;\n        exgcd(a,b,x,y);\n        cout&lt;&lt;x&lt;&lt;&quot; &quot;&lt;&lt;y&lt;&lt;endl;\n    &#125;\n    return 0;\n&#125;\n\n\n线性同余方程这个其实是扩欧的一个应用。题目让你求这个\n\n我们对于取mod来说是什么比如a%b&#x3D;c。我们可以改写成a&#x3D;b*k+c (k&#x3D;….-2,-1,0,1,2….)所以我们可以改写一下这个方程式。也就是下面这个。\n\n注意这里的k可以为负数的，我左边如果乘积是个很小的负数，那右边不自然得是负数的k吗？\n然后我们移项。\n\n观察我们这个式子，我们发现，未知数只有xi和k，那这一看，不就是扩欧的标准形式吗，只不过k多了个负号。这里作一个k&#x3D;-k的换元，就是加法了。因为这题我们只要求x，对于这个k没有要求，所以不用管他的正负。接下来只要对这个式子套exgcd的模板就可以了。exgcd(ai,mi,xi,k)当然要注意是否有解的情况，bi得是gcd(ai,mi)的倍数。\nac code:\n#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\n\nll exgcd(ll a,ll b,ll&amp; x,ll&amp; y)&#123;\n    if(b&#x3D;&#x3D;0)&#123;\n        x&#x3D;1,y&#x3D;0;\n        return a;\n    &#125;\n    ll t&#x3D;exgcd(b,a%b,y,x);\n    y-&#x3D;a&#x2F;b*x;\n    return t;\n&#125;\n\nint main()&#123;\n    int n;\n    cin&gt;&gt;n;\n    while(n--)&#123;\n        ll a,b,m;\n        cin&gt;&gt;a&gt;&gt;b&gt;&gt;m;\n        ll  x,y;\n        ll t&#x3D; exgcd(a,m,x,y);\n        if(b%t!&#x3D;0)&#123;\n            cout&lt;&lt;&quot;imposssible&quot;&lt;&lt;endl;\n        &#125;\n        else&#123;\n            cout&lt;&lt;x*(b&#x2F;t)%m&lt;&lt;endl;\n        &#125;\n    &#125;\n    \n    return 0;\n&#125;\n\n\n中国剩余定理什么是中国剩余定理？其实中国剩余定理就是一个公式，他解决的是以下的这个问题。\n对于以下的方程组，求解x。\n\n其中模数mi全部两两互质。(这是一个很关键的条件。)那么这里中国剩余定理给出了一个x的公式解。如下：\n我们定义\n\n注意：为什么要强调mi两两互质，因为Mi存在mod mi的逆元的前提是Mi和mi互质，因为所有的mi都是两两互质的，那么Mi和mi也一定是互质的。如此，这个Mi的逆元才一定会存在。那么我们的x的一个解就可以表示为：\n\n这个x的值就是中国剩余定理的结果。为什么这里说是x的一个解，因为方程组完全有可能是有其他的解的。接下来我们简单理解一下这个公式。我们对于方程组中第i个方程，不难发现。x求和中第i个数字，因为是mod mi下的所以Mi和Mi的逆元自然为1，那么结果也就自然为ai对于求和中的非第i个数字，比如第j个数字，因为Mj中肯定包含了mi，所以乘积式子中也一定包含了mi，所以mod mi的结果一定为零。这样我们就验证了这个结果的正确性。所以求解这个方程组就变成了，求解Mi和他的逆元的问题了。Mi好求的，对于Mi的逆元。这里不能使用费马小定理，用快速幂求解，因为我们不能确保我们的模数一定是质数。所以我们就按照逆元的定义就可以了。对于一个x mod a下的逆元，满足以下的式子。\n\n而对于这个式子，我们可以类比线性同余方程的办法，采用扩欧来做。问题应该是不大的。\n下面为acwing上曹冲养猪的ac code：这题就是纯CRT没啥技术含量的。\n#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\n\nll exgcd(ll a,ll b , ll&amp; x,ll&amp; y)&#123;\n    if(b&#x3D;&#x3D;0)&#123;\n        x&#x3D;1,y&#x3D;0;\n        return a;\n    &#125;\n    ll d&#x3D; exgcd(b,a%b,y,x);\n    y-&#x3D;a&#x2F;b*x;\n    return d;\n&#125;\n\nint main()&#123;\n    int n;\n    cin&gt;&gt;n;\n    vector&lt;ll&gt; a(n),b(n);\n    ll product&#x3D;1;\n    for(int i&#x3D;0;i&lt;n;i++)&#123;\n        cin&gt;&gt;a[i]&gt;&gt;b[i];\n        product*&#x3D;a[i];\n    &#125;\n    ll res&#x3D;0;\n    for(int i&#x3D;0;i&lt;n;i++)&#123;\n        ll mi&#x3D;product&#x2F;a[i];\n        ll mi_,y;\n        exgcd(mi,a[i],mi_,y);\n        res+&#x3D;b[i]*mi*mi_;\n    &#125;\n    cout&lt;&lt;(res%product+product)%product&lt;&lt;endl;\n    return 0;\n&#125;\n\nOK，那么这里就是这次的全部内容了。我们下次再见。bye~ qwq\n","slug":"ACM学习笔记day24","date":"2023-02-02T14:25:04.000Z","categories_index":"ACM","tags_index":"打卡,学习,蒟蒻,数论,扩展欧几里得,CRT,中国剩余定理","author_index":"Ausert"},{"id":"ead55ceebbb5da582503c01cc4b636b6","title":"ACM学习笔记day23(欧拉函数，筛法求欧拉函数，快速幂，快速幂求逆元)","content":"今天的内容是欧拉函数和快速幂，主要是这两个。其中最后那个逆元，emm感觉好难理解QAQ\n\n\n欧拉函数欧拉函数的定义：\n\n由定义我们容易得出，对于求一个数字N的欧拉函数的值，我们按照定义来就可以了。时间复杂度是O(sqrt(N))。因为分解质因数要根号n，然后乘法乘上去也是根号n。所以时间复杂度是这样的。关于这个公式的证明其实是一个容斥原理。我们知道N有k个质因数，那么这k个质因数的次幂肯定和N不是互质的对吧。那么我们就要删掉这些个东西，比如他的有一个质因数p1，那么我们就要删掉N&#x2F;p1个数字。N&#x2F;p1就代表了，p1*1,p1*2….这些有几个了。其他的依次类推。那么,就变成了 \n\n\n\n\n\n\n\n\n\nN - N&#x2F;p1-N&#x2F;p2-N&#x2F;p3….但是也有可能什么呢？有的因数啊，他的质因数里面既包括p1又包括p2那样的话我们就多删了这个数字一次，所以我们要加上去这个。那么就变成了N - N&#x2F;p1-N&#x2F;p2-N&#x2F;p3….+N&#x2F;p1*p2+N&#x2F;p1*p3+….N&#x2F;*p(k-1)*pk…这里我们可能又多加了p1,p2,p3交集的部分，所以我们又要删掉他。…….以此类推，会们会得到一个形式上很类似上面的循环的表达式，而这个表达式化简下来就是公式定义里面的式子。知道了定义之后，那么我么再来求欧拉函数的值就好多了。就分两步。\n\n一个是分解质因数。\n计算欧拉函数的值。下面为代码:#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nint n;\n\n\n\nint main()&#123;\n    cin&gt;&gt;n;\n    while(n--)&#123;\n        int x;\n        cin&gt;&gt;x;\n        int res&#x3D;x;\n        for(int i&#x3D;2;i&lt;&#x3D;x&#x2F;i;i++)&#123;\n            if(x%i&#x3D;&#x3D;0)&#123;\n                res&#x3D;res&#x2F;i*(i-1);\n                while(x%i&#x3D;&#x3D;0) x&#x2F;&#x3D;i;\n            &#125;\n        &#125;\n        if(x&gt;1)&#123;\n            res&#x3D;res&#x2F;x*(x-1);\n        &#125;\n        cout&lt;&lt;res&lt;&lt;endl;\n    &#125;\n    return 0;\n&#125;\n\n筛法求欧拉函数如果要求某一个数的欧拉函数的值，那我们用上面的公式来做，完全可以了。但是如果我们要求1到某一个数的欧拉函数的值，那么用上面那个方法来做，会是n*sqrt(n)的时间复杂度，会非常的慢。那么这里我们就可以借助欧拉筛来解决这个问题。我们一边在用线性筛的同时，处理我们所需的欧拉函数的结果，这样我们可以在O(n)的时间内，解决这个问题。既然要用到线性筛，那么我们肯定先把线性山的板子先写一下对吧。\ntypedef long long ll;\nconst int N &#x3D; 1e6+10;\nint n;\nbool flag[N];\nvector&lt;int&gt; primes;\n\nll geteulers(int n)&#123;\n    for(int i&#x3D;2;i&lt;&#x3D;n;i++)&#123;\n        if(!flag[i])&#123;\n            primes.push_back(i);\n        &#125;\n        for(int j&#x3D;0;primes[j]*i&lt;&#x3D;n;j++)&#123;\n            flag[primes[j]*i]&#x3D;true;\n            if(i%primes[j]&#x3D;&#x3D;0)&#123;\n                break;\n            &#125;\n        &#125;\n    &#125;\n&#125;\n\n如上，是个线性筛的板子。那么我们这里要额外动用一个数组，phi[N]。phi[i]表示数字i的欧拉函数的值。我们求完phi数组，最后直接对这个数组求和就是最终的结果了。这里我们在做线性筛的时候，我们可以一并进行phi[i]的求解。分三种情况讨论。我们要处理的就是三种数字，质数的欧拉函数值，线性筛中，通过质数筛掉的数字的欧拉函数的值。其中又可以分为两种，如下：\n1. 如果i正好是质数。那么很显然，前面的i-1个数字全是和他互质的，他的欧拉函数的值就是i-1.\n证明也很好证，因为质数的定义就是他的约数只有1和他本身，如果前面有数字和i有相同的除1以外的约数的话，那么就不满足质数的定义了。\n\n2. 如果i%primes[j]&#x3D;&#x3D;0这种情况下，我们要求primes[j]*i的欧拉函数值，因为primes[j]已经是i的因数的，所以如果把i分解质因数，质因数的个数不会变，改变的只会是某个质因数的次幂。而我们从欧拉函数的公式上来看，这样的话是不会改变欧拉函数的值的。那么我么可以得以下的公式。\nprimes[j]用pj简写。\n\n\n也就是说phi[primes[j]*i]&#x3D;primes[j]*phi[i];\n3. 如果i%primes[j]!&#x3D;0这里就说明primes[j]不是他的质因数对吧，那么相应的，公式中就要多加一下pj的项，其他不变，那么我们就可以得到下面的公式。\n\n\n也就是说phi[primes[j]*i]&#x3D;phi[i]*(primes[j]-1);\n那么我们这里，一开始的时候要初始化一下phi[1]&#x3D;1，根据维基和google上的定义，我们规定1和1是算是互质的。那么代码如下:\n#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nvector&lt;int&gt; primes;\ntypedef long long ll;\nconst int N &#x3D; 1e6+10;\nint phi[N];\nbool flag[N];\n\nll getprimes(int n)&#123;\n    phi[1]&#x3D;1;\n    for(int i&#x3D;2;i&lt;&#x3D;n;i++)&#123;\n        if(!flag[i])&#123;\n            primes.push_back(i);\n            phi[i]&#x3D;i-1;\n        &#125;\n        for(int j&#x3D;0;primes[j]*i&lt;&#x3D;n;j++)&#123;\n            flag[primes[j]*i]&#x3D;true;\n            if(i%primes[j]&#x3D;&#x3D;0)&#123;\n                phi[primes[j]*i]&#x3D;primes[j]*phi[i];\n                break;\n            &#125;\n            phi[primes[j]*i]&#x3D;(primes[j]-1)*phi[i];\n        &#125;\n    &#125; \n    ll res&#x3D;0;\n    for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;\n        res+&#x3D;phi[i];\n    &#125;\n    return res;\n&#125;\n\nint main()&#123;\n    int n;\n    cin&gt;&gt;n;\n    cout&lt;&lt;getprimes(n)&lt;&lt;endl;\n    return 0;\n&#125;\n\n快速幂快速幂这个东西，顾名思义。就是能够快速的求出一个数的次幂是多少。比如我们要求a^b是多少，如果朴素做法的话就是，一个一个乘过去。这样我们的时间就是O(b）,很明显，太慢了。我们使用快速幂的话，我们就能够在logb的时间内求出来结果。好，那我们来看一下快速幂是怎么求的。我们要求a^b,我们先把下面的东西求出来:\n\n注意，这里这个东西的求法也是有讲究的，我们发现一个数字就等于他前面那个数字的平方，所以我们每次求某个数字的时候，他的值就是他前面那个数字的平方。然后利用这个来求a^b。那么怎么求呢？其实快速幂的原理，就是将幂用二进制来表示，比如5&#x3D;(101)_2,那么5就可以表示为5&#x3D;2^2+2^0,对应的到次幂的话，就是对应的底数相乘就是了。如图：\n\n我们发现最终的表达式中我们要的值是之前求过的，这也就是为什么我们要提前算一下a的各个2的次幂的次幂的值。当然在实际过程中不需要预先算好，我们只要一步一步拆解b，然后推进的同时更新我们的数值就可以了。以下为代码：\n#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\n\nll  qmi(ll a,ll b,ll p)&#123;\n    ll ans&#x3D;1;\n    while(b)&#123; &#x2F;&#x2F;一直到b为零为止\n        if(b&amp;1)&#123; &#x2F;&#x2F;如果b的最后一位是1的话，那么就相当于要乘一个值的。\n            ans&#x3D;ans*a%p; &#x2F;&#x2F;这里这个a就是不断更新的a平方的次幂的值。\n        &#125;\n        a&#x3D;a*a%p; &#x2F;&#x2F;更新a，根据上面的结论，后一个数字的值就是前面数字的平方，当然，要记得取模。\n        b&gt;&gt;&#x3D;1; &#x2F;&#x2F;b右移一位。\n    &#125;\n    &#x2F;&#x2F;相当于，这里我们用a作为那个我们要乘的数字，不断更新a。使得算法大大的简化了。\n    return ans;\n&#125;\nint main()&#123;\n    int n;\n    cin&gt;&gt;n;\n    while(n--)&#123;\n        ll a,b,p;\n        cin&gt;&gt;a&gt;&gt;b&gt;&gt;p;\n        cout&lt;&lt;qmi(a,b,p)&lt;&lt;endl;\n    &#125;\n    return 0;\n&#125;\n\n\n快速幂求逆元这题主要是利用快速幂去求逆元的。题目上是让你求逆元，但是运用到了一个结论，然后就转化为了用快速幂去求逆元的题目了。逆元定义如下：\n\n额，这个鸟定义七绕八拐的，真不太懂，不过感觉有点离散的味道，这个逆元。反正就是当b和m互质的时候，对于任意的能够让b整除的a，存在一个x，使得 a&#x2F;b&#x3D;a*x(同余m)，这个x就叫做b的模m乘法逆元，记作b^-1(mod m);其中b必须和m互质，不然的话b是不存在乘法逆元的。然后这题的话，用到了一个定理。就是上面写的，当m为质数的时候，b^(m-2)就是b的乘法逆元。因为题目给的模p一定是质数，所以我们就把这个问题转化为了求b^(m-2)的值就是了。当然要判断一下b和m是不是互质的，如果不是的话，是不存在逆元的。 \n代码如下：\n#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\nll qmi(ll a,ll b,ll p)&#123;\n    ll res&#x3D;1;\n    while(b)&#123;\n        if(b&amp;1)&#123;\n            res&#x3D;res*a%p;\n        &#125;\n        a&#x3D;a*a%p;\n        b&gt;&gt;&#x3D;1;\n    &#125;\n    return res;\n&#125;\nint mygcd(ll a,ll b)&#123;\n    if(b&#x3D;&#x3D;0) return a;\n    else return mygcd(b,a%b);\n&#125;\n\n\nint main()&#123;\n    int n;\n    cin&gt;&gt;n;\n    while(n--)&#123;\n        int a,p;\n        cin&gt;&gt;a&gt;&gt;p;\n        if(mygcd(a,p)!&#x3D;1)&#123;\n            cout&lt;&lt;&quot;impossible&quot;&lt;&lt;endl;\n        &#125;\n        else&#123;\n            cout&lt;&lt;qmi(a,p-2,p)&lt;&lt;endl;\n        &#125;\n    &#125;\n    return 0;\n&#125;\n\n\n好了，那么今天的内容，额，写这个写了两天了，就到这里了。我们下次再见捏Bye~\n","slug":"ACM学习笔记day23","date":"2023-01-24T13:07:47.000Z","categories_index":"ACM","tags_index":"ACM,打卡,学习,数论,数学,快速幂,欧拉函数,逆元","author_index":"Ausert"},{"id":"3438dc43ca9a9de9df433abe2e751c9e","title":"ACM学习笔记day22 (约数个数，约数之和，最大公约数)","content":"浅过了个年，差不多了，应该回来念书了XD今天的内容是约数个数，约数之和，最大公约数。\n\n\n\n\n约数个数,约数之和对于这个问题，其实就是两个公式。具体的证明，可以自寻资料查看。这里仅给出结果，和我自己的理解。严格的数学证明我们不多赘述。以下为公式(图中pi为N的质因数)：\n好，公式我们给出来了。我们应该怎么理解这个公式呢？首先我们去观察一下约数之和这个公式，看最后一个表达式。如果我们把这个乘积表达式展开，我们会发现其中的每一个数字，都是N的所有质因数的幂之积，也就是说，一个数N的任何一个约数都可以用他的质因数的幂之积来表示。这个其实不难理解，因为由算数基本定理，任何一个数都可以用他的质因数的幂之积来表示。那么约数是能够整除N的数字，也就相当于他是N的质因数的幂之积的一部分。那么为了表示出所有的约数，每一个质因数的幂的部分从0到alpha1都是需要枚举到的这里面一共有alpha1+1个，那么自然约数的个数就是(alpha1+1)(alpha2+1)…..(alphak+1)。理解完约数的个数为什么是这么多之后，我们再来看约数之和这个公式。我们也会更好的去记忆这个公式了，毕竟他是所有约数和的合并式。\n注意这里求约数个数的时候方便的，但是求约数之和的时候，可能有些人想要用等比数列求和公式(就是我)可以是可以，但是不能用pow函数，因为pow函数返回的是double类型的，而不是longlong类型的，可能最终的结果会爆double自己写pow函数的话，别忘了要每次取整。那么如果不用等比数列求和公式的话，我们可以采用秦九昭算法。也就是进行alpha1次循环，令t&#x3D;1，每次循环t&#x3D;t*p1+1;这样最终t的值就是我们要求的值了。\n\n下面为两题的代码：约数个数:\n#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nint n;\ntypedef long long  ll;\nconst int mod &#x3D; 1e9+7;\nint main()&#123;\n    map&lt;int,int&gt; isprimes;\n    cin&gt;&gt;n;\n    while(n--)&#123;\n        int x;\n        cin&gt;&gt;x;\n        for(int i&#x3D;2;i&lt;&#x3D;x&#x2F;i;i++)&#123;\n            if(x%i&#x3D;&#x3D;0)&#123;\n                while(x%i&#x3D;&#x3D;0)&#123;\n                    x&#x2F;&#x3D;i;\n                    isprimes[i]++;\n                &#125;\n            &#125;\n        &#125;\n        if(x&gt;1)&#123;\n            isprimes[x]++;\n        &#125;\n    &#125;\n    ll res&#x3D;1;\n    for(auto prime:isprimes)&#123;\n        res&#x3D;res*(prime.second+1)%mod;\n    &#125;\n    cout&lt;&lt;res&lt;&lt;endl;\n    return 0;\n&#125;\n约数之和:\n#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nint n;\ntypedef long long ll;\nconst int mod &#x3D; 1e9+7;\n\n\nint main()&#123;\n    map&lt;ll,ll&gt; primes;\n    cin&gt;&gt;n;\n    while(n--)&#123;\n        int x;\n        cin&gt;&gt;x;\n        for(int i&#x3D;2;i&lt;&#x3D;x&#x2F;i;i++)&#123;\n            while(x%i&#x3D;&#x3D;0)&#123;\n                x&#x2F;&#x3D;i;\n                primes[i]++;\n            &#125;\n        &#125;\n        if(x&gt;1)&#123;\n            primes[x]++;\n        &#125;\n    &#125;\n    ll res&#x3D;1;\n    for(auto prime: primes)&#123;\n        ll p &#x3D; prime.first;\n        ll a&#x3D;prime.second;\n        ll t&#x3D;1;\n        for(int i&#x3D;0;i&lt;a;i++)&#123;\n            t&#x3D;(t*p%mod+1)%mod;\n        &#125;\n        res&#x3D;res*t%mod;\n    &#125;\n    cout&lt;&lt;res&lt;&lt;endl;\n    return 0;\n&#125;\n最大公约数求两个数的最大公约数，这个很简单，就是一个公式，辗转相除法。这里要理解一下为啥\n\n\n\n\n\n\n\n\n\ngcd(a,b)&#x3D;&#x3D;gcd(b,a%b);首先我们知道，a能整除b，a能整除c，那么a一定能够整除(a+b)那么我们来看一下a,b的所有公约数，还有b，a%b的所有公约数，如果这两个公约数都一样的话，那么最大公约数也肯定是一样的对吧假设c是a和b的任意一个公约数，那么可以得到c能整除a，c能整除b，对于等式右边，c能整除b。而对于a%b我们可以表示为a-(a&#x2F;b)*b的值，也就是说a-k*b,k为一个常数(是的表达式的值大于零的最大常数)因为c能整除a，c能整除b，那么自然c能整除a-k*b。同理，设c是b和a%b的一个任意公约数，c能整除a-k*b，并且因为c能整除b，所以c能整除k*b,所以c能整除a-k*b+k*b 也就是c能整除a。综上两边的公约数是一模一样的，所以等式成立。下面为代码：\n#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\n\nint gcd(int a,int b)&#123;\n    if(b&#x3D;&#x3D;0) return a;\n    else&#123;\n        return gcd(b,a%b);\n    &#125;\n&#125;\n\nint main()&#123;\n    int n;\n    cin&gt;&gt;n;\n    while(n--)&#123;\n        int a,b;\n        cin&gt;&gt;a&gt;&gt;b;\n        cout&lt;&lt;gcd(a,b)&lt;&lt;endl;\n    &#125;\n    return 0;\n&#125;\n\nOK，那么就那么多东西了。我们下次再见Bye~~~\n","slug":"ACM学习笔记day22","date":"2023-01-23T13:17:12.000Z","categories_index":"ACM","tags_index":"ACM,打卡,学习,数论,约数,公式","author_index":"Ausert"},{"id":"a894f3fb49a6e9d5b26247e277bba209","title":"ACM学习笔记day21(试除法判定质数，分解质因数，质数筛（朴素筛，埃氏筛，线性筛）,试除法求约数)","content":"emmmm，距离上次写blog好像已经是很久以前的事情了XD(其实就是自己摆)那么今天的内容是试除法判定质数，分解质因数，还有三个质数筛。\n\n\n试除法判定质数 题目这个很好理解，就是一个一个数去取余所给的数，如果存在一个数正好取余的话，那就说明这个数不是质数。同时有一个结论，那就是如果出现约数，一定是成对出现的。比如i是n的约数，那么n&#x2F;i也是他的约数。这个很好理解的因为i是n的约数，那么很显然i乘一个数字就等于n，也就是说\n\n\n\n\n\n\n\n\n\n$$i*\\frac{n}{i}&#x3D;n$$\ni是n的约数，自然$\\frac{n}{i}$也是n的约数。所以我们发现约数总是成对出现的。那么我们就可以不用一个一个的去找，相反，只要找$\\sqrt{n}$个数字就可以了。也就是说时间复杂度是$O(\\sqrt{n})$。下面为题目代码:\n#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\n\nbool isPrime(int x)&#123;\n    for(int i&#x3D;2;i&lt;&#x3D;x&#x2F;i;i++)&#123;\n        if(x%i&#x3D;&#x3D;0)&#123;\n            return false;\n        &#125;\n    &#125;\n&#125;\n\nint main()&#123;\n    int n;\n    cin&gt;&gt;n;\n    while(n--)&#123;\n        int x;\n        cin&gt;&gt;x;\n        if(isPrime(x))&#123;\n            cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl;\n        &#125;\n        else&#123;\n            cout&lt;&lt;&quot;No&quot;&lt;&lt;endl;\n        &#125;\n    &#125;\n    return 0;\n&#125;\n\n分解质因数 题目分解质因数也是试除法来进行的。我们不难发现，给定任何一个数，我们总能够将其拆分成若干个质数的幂的乘积的形式。如下\n\n\n\n\n\n\n\n\n\n$n&#x3D;p_1^ap_2^bp_3^c…..$\n其中，$p_1,p_2,p_3$，为他的质因数,abc为一个固定的常数。那么我们分解质因数的过程是和这个类似的。倒不如说也就是模拟这个的过程。同理，我们这里只要进行$\\sqrt{n}$次就可以了。为什么呢？我们不难发现，对于一个数字n，他大于$\\sqrt{n}$的质因数至多就一个。很好证明，反证法，如果大于一个了，说明至少两个是吧，那么质因数乘起来明显是大于n的，显然不成立。所以n大于$\\sqrt{n}$的质因数至多只会有一个。那么我们就先做小于等于$\\sqrt{n}$的部分，然后我们每次找到一个质因数之后，不断的去除掉给的数里面的这个质因数如果最后结果不是1（因为一直除，除到最小就是1嘛）说明是存在大于$\\sqrt{n}$的质因数的那么我们就把当前这个数也作为一个结果。该算法的时间复杂度为$O(\\sqrt{n})$。不同于上面那个是严格的$\\sqrt{n}$，这里这个是小于$\\sqrt{n}$的，极端下才会是$\\sqrt{n}$下面为代码\n#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\n\nvoid Prime(int x)&#123;\n    for(int i&#x3D;2;i&lt;&#x3D;x&#x2F;i;i++)&#123; &#x2F;&#x2F;从2开始到sqrt(x)一个一个去找\n        if(x%i&#x3D;&#x3D;0)&#123; &#x2F;&#x2F;如果是因数，这里一定是质因数，因为我们找到了之后会不断的用他去除所给的x，有关i的倍数的值全部被\n                    &#x2F;&#x2F;除掉了\n            int cnt&#x3D;0; &#x2F;&#x2F;计数质因数的幂次\n            while(x%i&#x3D;&#x3D;0)&#123;\n                x&#x2F;&#x3D;i; &#x2F;&#x2F;如果x里面还有当前i这个因数的话，就不断的去除去，然后计数器加一\n                cnt++;\n            &#125;\n            cout&lt;&lt;i&lt;&lt;&#39; &#39;&lt;&lt;cnt&lt;&lt;endl; \n        &#125;\n    &#125;\n    if(x&gt;1)&#123; &#x2F;&#x2F;如果x大于了1，说明存在大于根号x的质因数，那么这个数就是其中的一个质因数，并且幂次一定为1.\n        cout&lt;&lt;x&lt;&lt;&#39; &#39;&lt;&lt;1&lt;&lt;endl;\n    &#125;\n&#125;\n\nint main()&#123;\n    int n;\n    cin&gt;&gt;n;\n    while(n--)&#123;\n        int x;\n        cin&gt;&gt;x;\n        Prime(x);\n        cout&lt;&lt;endl;\n    &#125;\n    return 0;\n&#125;\n\n质数筛 题目质数筛，顾名思义，就是在给定的范围内，将其中所有的质数全面筛选出来。一般的方法是把合数去掉，剩下的就是质数了。这也是朴素筛和埃氏筛的原理。如图就是筛完之后的样子。\n朴素筛朴素筛的思想很简单，就是对于每一个数字，将他的倍数删掉。比如，2，那我们就将4,6,8….这些数字都删掉这样我们迭代到n之后，就删掉了里面所有的因数了。这种筛法的时间复杂度是$O(n\\log_2n)$;下面为简要的证明\n\n\n\n\n\n\n\n\n\n不难发现，程序的执行次数为$\\frac{n}{2}+\\frac{n}{3}+\\frac{n}{4}…..+\\frac{n}{n}$即为$n*(\\frac{1}{2}+\\frac{1}{3}+\\frac{1}{4}+\\frac{1}{5}+…..\\frac{1}{n})$后面的为一个调和级数，当$n→∞$时，他的值为$\\ln{n}+c$。其中c为欧拉常数因为$\\ln{n}&lt;\\log_2 n$所以我们一般认为这个时间复杂度为$O(n\\log_2n)$\n下面为朴素筛的代码：\n#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nint n;\nconst int N  &#x3D; 1e6+10;\nint cnt;\nbool st[N];\n&#x2F;&#x2F;如果要存储结果的话，只要再开一个数组用来存就可以了\nvoid getPrimes()&#123;\n    for(int i&#x3D;2;i&lt;&#x3D;n;i++)&#123;\n        if(!st[i])&#123;\n            cnt++;&#x2F;&#x2F;当cnt++的时候，当前的i存入数组中去就可以了;\n        &#125;\n        for(int j&#x3D;i+i;j&lt;&#x3D;n;j+&#x3D;i)&#123;\n            st[j]&#x3D;1;\n        &#125;\n    &#125;\n&#125;\n\nint main()&#123;\n    cin&gt;&gt;n;\n    getPrimes();\n    cout&lt;&lt;cnt&lt;&lt;endl;\n    return 0;\n&#125;\n\n\n埃氏筛埃氏筛是朴素筛的优化版本。他和朴素筛的区别就在于，进行删除的时候，仅仅对于之前没被删过的数字。因为如果这个数字被删过，说明他是合数，前面一定存在一个质数，是他的因数，那么这个数字的倍数也一定是他的质因数的倍数那么当然也都是被删过的，所以我们可以跳过这一步。他的时间复杂度为$O(n\\log_2\\log_2n)$很多时候loglog基本上可以看做是一个常数。下面为代码：\n#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nint n;\nconst int N  &#x3D; 1e6+10;\nint cnt;\nbool st[N];\n\nvoid getPrimes()&#123;\n    for(int i&#x3D;2;i&lt;&#x3D;n;i++)&#123;\n        if(!st[i])&#123;\n            cnt++;\n            for(int j&#x3D;i+i;j&lt;&#x3D;n;j+&#x3D;i)&#123; &#x2F;&#x2F;将这一步移动进了条件句里面。\n                st[j]&#x3D;1;\n            &#125;\n        &#125;\n        \n    &#125;\n&#125;\n\nint main()&#123;\n    cin&gt;&gt;n;\n    getPrimes();\n    cout&lt;&lt;cnt&lt;&lt;endl;\n    return 0;\n&#125;\n\n线性筛(欧拉筛)欧拉筛为什么是线性筛，原因就在于他不同于埃氏筛，他没有重复筛除的过程。埃氏筛中，我们i遍历到3和7的时候，显然会重复筛除21，而欧拉筛不会这样。因为我们每次筛除的时候都是以primes[i]为最小质因数的数每一个数的最小质因数都是唯一的，那么当然筛除的过程也就没有多余的重复筛除过程。所以欧拉筛也叫线性筛。具体筛除的过程可以看这个视频。这里面有动画演示欧拉筛的过程。\n下面为代码：\n#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nint n;\nconst int N &#x3D; 1e6+10;\nbool st[N];\nint cnt&#x3D;0;\nint primes[N];\n\nvoid getPrimes()&#123;\n    for(int i&#x3D;2;i&lt;&#x3D;n;i++)&#123;\n        if(!st[i])&#123;\n            primes[cnt++]&#x3D;i; &#x2F;&#x2F;如果没被筛掉，说明是质数，那么就将他放入primes数组里面，同时cnt计数++\n        &#125;\n        for(int j&#x3D;0;primes[j]&lt;&#x3D;n&#x2F;i;j++)&#123; &#x2F;&#x2F;遍历整个primes数组，首先要求保证primes[j]*i得是&lt;&#x3D;n的确保合法\n            st[primes[j]*i]&#x3D;true; &#x2F;&#x2F; 让primes[j]*i的值为true，表示被筛过了，因为这个数肯定是约数了。\n            if(i%primes[j]&#x3D;&#x3D;0)&#123;\n                break; &#x2F;&#x2F;如果primes是i的约数的话，那就结束循环，此时primes[j]一定是i的最小质因数，当然也是primes[j]*i的最小质因数。\n                                &#x2F;&#x2F;遵循了欧拉筛的原则，只筛到以primes[j]为最小质因数的数，避免多筛。\n            &#125;\n        &#125;\n    &#125;\n&#125;\nint main()&#123;\n    cin&gt;&gt;n;\n    getPrimes();\n    cout&lt;&lt;cnt&lt;&lt;endl;\n    return 0;\n&#125;\n试除法求约数 题目用试除法求约数，很简单，就一个一个数字除过去看能不能正好取整，如果可以就是约数。同时因为约数是成对出现的，所以可以优化到$O(\\sqrt{n})$的时间复杂度。下面为代码：\n#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nconst int N &#x3D; 1e7;\nint n;\nvector&lt;int&gt; res;\nvoid getdivisor(int x)&#123;\n    for(int i&#x3D;1;i&lt;&#x3D;x&#x2F;i;i++)&#123;\n        if(x%i&#x3D;&#x3D;0)&#123;\n            res.push_back(i);\n            if(i!&#x3D;x&#x2F;i) res.push_back(x&#x2F;i);\n        &#125;\n    &#125;\n&#125;\n\nint main()&#123;\n    cin&gt;&gt;n;\n    while(n--)&#123;\n        int x;\n        cin&gt;&gt;x;\n        res.clear();\n        getdivisor(x);\n        sort(res.begin(),res.end());\n        for(int i&#x3D;0;i&lt;res.size();i++)&#123;\n            cout&lt;&lt;res[i]&lt;&lt;&#39; &#39;;\n        &#125;\n        cout&lt;&lt;endl;\n    &#125;\n    \n    return 0;\n&#125;\n好了，那么这就是这里的全部内容了。感觉欧拉筛还是有点难理解的。我们下次再见Bye~\n","slug":"ACM学习笔记day21","date":"2023-01-17T15:01:09.000Z","categories_index":"ACM","tags_index":"ACM,打卡,笔记,数论,质数,约数","author_index":"Ausert"},{"id":"955da31dc34cc48d9fa1d8587dc420ff","title":"ACM学习笔记day20(走迷宫bfs)","content":"hello guys！今天的内容是走迷宫。额，好像叕好久没有更新博客了。呃呃呃。好像确实有点摆（是非常吧。好的，我们来看问题。\n\n\n\n走迷宫问题，这个不多说，啥意思很容易理解题源：acwing;所用的思想就是bfs算法。bfs算法其实是有一个固定的算法模板的。\n\n\n\n\n\n\n\n\n\nwhile(queue非空){    t&#x3D;queue.front();    queue.pop();    根据t去扩展，push进queue中去。}\n所以，对于这个迷宫问题就是对于起点来说，从起点开始扩展，放入队列中去然后取队头元素，然后再扩展，如此往复。下面直接看代码。\n#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nconst int N &#x3D; 110;\ntypedef pair&lt;int,int&gt; PII; &#x2F;&#x2F;用来表示坐标。\nint n,m; \nint g[N][N]; &#x2F;&#x2F;存放这个迷宫\nint d[N][N]; &#x2F;&#x2F;d[i][j]表示这个点到起点的距离，-1表示不可到达或者还没有遍历到。 \n\nint bfs()&#123;\n    queue&lt;PII&gt; work;\n    d[0][0]&#x3D;0;&#x2F;&#x2F;初始化第一个点，是零。\n    work.push(&#123;0,0&#125;); &#x2F;&#x2F;把起点放入工作队列中去。\n    int dx[4]&#x3D;&#123;-1,0,1,0&#125;,dy[4]&#x3D;&#123;0,-1,0,1&#125;; &#x2F;&#x2F;这个是方向向量，为了便于表示一个点的四个方向的扩展。\n    while(!work.empty())&#123;\n        PII t &#x3D; work.front(); &#x2F;&#x2F;队头元素\n        work.pop(); &#x2F;&#x2F;弹出\n        for(int i&#x3D;0;i&lt;4;i++)&#123; &#x2F;&#x2F;四个方向 \n            int x&#x3D;t.first+dx[i],y&#x3D;t.second+dy[i]; &#x2F;&#x2F;用x，y表示新的位置。\n            if(x&gt;&#x3D;0&amp;&amp;x&lt;n&amp;&amp;y&gt;&#x3D;0&amp;&amp;y&lt;m&amp;&amp;g[x][y]&#x3D;&#x3D;0&amp;&amp;d[x][y]&#x3D;&#x3D;-1)&#123; &#x2F;&#x2F;如果xy没有越界，同时这个位置可以走，并且没有访问过。\n            &#x2F;&#x2F;注意，这里为什么要加这个没有访问过？\n            &#x2F;&#x2F;因为我们按照bfs的顺序是一层一层的遍历过去的。如果访问过了，说明层数肯定已经大了，有更小的，肯定就不是最优解了，所以我们要加这个。\n                d[x][y]&#x3D;d[t.first][t.second]+1;\n                work.push(&#123;x,y&#125;); &#x2F;&#x2F;把扩展push进queue.\n            &#125;\n        &#125;\n    &#125;\n    return d[n-1][m-1];\n&#125;\n\nint main()&#123;\n    cin&gt;&gt;n&gt;&gt;m;\n    for(int i&#x3D;0;i&lt;n;i++)&#123;\n        for(int j&#x3D;0;j&lt;m;j++)&#123;\n            d[i][j]&#x3D;-1; &#x2F;&#x2F;初始化距离\n            cin&gt;&gt;g[i][j];\n        &#125;\n    &#125;\n    cout&lt;&lt;bfs()&lt;&lt;endl;\n    return 0;\n&#125;\n\n好的，那么这就是今天的全部内容了。我们下次再见，bye~\n","slug":"ACM学习笔记day20","date":"2022-12-16T13:50:22.000Z","categories_index":"ACM","tags_index":"ACM,打卡,学习,算法,数据结构,bfs","author_index":"Ausert"},{"id":"8939638ff3772e749e6b91f98033c73a","title":"题解-Codeforces-Round-837-div-2","content":"蒟蒻又日常来尝试div2了，这次独立（额，算独立吗）做出来的只有A，B还是问了别人才做出来的，接下里的这个就是B的题解。下面这个做法真的十分的优雅。代码很简洁，思路也很清楚。\n\n\n\nB-Hossam and Friends\n题目链接\n题目描述：一个人有n个朋友，按照1,2,3,4…，n的顺序。现在他有m对数据，里面的每对数据表示这两个人互相不认识。定义good segment：以l为左边界，r为右边界的一个segment(包括l和r)，如果里面的每个人都互相认识，那么我们就认为他是一个good segment问你，这n个人中有多少个good segment。\n题目思路：这里呢，我们使用到了一个数组a，这个数组存放的不是1,2,3,4….这些朋友。这个数组的含义，就是这个解法最妙的地方。a[i]表示以左边界i的最大右边界+1。什么意思呢，就比如说a[2]&#x3D;5，就说明2~4这些人是互相认识的。所以我们对于m次输入的x和y，表示x和y不认识，为了能够方便维护我们的数组如果x&gt;y就让x和y swap一下。然后让a[x]&#x3D;min(a[x],y)即可，就这样维护了a[x]新的右边界，当然要去min值，因为有可能给的这个y是大于原来的那个的。然后我们要继续维护一下这个a数组。为什么呢？我们来看下面这一种特殊的情况。我们得到如下的a数组\n\n\n\n\n\n\n\n\n\na[i]: 1 2 3 4 5 6 7 8 9 100 99 65 43 65 47 100 ……下标: 1 2 3 4 5 6 7 8 9 10  11 12 13 14 15  16\n不难发现，我们对于第12个人来说，最大good segment的右边界是65-1,但是第11个人的右边界却是9965和12都不认识，那11~98这个区间里面，肯定是有人不认识的，也就不可能是good segment。所以我们要根据他右边的那个数来更新自己。因为a[i]表示的值是最大右边界嘛。同时要注意，更新的时候必须从右边开始更新，而不是左边试想一下，对于10 11 12这三个数字，更新完之后，显然应该是43 43 43但是如果从左边更新的话，就会变成99 65 43显然这样是不对的。理由也很简单，因为a[i]的值是右边界的最大值，每一个a[i]的值是否正确，都是依托于他右边的值的，所有我们要从右边开始更新确保每次更新都是正确的。更新完之后，我们让ans+&#x3D;每一个a[i]-i即可，也就是以i为边界的最长good segment的长度。下面为代码实现：\n#include&lt;bits&#x2F;stdc++.h&gt;\t\nusing namespace std;\t\nconstexpr int INF &#x3D; 2100000000;\ntypedef long long ll;\t\ntypedef unsigned long long ULL;\nconstexpr ll INF64 &#x3D; 1e18;\nconst int N &#x3D; 100003;\t\ntypedef pair&lt;int, int&gt; PII;\n#define mysort(a) sort(a.begin(),a.end());\n#define mysort(a,n) sort(a,a+n);\nint n, m;\nint a[N];\n\nvoid solve() &#123;\n\tcin &gt;&gt; n &gt;&gt; m;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;\n\t\ta[i] &#x3D; n + 1;\n\t&#125;\n\twhile (m--) &#123;\n\t\tint x, y;\n\t\tcin &gt;&gt; x &gt;&gt; y;\n\t\tif (x &gt; y) &#123;\n\t\t\tswap(x, y);\n\t\t&#125;\n\t\ta[x] &#x3D; min(a[x], y);\n\t&#125;\n\tfor (int i &#x3D; n - 1; i &gt;&#x3D; 1; i--) &#123;\n\t\ta[i] &#x3D; min(a[i], a[i + 1]);\n\t&#125;\n\tll ans &#x3D; 0;\n\tfor (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;\n\t\tans +&#x3D; a[i] - i;\n\t&#125;\n\tcout &lt;&lt; ans &lt;&lt; endl;\n\n&#125;\n\t\t\t\t\t\t\n\n\t\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t\t\nint main()\n&#123;\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\t\t\t\t\t \n\tint t;\t\t\t\t\t\n\tcin &gt;&gt; t;\t\t\t\t\n\twhile (t--)\t\t\t\t\n\t&#123;\t\t\t\t\t\t\n\t\tsolve();\t\t\t\n\t&#125;\t\t\t\t\t\t\n\treturn 0;\n&#125;\t\t\n\n先这样吧，如果后面的C我干出来了，或者是有很优美的算法解决问题的话，我也会更新在博客里面。Bye~\n","slug":"题解-Codeforces-Round-837-div-2","date":"2022-12-12T11:57:48.000Z","categories_index":"题解","tags_index":"ACM,学习,算法,数据结构,codeforces,题解","author_index":"Ausert"},{"id":"983fdf7c1cf56eb82d4bc470facb21cc","title":"ACM学习笔记day19(N皇后问题-2种dfs解法)","content":"今天的内容是N皇后问题，有两种dfs方法，但是自己在写的时候还是碰到了不少问题的。\n\n第一种dfs方法这种dfs方法，是基于我们已经知道了，每一行每一列每一主对角线和副对角线上只能有一个皇后。思想和数字的全排列差不多。我们dfs第零行到第n-1行，然后枚举第零列到第n-1列，如果有满足条件的，就放一个皇后。直到递归的深度到达n之后，输出一个解。然后回溯寻找其他的解。这里要涉及一个第x行第y列的格子是第几个主对角线的和第几个副对角线的问题。我们定义的dg数组是指副对角线的。udg数组是指主对角线的。实际上这两个东西的含义相反的话也没事的。其中对于第x行第y列的格子，他对应的dg下标是x+y而udg的则是x-y+n;为什么是这样的？我们看下面两张图。\n这张图中，描述的是udg的情况，我们可以通过找规律来理解为什么x,y对应的是x-y+n这里加n是为了让他的值为非负，不然数组会越界的。\n\n这张图中，描述的是dg的情况，我们也可以通过找规律来理解为什么x，y对应的是x+y\n\n下面为代码：\n#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nconst int N&#x3D;20;\nchar graph[N][N];\nint n;\nbool col[N],dg[N],udg[N];\n\nvoid dfs(int x)&#123;\n    if(x&#x3D;&#x3D;n)&#123; &#x2F;&#x2F;递归到n的时候，可以停止了，因为这个时候n行都被放完了。\n        for(int i&#x3D;0;i&lt;n;i++)&#123;\n            for(int j&#x3D;0;j&lt;n;j++)&#123;\n                cout&lt;&lt;graph[i][j];\n            &#125;\n            cout&lt;&lt;endl;\n        &#125;\n        cout&lt;&lt;endl;\n        return;\n    &#125;\n    for(int i&#x3D;0;i&lt;n;i++)&#123; &#x2F;&#x2F;逐列寻找可以放的地方\n        if(!col[i]&amp;&amp;!dg[x+i]&amp;&amp;!udg[x-i+n])&#123;\n            graph[x][i]&#x3D;&#39;Q&#39;;\n            col[i]&#x3D;1;\n            dg[x+i]&#x3D;1;\n            udg[x-i+n]&#x3D;1; &#x2F;&#x2F;将皇后放下，同时更新所有的数组。\n            dfs(x+1);\n            graph[x][i]&#x3D;&#39;.&#39;; &#x2F;&#x2F;恢复现场\n            col[i]&#x3D;0;\n            dg[x+i]&#x3D;0;\n            udg[x-i+n]&#x3D;0;\n        &#125;\n    &#125;\n&#125;\n\nint main()&#123;\n    cin&gt;&gt;n;\n    for(int i&#x3D;0;i&lt;n;i++)&#123;\n        for(int j&#x3D;0;j&lt;n;j++)&#123;\n            graph[i][j]&#x3D;&#39;.&#39;;\n        &#125;\n    &#125;\n    dfs(0); &#x2F;&#x2F;从第零行开始dfs\n    return 0;\n&#125;\n这种算法的时间复杂度是O(n*n!)可以看见复杂度很高，当然后面还有优化的。\n第二种dfs方法这一种dfs的方法比上一种更加的朴素。我们对于每一个格子，分别有两种选择，放还是不放。以此构成一个二叉决策树，树的深度就是n方，格子的个数。思路很简单。下面为代码：\n#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nconst int N &#x3D; 20;\nint n;\nchar graph[N][N];\nbool row[N],col[N],dg[N],udg[N];\n\nvoid dfs(int x,int y,int s)&#123;\n    if(y&#x3D;&#x3D;n)&#123; &#x2F;&#x2F;如果y&#x3D;&#x3D;n说明已经出界了，那我们让y回到零，同时让行数++\n        y&#x3D;0;\n        x++;\n    &#125;\n    if(x&#x3D;&#x3D;n)&#123;\n        if(s&#x3D;&#x3D;n)&#123; &#x2F;&#x2F;如果x到了n就说明n-1.n-1这个点已经过了，并且皇后已经放了n个的话就可以输出了，然后结束递归\n            for(int i&#x3D;0;i&lt;n;i++)&#123;\n                for(int j&#x3D;0;j&lt;n;j++)&#123;\n                    cout&lt;&lt;graph[i][j];\n                &#125;\n                cout&lt;&lt;endl;\n            &#125;\n            cout&lt;&lt;endl;\n        &#125;\n        return;\n    &#125;\n    &#x2F;&#x2F;不放皇后的情况\n    dfs(x,y+1,s);\n    &#x2F;&#x2F;放皇后的情况，这里要放的时候要注意不能和其他皇后起冲突\n    if(!row[x]&amp;&amp;!col[y]&amp;&amp;!dg[x+y]&amp;&amp;!udg[x-y+n])&#123;\n        row[x]&#x3D;1; &#x2F;&#x2F;更新所有数组\n        col[y]&#x3D;1;\n        dg[x+y]&#x3D;1;\n        udg[x-y+n]&#x3D;1;\n        graph[x][y]&#x3D;&#39;Q&#39;;\n        dfs(x,y+1,s+1); &#x2F;&#x2F;然后前往下一个点，同时放的皇后计数器++。\n        row[x]&#x3D;0; &#x2F;&#x2F;恢复现场\n        col[y]&#x3D;0;\n        dg[x+y]&#x3D;0;\n        udg[x-y+n]&#x3D;0;\n        graph[x][y]&#x3D;&#39;.&#39;;\n    &#125;\n&#125;\n\nint main()&#123;\n    cin&gt;&gt;n;\n    for(int i&#x3D;0;i&lt;n;i++)&#123;\n        for(int j&#x3D;0;j&lt;n;j++)&#123;\n            graph[i][j]&#x3D;&#39;.&#39;;\n        &#125;\n    &#125;\n    dfs(0,0,0); &#x2F;&#x2F;三个参数分别为第x行第y列，当前已经放了几个皇后了。\n    \n    return 0;\n&#125;\n\n这个算法的时间复杂度是O(2^(n^2))。时间复杂度也是非常的高。\n好的，就那么多。我们下次再见~Bye~\n","slug":"ACM学习笔记day19","date":"2022-12-11T14:48:21.000Z","categories_index":"ACM","tags_index":"ACM,打卡,学习,算法,数据结构,dfs,N皇后","author_index":"Ausert"},{"id":"d247f335debb5355e7105da57059aeeb","title":"网站开发日志2(新增了图床)","content":"emmm，日志是之后写的，实际的实现功能在之前就完成了这里只是补个开发日志而已\n\n\n更新内容：\n\n\n\n\n\n\n\n\n\n新增了图床，博客中可以上传图片了\n简单学习了一下图床，现在所有的图片我都放图床上了那么接下来，我们博客里面也就能看到图片力！好耶！\n\n","slug":"网站开发日志2","date":"2022-12-11T08:51:32.000Z","categories_index":"个人博客开发","tags_index":"学习,网站部署,网站开发,网站维护,图床","author_index":"Ausert"},{"id":"43196df8e77fd8e5155e9b94ef5532f4","title":"ACM学习笔记day18(dfs)","content":"今天的内容是dfs，对应的acwing题目\ndfs深搜，不难理解，而且之前在白书上我也学过啥意思也不多赘述这里主要讲解一下这题的思路\n\n\n\n给你个n，让你求所有可能的排列组合，也就是求permutation因为n很小，所有dfs能过我们从第0个数字开始接下来选第1个数字，有n中可能对应的就是n个分叉然后每个分叉又有n-1一种可能直到选到了第n个数字，在存储上，也就是dfs(x)这个x到了n，因为我们存储的时候下标是从零开始的可以理解为这个样子\n\n我们不断深入之后，到了底层，然后要回溯，回溯的时候这题不要忘了还原现场，也就是说，我们到了底层，所有的数字都拿过了，回溯的时候要把去掉的数字标记为没拿过下面我们结合代码来看\n#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nconst int N &#x3D; 10;\nint path[N]; &#x2F;&#x2F;路径数组，用来表示结果的数字\nbool st[N]; &#x2F;&#x2F;状态数组，用来表示下标为i的数字有没有拿，这里下标是i就是数字i\nint n;\n\nvoid dfs(int x)&#123;\n    if(x&#x3D;&#x3D;n)&#123; &#x2F;&#x2F;如果x和n相等，标明已经集齐了n个数字，可以输出了\n        for(int i&#x3D;0;i&lt;n;i++)&#123;\n            cout&lt;&lt;path[i]&lt;&lt;&quot; &quot;;\n        &#125;\n        cout&lt;&lt;endl;\n        return ; \n    &#125;\n    for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123; &#x2F;&#x2F;从这个n个数字中一个一个去找，看那个是没有拿过的\n        if(!st[i])&#123; &#x2F;&#x2F;如果没拿过，也就是st值是零\n            path[x]&#x3D;i; &#x2F;&#x2F;将这个i存入我们的path中去\n            st[i]&#x3D;1; &#x2F;&#x2F;同时st表示为true\n            dfs(x+1); &#x2F;&#x2F;继续深入一层去\n            st[i]&#x3D;0; &#x2F;&#x2F;这里表示回溯的时候，还原现场，也就是对应的st[i]要为零，表示没拿过，因为你回溯了嘛\n        &#125;\n    &#125;\n&#125;\nint main()&#123;\n    cin&gt;&gt;n;\n    dfs(0); &#x2F;&#x2F;从0开始递归，如果从1的话，判断x和n相等的条件得是n+1\n    return 0;\n&#125;\n\nemm，今天刚考完六级，稍微水了点，先这样吧bye~\n","slug":"ACM学习笔记day18","date":"2022-12-10T15:15:28.000Z","categories_index":"ACM","tags_index":"ACM,打卡,学习,算法,数据结构,dfs","author_index":"Ausert"},{"id":"633b5f64cd1a9eff1c65ad66ca026b45","title":"ACM学习笔记day17(floyd算法求多源最短路)","content":"额，距离上次写ACM笔记好像已经过了很久了其实这是有原因(借口)的，在被模电折磨捏~好了，不多bb了今天学习的内容是Floyd算法求多源最短路。这个算法写起来东西很少，同时也比较简单，从整体上去理解的话，感觉还是不难理解的运用的思想就是DP的思想\n\n\n直接上代码吧，思想是dp的思想，但是实际操作起来，只有三重嵌套循环，然后不断的用\n&#96; d[i][j]&#x3D;min(d[i][j],d[i][k]+d[k][j]);\n这个来更新距离，注意在floyd算法中，我们直接将用来存储图信息的领接矩阵作为最终的结果距离矩阵下面为acwing上对应的floyd算法的题目\n#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nconst int N &#x3D; 210;\nconst int INF &#x3D; 1e9;&#x2F;&#x2F;这里这题INF的值不能太大也不能太小，太大了不知道为啥结果溢出了，太小的话，可能会没有路的长度长，起不到无穷的作用\nint d[N][N];\nint n,m,k;\nvoid floyd()&#123;\n    &#x2F;&#x2F;三重嵌套循环，其中k必须在最外面\n    &#x2F;&#x2F;DP的状态转移方程为d[k][i][j]&#x3D;min(d[k-1][i][k]+d[k-1][k][j],d[k][i][j]);\n    &#x2F;&#x2F;当然这里这个k可以优化掉，额，这就具体涉及DP里面的东西了\n    &#x2F;&#x2F;dp的东西我们之后再说吧\n    for(int k&#x3D;1;k&lt;&#x3D;n;k++)&#123;\n        for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;\n            for(int j&#x3D;1;j&lt;&#x3D;n;j++)&#123;\n                d[i][j]&#x3D;min(d[i][j],d[i][k]+d[k][j]);\n            &#125;\n        &#125;\n    &#125;\n&#125;\n\nint main()&#123;\n    cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;\n    for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;\n        for(int j&#x3D;1;j&lt;&#x3D;n;j++)&#123;\n            if(i&#x3D;&#x3D;j)&#123;\n                d[i][j]&#x3D;&#x3D;0;\n            &#125;\n            else&#123;\n                d[i][j]&#x3D;INF;\n            &#125;\n        &#125;\n    &#125;\n    while(m--)&#123;\n        int x,y,z;\n        cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;\n        d[x][y]&#x3D;min(d[x][y],z);\n    &#125;\n    floyd();\n    while(k--)&#123;\n        int x,y;\n        cin&gt;&gt;x&gt;&gt;y;\n        &#x2F;&#x2F;这里因为存在负权边，所以可能实际上两个节点不能到达的距离结果上来看可能小于INF，所以这里判断条件要改成距离是较大值，而不是INF\n        if(d[x][y]&gt;INF&#x2F;2)&#123;\n            cout&lt;&lt;&quot;impossible&quot;&lt;&lt;endl;\n        &#125;\n        else&#123;\n            cout&lt;&lt;d[x][y]&lt;&lt;endl;\n        &#125;\n    &#125;\n    \n    return 0;\n&#125;\n\n好了，这就是今天的所有内容了，怎么感觉有点水（emmm，行吧，That’s all明天还要考六级捏Bye~\n","slug":"ACM学习笔记day17","date":"2022-12-09T14:20:36.000Z","categories_index":"ACM","tags_index":"ACM,打卡,学习,算法,数据结构,Floyd,图论","author_index":"Ausert"},{"id":"569c66ff03a6fea9d4ceedb2c072fa60","title":"ACM学习笔记day16(朴素dijkstra求最短路径)","content":"Hello，guys！今天我们学习的内容是dijkstra算法求最短路径,题目emm，第一次学这个的话，感觉还是比较抽象的，不过想了一段时间，稍微整理了一下思路，感觉也还可以应该（\n\n\n朴素Dijkstra为什么叫朴素dijkstra呢？因为目前这个dijkstra算法的时间复杂度是O(n^2)的有一个堆优化的算法是是O(mlogn)的朴素dijkstra是相对于堆优化而言的在朴素dijkstra中，我们要清楚两个概念一个是dist数组的意思dist[i]的意义是第i个节点到源点的距离另外一个就是我们把图中的节点分成了两个部分一个部分是最短路劲已经确定好了的节点另外一部分就是没有确定的节点我们用一个cnt数组，或者st数组来表示这个状态值为true即为最短路径已经确定了反之没有朴素dijkstra的算法思想是：我们首先初始化cnt数组中的所有值为0表示没有确定最短路径然后初始化dist数组除了第一个节点之外的所有节点的值为INF第一个节点的值为零表示一开始的时候，其他节点到源点的距离都是无穷。然后我们进行n次迭代，n是一共的节点数每一次迭代中，我们选取没有确定最短路径的节点中dist值最小的那个，取名叫t，或者第一次进行这个操作的的话就选择第一个节点然后我们去用这个节点去更新所有节点的dist值，取小的那个怎么更新呢？比如用j去遍历所有节点，dist[j]就等于dist[t]+t节点到j节点的距离和原来的值的取小的那个每一次迭代之后，dist的值都会多多少少变化的为什么要进行n次迭代呢？因为我们每一次的迭代都会确定一个节点的最短路径，n次下来，每个节点的最短路径都确定了问题也就解决了但是这里也可以只迭代n-1次，省略掉的一次是终点节点的迭代为什么可以省略终点节点的迭代呢？因为当迭代到n-1次的时候，此时终点的最短路径其实已经被n-1个节点确定好了因为我们每确定一个没确定最短路径的节点，就更新一遍所有节点的dist值其实如果迭代第n次的时候，做的都是无效操作，因为无论如何，dist+g的值都会比之前的最短路径要大的取min值不会取到的对了，acwing上这题，因为有重边，所有输入的时候，重边需要取min的那个下面为代码：\n#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nconst int N &#x3D; 510;\nconst int INF &#x3D; 0x3f3f3f3f; &#x2F;&#x2F;用这个值代表无穷\nint dist[N],g[N][N];\nint n,m;\nbool cnt[N]; &#x2F;&#x2F;状态数组，表示每个节点是否已经确定最短路径\n\nint dijkstra()&#123;\n    &#x2F;&#x2F;初始化dist值，每个都是INF\n    for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;\n        dist[i]&#x3D;INF;\n    &#125;\n    dist[1]&#x3D;0; &#x2F;&#x2F;将第一个节点初始化为INF\n    &#x2F;&#x2F;然后进行n次迭代，n-1也可以\n    for(int i&#x3D;0;i&lt;n;i++)&#123;\n        int t&#x3D;-1; &#x2F;&#x2F;t表示未被确定最短路径的到源点最近的点，t为-1即为不存在\n        for(int j&#x3D;1;j&lt;&#x3D;n;j++)&#123; &#x2F;&#x2F;去n个节点中去寻找我们所需要的点\n            if(!cnt[j]&amp;&amp;(t&#x3D;&#x3D;-1||dist[t]&gt;dist[j]))&#123; &#x2F;&#x2F;如果没有确定，并且他的dist值比dist[j]大，或者他是-1的话就直接选择t&#x3D;1，即第一个节点\n                t&#x3D;j; &#x2F;&#x2F;t赋值j\n            &#125;\n        &#125;\n        cnt[t]&#x3D;1;&#x2F;&#x2F;把此时的节点标记为确定了最短路径\n        &#x2F;&#x2F;n次循环，去更新n个节点的dist值\n        for(int j&#x3D;1;j&lt;&#x3D;n;j++)&#123;\n            dist[j]&#x3D;min(dist[j],dist[t]+g[t][j]);\n            &#x2F;&#x2F;到第j个节点有两种方式\n            &#x2F;&#x2F;一种是已经有的距离，即dist[j]\n            &#x2F;&#x2F;还有一种就是经过当前这个t节点的方式，即dist[t]+g[t][j]（这个表示t到j节点的距离）\n        &#125;\n    &#125;\n    &#x2F;&#x2F;如果他的值为INF，说明不存在，则返回-1\n    if(dist[n]&#x3D;&#x3D;INF)&#123;\n        return -1;\n    &#125;\n    else&#123;\n        return dist[n];\n    &#125;\n&#125;\n\nint main()&#123;\n    cin&gt;&gt;n&gt;&gt;m;\n    &#x2F;&#x2F;初始化领接矩阵每一个值为INF\n    for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;\n        for(int j&#x3D;1;j&lt;&#x3D;n;j++)&#123;\n            g[i][j]&#x3D;INF;\n        &#125;\n    &#125;\n    while(m--)&#123;\n        int x,y,z;\n        cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;\n        g[x][y]&#x3D;min(g[x][y],z); &#x2F;&#x2F;存储给入的值\n    &#125;\n    int res&#x3D;dijkstra();\n    cout&lt;&lt;res&lt;&lt;endl;\n    return 0;\n&#125;\nOK,guys.今天的内容就那么多啦虽然就一个算法，但是理解这个东西还是花费了我不少时间感觉到现在为止还是有点懵懵懂懂的还是需要一点时间去理解的吧Bye~\n","slug":"ACM学习笔记day16","date":"2022-12-03T13:32:15.000Z","categories_index":"ACM","tags_index":"ACM,打卡,学习,算法,数据结构,蒟蒻,dijkstra","author_index":"Ausert"},{"id":"5358138299a8ff147d7f561517fe5a1d","title":"ACM学习笔记day15(哈希，字符串的哈希)","content":"hello guys！今天的学习内容是哈希表，也就是散列表对应acwing上的模拟散列表和字符串哈希\n\n\n那么问题来了什么是哈希表呢？一句话来总结就是，不保序的离散化离散化其实是哈希化的一种特殊情况我们将数据范围很大的，较少的数字，映射到一个比较小的数组，这就是哈希，不过中间的那个映射值是哈希函数做的事情，也是导致他可能不保序的原因一般的，我们将哈希函数定义为x取余给的数字的总数之后的最小的一个质数比如给定10w个数字，100000之后的最小的一个质数是100003,那我们就将哈希函数定义为x%100003,当然，我们一般讲N就初始化为100003，这样我们直接%N就可以了然后我们接下来如果要找一个数x有没有，只要计算一下他的hash值，然后去哈希数组里面去找就可以了没有就是没有接下来，在计算哈希值的时候，容易产生的一个问题就是哈希冲突的问题什么是哈希冲突？就是明明是不同的两个数字，却存在了同一个地方，这就产生了问题。\n哈希冲突防止哈希冲突的方法有两种，一种是拉链法什么是拉链法？但说实话我感觉他更应该叫吊带法，感觉不像拉链，像很多的丝带吊在上面拉链法中，我们使用一个h[N]来作为杆子，h的值是指针，指向等会使用的链表节点然后我们使用一个链表ele[N],和ne[N]来维护杆子上n个口子可能产生的n个链表h[hash[i]],h数组的下标是我们加入进来的数字的hash值，我们加入进来的输入存入链表当中然后我们每插入一个数字，就相当于在以h[hash[i]]为头结点的表头插入一个元素。这样我们就用拉链法解决了hash冲突的问题，在平均情况下，我们可以认为哈希的存储和访问都是O（1）的当然极端情况下，比如每个数字的存入都是冲突的，导致查询一个数字是O(n)的，这种情况太极端了，我们一般不考虑代码如下：\n#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nconst int N &#x3D;100003;\nint ele[N],ne[N],idx;\nvector&lt;int&gt; h(N,-1);\n\nvoid insert(int x)&#123;\n    int k&#x3D;(x%N+N)%N;\n    ele[idx]&#x3D;x;\n    ne[idx]&#x3D;h[k];\n    h[k]&#x3D;idx++;\n&#125;\n\nbool find(int x)&#123;\n    int k&#x3D;(x%N+N)%N;\n    for(int i&#x3D;h[k];i!&#x3D;-1;i&#x3D;ne[i])&#123;\n        if(ele[i]&#x3D;&#x3D;x)&#123;\n            return true;\n        &#125;\n    &#125;\n    return false;\n&#125;\n\nint main()&#123;\n    int n;\n    cin&gt;&gt;n;\n    while(n--)&#123;\n        string s;\n        cin&gt;&gt;s;\n        if(s&#x3D;&#x3D;&quot;I&quot;)&#123;\n            int x;\n            cin&gt;&gt;x;\n            insert(x);\n        &#125;\n        else &#123;\n            int x;\n            cin&gt;&gt;x;\n            if(find(x))&#123;\n                cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl;\n            &#125;\n            else&#123;\n                cout&lt;&lt;&quot;No&quot;&lt;&lt;endl;\n            &#125;\n        &#125;\n    &#125;\n    return 0;\n&#125;\n\n还有一种是开放寻址法什么是开放寻址法呢？感觉就是向你去上厕所，你要上的这个坑位，有人了那就去下一个，如果还是有人了，继续去下一个直到到一个空位，然后数据存进去这就是开放寻址法开放寻址法不像拉链法需要额外开两个数组，作为链表来存储数据但是开放寻址法需要注意的是，存储数据的长度需要大一点，一般是给的数据量最大的两到三倍。同时我们需要的注意的是，我们一开始的时候要初始化数据为null，null为一个极大值，可以取成int的上界我们用null来表示这个位置为空，但是我觉得应该另外开一个数组来表示是否为空应该也可以，不过这样的话开放寻址法也要再开一个数组了，就不能体现出他的一个特点了awa代码如下：\n#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nconst int N &#x3D; 200003, null&#x3D;0x3f3f3f3f;\nint h[N];\n\nint find (int x)&#123;\n    int k&#x3D;(x%N+N)%N;\n    while(h[k]!&#x3D;x&amp;&amp;h[k]!&#x3D;null)&#123;\n        k++;\n        if(k&#x3D;&#x3D;N)&#123;\n            k&#x3D;0;\n        &#125;\n    &#125;\n    return k;\n&#125;\n\nint main()&#123;\n    int n;\n    cin&gt;&gt;n;\n    for(int i&#x3D;0;i&lt;N;i++)&#123;\n        h[i]&#x3D;null;\n    &#125;\n    while(n--)&#123;\n        string str;\n        cin&gt;&gt;str;\n        int x;\n        cin&gt;&gt;x;\n        int t&#x3D;find(x);\n        if(str&#x3D;&#x3D;&quot;I&quot;)&#123;\n            h[t]&#x3D;x;\n        &#125;\n        else&#123;\n            if(h[t]&#x3D;&#x3D;null)&#123;\n                cout&lt;&lt;&quot;No&quot;&lt;&lt;endl;\n            &#125;\n            else&#123;\n                cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl;\n            &#125;\n        &#125;\n    &#125;\n&#125;\n接下来是字符串的哈希这个就有点难理解了比之前那个普通的哈希要稍微难一点但是实际写起来的代码量还是很少的所以关键就在于如何理解字符串哈希\n字符串哈希什么是字符串的哈希？顾名思义嗷其实就是让一个字符串对应一个数值，这个数值我们就定义为他的哈希值而这个数值怎么来的，就是我们的哈希函数首先我们为了能够在O(1)的时间内求出一段字符串任意一段子串的哈希值，我们要预处理一下给定字符串也就是求一下给定字符串的前缀的哈希值然后运用前缀和的理论，来快速的求出任意一段的哈希值当然我们要说一个哈希冲突的问题，字符串哈希也是可能哈希冲突的但是这个概率很小，基本上99.99%的时候都不用考虑字符串哈希冲突的问题如果真冲突了，额，那也不是我能做出来的（所以字符串哈希和一般的哈希不太一样，他不用考虑哈希冲突的问题，当然这不是说他不可能发生啊好我们回到刚才那个问题上来，首先我们抛出两个问题怎么求前缀和的哈希值以及怎么通过前缀和去求任意一段字符串的哈希值这里我们的哈希手法是：\n\n\n\n\n\n\n\n\n\n把字符串看成是一个P进制的数字，位数从左往右越来越低，然后使用每一位字母的ASCII码值作为该位对应的值一般的，我们取P为131或者13331，这样的话，产生哈希冲突的概率最小，同时我们产生了一个新的问题，就是我们按照P进制，把字符串转化为哈希值之后，产生的数字可能会很大，那么我们就取模2^64，将结果限定在longlong的范围内为了避免，我们要写%2^64这样的操作，我们使用unsigned long long，这个类型，当数据越界了之后，他会自动取模，可以让我们省略取模的动作\n字符串前缀的哈希值是多少我们解决了，那么如何求任意一段的哈希值呢？比如l~r的这一段的哈希值很简单，我们把h[r]按照P进制写出来，h[l-1]按照P进制写出来不难发现，我们要求的一段的字符串的哈希值，是同样按照P进制转化为10进制化出来的那么我们只要把h[l-1]按照p进制左移直到左对齐，然后h[r]-h[l-1]即可得到结果因为大的那个是r位的小的那个是l-1位的所以要移动的位数为r-l+1位即h[l-1]*p^(r-l+1);综上，我们字符串哈希的很多问题已近解决了代码如下\n#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\ntypedef unsigned long long ULL;\nconst int N &#x3D; 100010, P &#x3D;131;\nint n,m;\nstring s;\nULL h[N],p[N];\n\nULL get(int l,int r)&#123;\n    return h[r]-h[l-1]*p[r-l+1];\n&#125;\n\nint main()&#123;\n    cin&gt;&gt;n&gt;&gt;m;\n    s+&#x3D;&quot; &quot;;\n    string str;\n    cin&gt;&gt;str;\n    s+&#x3D;str;\n    p[0]&#x3D;1;\n    for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;\n        p[i]&#x3D;p[i-1]*P;\n        h[i]&#x3D;h[i-1]*P+s[i];\n    &#125;\n    while(m--)&#123;\n        int l1,r1,l2,r2;\n        cin&gt;&gt;l1&gt;&gt;r1&gt;&gt;l2&gt;&gt;r2;\n        if(get(l1,r1)&#x3D;&#x3D;get(l2,r2))&#123;\n            cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl;\n        &#125;\n        else&#123;\n            cout&lt;&lt;&quot;No&quot;&lt;&lt;endl;\n        &#125;\n    &#125;\n    return 0;\n&#125;\n\nOK That’s all我们下次再见~Bye~\n","slug":"ACM学习笔记day15","date":"2022-12-02T12:15:59.000Z","categories_index":"ACM","tags_index":"ACM,打卡,学习,算法,数据结构,笔记,哈希表","author_index":"Ausert"},{"id":"baee1de5b96302e6e975d5e11b914928","title":"ACM学习笔记day14（带权并查集，堆排序，模拟堆）","content":"Hello guys!感觉好久没有写笔记了，上次写笔记好像是呃呃呃，五天前了吧。要忙学校的好多事情，呜呜呜，我有罪orz好了，不bb了，今天的学习内容是带权并查集（食物链）,堆模拟,堆排序\n\n\n带权并查集带权并查集就是原来并查集的升级版，plus版本。相较于原来的普通的并查集，带权并查集我们所维护的树，每一条边都有了权值。这就是带权并查集下面针对acwing上这道题目来理解带权并查集。食物链的题目。题目简单描述一下，有ABC三种动物，这三种动物是互相吃的比如，A吃B，B吃C，C吃A，食物链是形成一个闭环的。然后现在有N个动物，给你k个说法，判断里面有多少假话。假话的标准(满足其中一个就是假话)是：\n\n\n\n\n\n\n\n\n\n当前的话与前面的某些真的话冲突，就是假话；当前的话中 X 或 Y 比 N 大，就是假话；当前的话表示 X 吃 X，就是假话。\nk个说法中，有两种形式\n\n\n\n\n\n\n\n\n\n\n1 X Y 表示X和Y 是同类\n2 X Y 表示X吃Y。\n\n对于这题，我们维护一个树，树的不同节点，表示各个动物，然后我们对于每个节点，使之与根节点建立联系如果说，当前节点与根节点的距离为1，就定义为当前节点吃根节点，如果为2，就是被根节点吃如果是3就是与根节点同类实际过程中，这个距离难免会出现大于3的情况，因为一共就三种动物，所以距离是以3为循环的所以我们处理操作的时候让距离mod3就可以了这里我们要定义两个数组，一个是p[N]，一个是d[N]，p是该节点的父亲节点，这个不多赘述而d是该节点的距离其双亲节点的距离，注意！是到双亲的距离，不是根节点的距离，这个概念很重要！！好，我们定义完这个并查集的带权信息后，那么我们怎么界定X和Y是否是同类，是否是吃和被吃的关系呢？如果是同类并且根节点是同一个的话，如果X到根节点的距离%3为零，并且Y到根节点的距离%3也为零，就说明X和Y都是和根节点同类的也就说明X和Y同类。在数值上表现为(d[x]-d[y])%3&#x3D;&#x3D;0如果X是吃Y的并且在根节点是一致的，那我们就去找X是和根节点是同类的，然后Y是被根节点吃的，当然这是一种特殊的情况，但是计算值可以代表普遍属性也就是(d[x]-d[y]-1)%3&#x3D;&#x3D;0如果根节点不一样的话，说明我们所维护的树上，没有这个信息，不用管肯定是真的，将目前的信息加入到树上。下面为代码：\n#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nconst int N &#x3D; 100010;\nint p[N],d[N]; &#x2F;&#x2F;p代表一个节点的双亲节点是谁，d表示一个节点的到双亲结点的距离\nint n,m; &#x2F;&#x2F;n是节点个数，m是m个陈述\n&#x2F;&#x2F;并查集里面基础的模板查找，find函数，查找一个节点的根节点，同时进行路劲压缩和d距离的修改\nint find(int x)&#123;\n    if(p[x]!&#x3D;x)&#123;\n        int t&#x3D;find(p[x]); &#x2F;&#x2F;这里要提前存一下他的根节点是哪个，如果这里不存t，下面那个地方写p[X]&#x3D;find（p[x]）会出错\n        &#x2F;&#x2F;具体原因是因为递归的关系，这种写法才可以，如果看到不懂的，可以自己模拟一下递归的过程，或者直接记住这个就可以了\n        d[x]+&#x3D;d[p[x]]; &#x2F;&#x2F;将当前这个节点到根节点的距离递加父节点到根节点的距离。如果去模拟这个递推的过程的话，这个\n        &#x2F;&#x2F;不难理解，先根节点的一个孩子节点进行，然后再孩子节点，距离弄完，同时也把他直接连到了根节点上。\n        &#x2F;&#x2F;同时，这个时候再让d[x]+&#x3D;d[p[x]]也就是当前节点到根节点的距离了\n        p[x]&#x3D;t; &#x2F;&#x2F;路径压缩 \n    &#125;\n    return p[x]; &#x2F;&#x2F;返回根节点\n&#125;\nint main()&#123;\n    cin&gt;&gt;n&gt;&gt;m;\n    &#x2F;&#x2F;p数组的初始化，不要忘了！\n    for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;\n        p[i]&#x3D;i;\n    &#125;\n    int res&#x3D;0; &#x2F;&#x2F;结果\n    &#x2F;&#x2F;m次询问\n    while(m--)&#123;\n        int t,x,y;\n        cin&gt;&gt;t&gt;&gt;x&gt;&gt;y;\n        if(x&gt;n||y&gt;n)&#123; &#x2F;&#x2F;如果x，y超出了n的范围，直接可以得出来是假的\n            res++;\n        &#125;\n        else&#123;\n        int px&#x3D;find(x),py&#x3D;find(y); &#x2F;&#x2F;非常妙的一步\n        &#x2F;&#x2F;首先先把x和y的根节点给存储起来，这还不是最妙的\n        &#x2F;&#x2F;最妙的是先进行了这样的一部操作，是进行了一次路径压缩，也就是说，下面用到的d[x],d[y]，\n        &#x2F;&#x2F;定义上是该节点到他的父节点的距离，但是实际上是到根节点的距离，这样，我们也就方便我们接下来的操作了。\n        if(t&#x3D;&#x3D;1)&#123; \n            if(px&#x3D;&#x3D;py&amp;&amp;(d[x]-d[y])%3)&#123; &#x2F;&#x2F;如果在一棵树上，并且不是同类的话\n                res++; &#x2F;&#x2F;假话++：\n            &#125;\n            else if(px!&#x3D;py)&#123; &#x2F;&#x2F;如果不在一棵树上，说明目前没有这个信息，就把他存进去\n                &#x2F;&#x2F;添加信息，其实很简单，就两步操作，一个是把树连过去，一个是修改d的值\n                &#x2F;&#x2F;注意，如果把px连py上，那么要修改的是d[px]而不是其他的比如d[x]或者d[y]\n                &#x2F;&#x2F;修改根才是真的修改，不然都是部分的修改，没有修改本质\n                d[px]&#x3D;d[y]-d[x];  &#x2F;&#x2F;这个可以画图加上列方程求解这里为啥是这个值\n                p[px]&#x3D;py; &#x2F;&#x2F;把px连到py上\n            &#125;\n        &#125;\n        else&#123;\n            if(px&#x3D;&#x3D;py&amp;&amp;(d[x]-d[y]-1)%3)&#123; &#x2F;&#x2F;如果在同一树上并且不满足x吃y的关系，res++\n                res++;\n            &#125;\n            else if(px!&#x3D;py)&#123;\n                d[px]&#x3D;1+d[y]-d[x]; &#x2F;&#x2F;为什么是这个值同理，画图加方程求解\n                p[px]&#x3D;py;\n            &#125;\n        &#125;\n        &#125;\n    &#125;\n    cout&lt;&lt;res&lt;&lt;endl;\n    return 0;\n&#125;\n\n好了，差不多这题差不多就是这么个意思，关键就在于使用带权并查集然后并且赋予权值意义，结合题意来求解\n下一题是\n模拟堆什么是堆？其实堆就是一个完全二叉树，堆分为小根堆和大根堆。小根堆就是，根节点的值是小于等于左右孩子节点的值的，对于一棵树的每一颗子树都是这样的，这样就是小根堆大根堆同理。堆一般有三个操作\n\n\n\n\n\n\n\n\n\n1.插入一个数2.输出当前集合的最小值3.删除最小值\n除此之外，有更进阶的操作是\n\n\n\n\n\n\n\n\n\n4.删除第k个插入的数字5.修改第k个插入的数字\n这些那么多操作的背后，有两个基本的操作\n\n\n\n\n\n\n\n\n\n1.up操作，就是把当前数字的位置往上移动，直到目前的位置满足小根堆的定义或者大根堆的定义2.down操作和up操作刚好反过来。\n模拟堆，我们一般用一维数组来存储，一个节点的左孩子是2*i，右孩子是2*i+1,这里其实就是完全二叉树的一个性质用到了这个性质来用数组模拟二叉树的结构。\n对于acwing上的这题模拟堆，要想满足还要删除修改第k个值，需要用到两个额外的数组，一个是ph[N],一个是hp[N]其中ph[i]，表示第i个插入的数组在堆中是第几个数字，hp[i]表示堆中的第i个数字是第几个插入的为什么要用到这两个数组呢？因为我们修改一个数的值的时候，为了维护堆，必然要让他up和down的，那么此时他在堆的编号和他实际是第几个插入的已经不匹配了所以我们需要这么两个数组来获取编号信息同时，因为我们用到了这两个数组，普通的swap函数已经不能用了，我们需要自己写一个特殊的swap函数，用于交换数字之后，hp和ph的值也要交换下面结合代码来看看如何操作\n#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nconst int N &#x3D;100010;\nint n,m; &#x2F;&#x2F;这里这个m是统计第几个插入的数字的\nint heap[N],hp[N],ph[N],sz;  &#x2F;&#x2F;sz表示当前堆的大小，sz指向的是当前堆的最后一个数字\n&#x2F;&#x2F;heap数组用于存放堆的数据，hp和ph上面已经说明过了\n&#x2F;&#x2F;堆里面特殊的swap操作,首先你要交换ph指针，然后交换hp指针，然后交换heap里面的数值 这里，输入的数值是堆里面的第几个数\n&#x2F;&#x2F;也不在是单纯的数值了\nvoid heap_swap(int a,int b)&#123;\n    swap(ph[hp[a]],ph[hp[b]]);\n    swap(hp[a],hp[b]);\n    swap(heap[a],heap[b]);\n&#125;\n\nvoid down(int i)&#123;\n    int min&#x3D;i; &#x2F;&#x2F;记录三个数中的最小的那个标号\n    if(2*i&lt;&#x3D;sz&amp;&amp;heap[2*i]&lt;heap[min])&#123; &#x2F;&#x2F;如果存在左孩子，并且左孩子比min值小，就把min更新\n        min&#x3D;2*i;\n    &#125;\n    if(2*i+1&lt;&#x3D;sz&amp;&amp;heap[2*i+1]&lt;heap[min])&#123; &#x2F;&#x2F;同理，维护min\n        min&#x3D;2*i+1;\n    &#125;\n    if(min!&#x3D;i)&#123; &#x2F;&#x2F;如果此时min和要求down的i不一样，说明此时的i需要往下移动\n        heap_swap(min,i); &#x2F;&#x2F;交换min和i的值\n        down(min); &#x2F;&#x2F;递归继续进行down操作直到满足小根堆的条件\n    &#125;\n&#125;\n\nvoid up(int i)&#123;\n    if(i&#x2F;2&gt;0&amp;&amp;heap[i]&lt;heap[i&#x2F;2])&#123; &#x2F;&#x2F;如果他的值是小于双亲结点，那么就交换一下数字，然后继续up就可以了\n        heap_swap(i,i&#x2F;2);\n        up(i&#x2F;2);\n    &#125;\n&#125;\n\nint main()&#123;\n    cin&gt;&gt;n;\n    while(n--)&#123;\n        string op;\n        cin&gt;&gt;op;\n        if(op&#x3D;&#x3D;&quot;I&quot;)&#123;\n            &#x2F;&#x2F;插入一个数字x\n            int x;\n            cin&gt;&gt;x;\n            m++; &#x2F;&#x2F;m++，这是第m插入的\n            sz++; &#x2F;&#x2F;同时数字的大小也要增加1\n            ph[m]&#x3D;sz; &#x2F;&#x2F;第m个插入的在堆里面是第sz个\n            hp[sz]&#x3D;m; &#x2F;&#x2F;堆里面的第sz个是第m个插入的\n            heap[sz]&#x3D;x; &#x2F;&#x2F;把值存入heap里面去 \n            up(sz); &#x2F;&#x2F;因为插入在尾部，所以要up他，来维护小根堆的定义\n        &#125;\n        else if(op&#x3D;&#x3D;&quot;PM&quot;)&#123;\n            cout&lt;&lt;heap[1]&lt;&lt;endl;\n        &#125;\n        else if(op&#x3D;&#x3D;&quot;DM&quot;)&#123;\n            heap_swap(1,sz); &#x2F;&#x2F;删除最小的节点，就直接交换第一个节点和最后一个可以了\n            sz--;&#x2F;&#x2F;sz--就是删掉了最后一个节点\n            down(1); &#x2F;&#x2F;别忘了要down一下最后一个节点，来维护小根堆的定义\n        &#125;\n        else if(op&#x3D;&#x3D;&quot;D&quot;)&#123;\n            int k;\n            cin&gt;&gt;k;\n            &#x2F;&#x2F;要删除第k个数字，同理的，把第k个数字和最后一个数字交换一下\n            int u&#x3D;ph[k]; &#x2F;&#x2F;要先存一下ph[k]的信息，交换完之后的话，不存到这个u里面，会不知道down和up谁去\n            heap_swap(ph[k],sz);\n            sz--;\n            up(u);\n            down(u);\n        &#125;\n        else&#123;\n            int k,x;\n            cin&gt;&gt;k&gt;&gt;x;\n            heap[ph[k]]&#x3D;x; &#x2F;&#x2F;修改值\n            up(ph[k]); &#x2F;&#x2F;然后维护一下小根堆\n            down(ph[k]);\n        &#125;\n    &#125;\n    return 0;\n&#125;\n\n总之，模拟堆的基本思想就是用一维数组去模拟完全二叉树的结构，然后根据堆的结构去维护这样的一个树基本的操作就是两个up和down，删除操作一般是要删除的节点和最后一个节点互换，然后删除最后一个节点来进行的。基本的东西就这些接下来的就是堆排序理解了模拟堆之后，堆排序也就很简单了。因为我们如果要升序排序的话，只要构建一个小根堆就可以了降序的话就是大根堆\n我们来看acwing的这道题，直接结合代码来说明了理解完堆之后理解这个不难的\n#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nconst int N &#x3D; 100010;\nint n,m;\nint heap[N],sz;\n&#x2F;&#x2F;正常的down操作，这里我们不需要up操作\n&#x2F;&#x2F;因为我们只要前m小的数字，输出一个删掉一个，不会用到up操作的\nvoid down(int n)&#123;\n    int t&#x3D;n;\n    if(2*n&lt;&#x3D;sz&amp;&amp;heap[2*n]&lt;heap[t])&#123;\n        t&#x3D;2*n;\n    &#125;\n    if(2*n+1&lt;&#x3D;sz&amp;&amp;heap[2*n+1]&lt;heap[t])&#123;\n        t&#x3D;2*n+1;\n    &#125;\n    if(t!&#x3D;n)&#123;\n        swap(heap[t],heap[n]);\n        down(t);\n    &#125;\n&#125;\n\nint main()&#123;\n    cin&gt;&gt;n&gt;&gt;m;\n    sz&#x3D;n;\n    for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;\n        cin&gt;&gt;heap[i]; &#x2F;&#x2F;我们先把数据都输入到堆里面去\n    &#125;\n    &#x2F;&#x2F;这里这个是个特殊的操作，我们如何快速构建一个堆？在O(n)时间内\n    &#x2F;&#x2F;我们从第n&#x2F;2开始进行down操作，一直进行到第1个\n    &#x2F;&#x2F;这么操作之后的话我们就把数据成功构建成一个堆了\n    &#x2F;&#x2F;当然也可以一个一个插入，这样的话是O(nlogn)的时间复杂度了\n    for(int i&#x3D;n&#x2F;2;i;i--)&#123;\n        down(i); \n    &#125;\n    while(m--)&#123;\n        cout&lt;&lt;heap[1]&lt;&lt;&quot; &quot;; &#x2F;&#x2F;输出最小值\n        heap[1]&#x3D;heap[sz]; &#x2F;&#x2F;删除最小值\n        sz--;\n        down(1); &#x2F;&#x2F;别忘了再维护一下小根堆\n    &#125;\n    return 0;\n&#125;\n\n好啦，这就是全部内容啦，模拟堆和食物链这两题里面你的东西还是比较多的，不过理解起来还好，问题不是很大那么bye~我们下次再见啦~qwq\n","slug":"ACM学习笔记day14","date":"2022-12-01T14:13:12.000Z","categories_index":"ACM","tags_index":"ACM,打卡,学习,算法,数据结构,带权并查集,堆","author_index":"Ausert"},{"id":"d45c53bbd2d951bda24bba0bdde79964","title":"ACM学习笔记day13(求连通块中点的数量)","content":"今天的内容是求连通块中点的数量\n求连通块中点的数量这题和并查集那道模板题差不多就是多了一个要求让你统计集合中的数量而已\n\n\n这里我们用到一个cnt数组，同时我们规定，只有根节点的cnt数据是有意义的这样我们就避免了要给多个同连通块的集合重新赋值的麻烦\n#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nconst int N &#x3D; 100010;\nint p[N],cnt[N];\nint n,m;\n\nint find(int x)&#123;\n    if(p[x]!&#x3D;x)&#123;\n        p[x]&#x3D;find(p[x]);\n    &#125;\n    return p[x];\n&#125;\n\nint main()&#123;\n    cin&gt;&gt;n&gt;&gt;m;\n    for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;\n        p[i]&#x3D;i;\n        cnt[i]&#x3D;1; &#x2F;&#x2F;一开始每一个连通块中都只有一个点\n    &#125;\n    while(m--)&#123;\n        string op;\n        cin&gt;&gt;op;\n        if(op&#x3D;&#x3D;&quot;C&quot;)&#123;\n            int a,b;\n            cin&gt;&gt;a&gt;&gt;b;\n            if(find(a)&#x3D;&#x3D;find(b)) continue; &#x2F;&#x2F;这里特判一下，如果a和b已经在同一个连通块里面了，不需要在加啥了，不然会将值翻倍导致WA\n            cnt[find(b)]+&#x3D;cnt[find(a)];&#x2F;&#x2F;新的树的cnt个数也就是原来的加上另外一个的cnt值\n            p[find(a)]&#x3D;find(b); &#x2F;&#x2F;这里cnt改变要先进行，不然find(a)的值会被改变，也就会导致cnt计数错误\n        &#125;\n        else if(op&#x3D;&#x3D;&quot;Q1&quot;)&#123;\n            int a,b;\n            cin&gt;&gt;a&gt;&gt;b;\n            if(find(a)&#x3D;&#x3D;find(b))&#123;\n                cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl;\n            &#125;\n            else&#123;\n                cout&lt;&lt;&quot;No&quot;&lt;&lt;endl;\n            &#125;\n        &#125;\n        else&#123;\n            int a;\n            cin&gt;&gt;a;\n            cout&lt;&lt;cnt[find(a)]&lt;&lt;endl;&#x2F;&#x2F;要就输出结果的话，就直接输出a的根节点的cnt的值就可以了\n        &#125;\n    &#125;\n    return 0;\n&#125;","slug":"ACM学习笔记day13","date":"2022-11-25T11:42:49.000Z","categories_index":"ACM","tags_index":"ACM,打卡,学习,算法,数据结构,并查集","author_index":"Ausert"},{"id":"5299e436ed1961fa0cb39dca432850d2","title":"ACM学习笔记day12(最大异或对，并查集)","content":"今天的内容是Trie树的应用和并查集的学习。这个最大异或对的话，就是Trie树的应用，然后有别于之前那个Trie树存的数据不一样，之前那个存的是char，现在这个存的是0和1。然后并查集的话感觉就是构建了一个森林，然后每一颗树代表了一定的信息。\n\n\n最大异或对最大异或对。题目是啥呢，emmm给你n个数字，然后从中任意选两个，作异或操作，问最大的结果是什么我们先来暴力做法，i遍历一边数组，然后j遍历一边数组，然后让i和j指向的数字取异或，每次维护res值暴力的思想很简单，但是因为是n方的算法，所有是肯定会超时的然后我们想怎么优化，要想让异或取最大，如果我们给定一个数，那么我们对应位上的0和1，要和给定的数字尽可能的不同这样异或出来的结果是最大的，其实是贪心的思想。那我们让i去遍历数组，然后建立Trie树，在树上寻找尽可能和给定的数字对应位上的0和1不同的数字如果有那最好，如果没有那只能取相同的。根据给定的数据范围，Trie树的深度最大就为30，所以这个算法的时间复杂度是30*n，最大也就是10^6，使满足在1s内结束工作的思路就是这样，然后我们结合代码来看\n#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nconst int N &#x3D; 100010,M &#x3D; 3000010; \nint son[M][2],idx; &#x2F;&#x2F;这里M是代表总的节点数最大为多少 (为什么是300w，因为一共就100000个数据，然后一个数据最多就30个结点，一乘不就是300w了?)\nint a[N],n; &#x2F;&#x2F;存n个数据\n\n&#x2F;&#x2F;插入函数，把数据以01的形式插入到我们的Trie树中去  \nvoid insert(int x)&#123;\n    int p&#x3D;0;&#x2F;&#x2F;p代表指向当前节点的指针\n    &#x2F;&#x2F;因为数字化为01之后，最大长度就是30位，我们从最高位开始把01存入我们Trie树中去\n    for(int i&#x3D;30;i&gt;&#x3D;0;i--)&#123;\n        int&amp; s&#x3D;son[p][x&gt;&gt;i&amp;1]; &#x2F;&#x2F;这里s代表第p个节点的子节点，x&gt;&gt;i&amp;1表示取x第i位的值，是0还是1\n        if(!s)&#123; &#x2F;&#x2F;如果没有s这个节点，则创建一个。\n            s&#x3D;++idx; \n        &#125;\n        p&#x3D;s;&#x2F;&#x2F;让p指向这个s\n    &#125;\n&#125;\n&#x2F;&#x2F;这个query操作呢，是给你一个数，然后在Trie树里面寻找最优解，将结果返回\nint query(int x)&#123;\n    int res&#x3D;0;\n    int p&#x3D;0;\n    for(int i&#x3D;30;i&gt;&#x3D;0;i--)&#123;\n        int s&#x3D;x&gt;&gt;i&amp;1; &#x2F;&#x2F;取x的第i位，从尾巴开始计数的\n        if(son[p][!s])&#123; &#x2F;&#x2F;判断存不存在与当前位不同的\n            res+&#x3D;1&lt;&lt;i; &#x2F;&#x2F;存在，也就是给结果贡献一个1，从高位开始的\n            p&#x3D;son[p][!s];&#x2F;&#x2F;让p指向那边\n        &#125;\n        else&#123;\n            p&#x3D;son[p][s]; &#x2F;&#x2F;不存在，那结果里面那位就是零，等于没操作\n        &#125;\n    &#125;\n    return res;&#x2F;&#x2F;最后返回res\n&#125;\n&#x2F;&#x2F;main函数里面的操作就非常简单了\nint main()&#123;\n    cin&gt;&gt;n;\n    for(int i&#x3D;0;i&lt;n;i++)&#123;\n        cin&gt;&gt;a[i];\n        insert(a[i]);\n    &#125;\n    int res&#x3D;0;\n    for(int i&#x3D;0;i&lt;n;i++)&#123;\n        res&#x3D;max(res,query(a[i]));\n    &#125;\n    cout&lt;&lt;res&lt;&lt;endl;\n    return 0;\n&#125;\n\n\n并查集题目链接-合并集合题目是这样的：给你n个数字，他们构成了一个permutation，起初他们都各自在一个集合中然后以下给出m个操作，M a b表示将编号为a和b的数字合并集合，如果已经在一个集合里面了，等于没做Q a b询问a和b在同一个集合里面吗？\n我们先来思考暴力做法一共就是两个操作对吧，一个是合并两个集合，一个是查询两个数字是否在同一个集合。如果我们给每个数字标上一个标号，标号表示他是哪个集合的。初始状态，我们规定，第i个数字，标号为i表示他的是第i个集合的如何合并两个数字？很简单，把标号改一下就可以了如何查询两个，很简单，查询一下他们的标号是否一样就可以了看似这两步的时间复杂度不是很大但其实有问题就是在合并两个集合的时候比如我已经有了一个集合了，然后要让一个数并入到这个集合中去，把这个数的标号记成他们的标号就可以了可是实际的操作的时候，我们并不知道这个标准，你怎么知道a和b那个是单独的一个数字，那个是一个集合甚至两个都在一个集合中，然后要求你合并呢？就算真的做到了也会变成n方的复杂度所以，这里我们就使用并查集存储的逻辑其实和上面差不多，不过是结合树的结构的，同时要运用路劲压缩，不然复杂度也会很大下面结合代码来看\n#include&lt;bits&#x2F;stdc++.h&gt;;\nusing namespace std;\nconst int N  &#x3D; 100010;\nint p[N]; &#x2F;&#x2F;p数组，表示第i个数字的双亲节点是那个，初始化默认p[i]&#x3D;i，同时也表示他是根节点；\n&#x2F;&#x2F;这题的核心函数，find函数，用处是寻找一个节点的根节点\n&#x2F;&#x2F;这个find函数的写法是真的太妙了，\nint find(int x)&#123;\n    if(p[x]!&#x3D;x)&#123;&#x2F;&#x2F;如果当前节点的双亲节点不是他自身，表示他不是根节点，继续find，采用递归的方式\n        p[x]&#x3D;find(p[x]); &#x2F;&#x2F;同时采用路径压缩，直接将这个节点的双亲节点改为根节点，这样之后能够减少递归次数，这一步太妙了\n    &#125;\n    return p[x]; &#x2F;&#x2F;最后返回根节点\n&#125;\n\nint main()&#123;\n    int n,m;\n    cin&gt;&gt;n&gt;&gt;m;\n    for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;\n        p[i]&#x3D;i; &#x2F;&#x2F;初始化p数据\n    &#125;\n    while(m--)&#123;\n        char op;\n        cin&gt;&gt;op;\n        int a,b;\n        cin&gt;&gt;a&gt;&gt;b;\n        if(op&#x3D;&#x3D;&#39;M&#39;)&#123;\n            p[find(a)]&#x3D;find(b); &#x2F;&#x2F;如果让合并的话，就让a的根节点连到b的根节点上去\n        &#125;\n        else&#123;\n            if(find(a)&#x3D;&#x3D;find(b))&#123; &#x2F;&#x2F;如果根节点一样，那么说明在一个集合中\n                cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl;\n            &#125;\n            else&#123;\n                cout&lt;&lt;&quot;No&quot;&lt;&lt;endl;\n            &#125;\n        &#125;\n    &#125;\n    return 0;\n&#125;\n总结一下这题的话，并查集的思想其实和前面想的建立一个标志数组一样，只不过单纯的用各个数字来表示在一个集合内有他的缺陷。采用树的结构的话，就没有这种缺陷同时这里要进行路径优化，不然也会超时\nThat’s allBye!~\n","slug":"ACM学习笔记day12","date":"2022-11-24T14:50:04.000Z","categories_index":"ACM","tags_index":"ACM,打卡,算法,数据结构,并查集,Trie树","author_index":"Ausert"},{"id":"cf4a03b1403b8a8d56d4650e2b121d28","title":"ACM学习笔记day11(Trie树)","content":"Hello guys！今天学习的内容是Trie树，应该也是叫字典树题目链接acwing\n\n直接上代码吧理解不难\n#include&lt;iostream&gt;\n#include&lt;string&gt;\nusing namespace std;\nconst int N &#x3D;100010;\nint son[N][26],idx,n,cnt[N]; &#x2F;&#x2F;son[i][j]表示第i个节点的第j个孩子节点，idx表示目前的最大节点，cnt[i]表示到第i个节点构成的string的个数\n&#x2F;&#x2F;Trie树插入一个string\nvoid insert(string s)&#123;\n    int p&#x3D;0; &#x2F;&#x2F;p表示当前节点\n    for(int i&#x3D;0;i&lt;s.size();i++)&#123;\n        int t&#x3D;s[i]-&#39;a&#39;; &#x2F;&#x2F;t用来表示是哪个字母\n        if(son[p][t]&#x3D;&#x3D;0)&#123;  &#x2F;&#x2F;如果没有这个孩子节点，也就是没有这个字母的孩子节点\n            son[p][t]&#x3D;++idx; &#x2F;&#x2F;那就新建一个节点\n        &#125;\n        p&#x3D;son[p][t]; &#x2F;&#x2F;让p指向目前的那个节点，也就是最新的那个节点\n    &#125;\n    cnt[p]++; &#x2F;&#x2F;上面创建完了之后，让cnt计数自加一个，表示这里有一个string\n&#125;\n&#x2F;&#x2F;查找一个string\nint query(string s)&#123; &#x2F;&#x2F;思路和创建类似\n    int p&#x3D;0; &#x2F;&#x2F;p表示当前节点\n    for(int i&#x3D;0;i&lt;s.size();i++)&#123;\n        int t&#x3D;s[i]-&#39;a&#39;; &#x2F;&#x2F;t表示是哪个字母\n        if(son[p][t]&#x3D;&#x3D;0)&#123;\n            return 0; &#x2F;&#x2F;如果不存在这个孩子节点的话直接返回零就可以了 \n        &#125;\n        p&#x3D;son[p][t];&#x2F;&#x2F; 让p前往当前的节点\n    &#125;\n    return cnt[p]; &#x2F;&#x2F;返回cnt的值，表示有几个这个字符串\n&#125;\n\nint main()&#123;\n    cin&gt;&gt;n;\n    while(n--)&#123;\n        char op;\n        cin&gt;&gt;op;\n        if(op&#x3D;&#x3D;&#39;I&#39;)&#123;\n            string s;\n            cin&gt;&gt;s;\n            insert(s);\n        &#125;\n        else&#123;\n            string s;\n            cin&gt;&gt;s;\n            cout&lt;&lt;query(s)&lt;&lt;endl;\n        &#125;\n    &#125;\n    \n    return 0;\n&#125;\n总之Trie树的话，理解起来还是不难的关于代码的实现，理解起来有点费劲不过也还好That’s allbye~\n","slug":"ACM学习笔记day11","date":"2022-11-20T13:36:27.000Z","categories_index":"ACM","tags_index":"ACM,打卡,学习,算法,数据结构","author_index":"Ausert"},{"id":"f3213b374a759ee017011c4487f29020","title":"ACM学习笔记day10(KMP)","content":"今天的学习内容是！KMP！呃呃呃，理解了大概两天的样子，现在终于是差不多有点理解了。\n\n\n\nKMP题目链接acwingKMP算法用于两个字符串匹配的时候提供一个线性时间复杂度的做法。其中一个关键的东西，就是next数组next数组定义：next[i]的值，表示主串匹配到第i位的时候，第i-1个字符以前的后缀和模板串前缀长度最长的部分的最后一个字符的位置，他记录的位置是模板串里的位置。比如： next[5]&#x3D;3，表示主串匹配到第5位的时候，最长的和主串的后缀相同的模板串的前缀的最后的一个字符的位置是3。介绍为next数组的含义下面为KMP的思想(next数组的求法我们放到最后)：我们用i从头遍历主串，然后用另外一个指针j去遍历模板串这里我们初始化i&#x3D;0，j&#x3D;-1(为什么让j为-1，这里是为了和next数组里面存的数据相对应)我们记主串为S，模板串为P去比较S[i]&#x3D;&#x3D;P[j+1]吗？ &#x2F;&#x2F;我们这里为什么要P[j+1]而不是P[j]呢？因为我们默认j是已经匹配好的最后一个字符，是为了配合next的定义\n\n\n\n\n\n\n\n\n\n如果相等，那最好，直接j++就可以了\n\n\n\n\n\n\n\n\n\n如果不相等，我们得让j回退吧，但是如果j从头开始就是暴力做法了，会很多重复的浪费的步骤，这里我们就要用到next数组了我们直接让j&#x3D;next[j],让j回退到最大长度的已经匹配好的地方，然后再进行P[j+1]&#x3D;&#x3D;S[i]的比较这里我们使用一个while循环一下\nSee see code\n&#x2F;&#x2F;KMP算法\n &#x2F;&#x2F;m为主串长度\n    for (int i &#x3D; 0, j &#x3D; -1; i &lt; m; i++) &#123;\n        &#x2F;&#x2F;循环判断 s[i] !&#x3D; p[j + 1]是否？，如果不相等就就让j回溯到ne[j]。直至相等为止\n        while (j !&#x3D; -1 &amp;&amp; s[i] !&#x3D; p[j + 1]) &#123;\n            j &#x3D; ne[j];\n        &#125;\n        &#x2F;&#x2F;如果相等，让j自加\n        if (s[i] &#x3D;&#x3D; p[j + 1]) &#123;\n            j++;\n        &#125;\n        &#x2F;&#x2F;这里，如果j&#x3D;&#x3D;n-1，说明j已经指向了模板串的最后一位了，而根据我们之前的定义，j是已经匹配好的串的最后一位，\n        &#x2F;&#x2F;那么j&#x3D;&#x3D;n-1就说明，已经匹配好了。\n        &#x2F;&#x2F;输出i-n+1就是匹配的串的第一个字符的位置了\n        if (j &#x3D;&#x3D; n - 1) &#123;\n            cout &lt;&lt; i - n + 1 &lt;&lt; &#39; &#39;;\n            j &#x3D; ne[j];&#x2F;&#x2F;这里，可能会有多个模板串重叠的情况，所以要让j回退一次，\n        &#125;\n    &#125;\n\n然后接下来，就是求解next数组的部分，这部分其实是KMP算法里面最难的部分了就是这东西一直不理解(哭)我们在匹配的时候，发现第i个位置匹配的位置不对了，这里我们可以看到前面的其实是有一部分模板串的前缀和主串的后缀是匹配的，我们想办法把那里的位置给存下来，然后让j直接等于他就可以了，这既是next数组那么怎么求next数组呢？因为我们是要在已经匹配好的地方去找next应该在哪里而此时因为上下已经匹配了所以我们只要对模板串操作就可以了反正两部分都是一样的嘛我们怎么求这个next数组呢?其实思路和求主串和模板串匹配是一样的我们结合代码来看\n&#x2F;&#x2F;构造next数组\n &#x2F;&#x2F;n为模板串长度\n    &#x2F;&#x2F;老规矩，遍历一边模板串，这里求next数组其实就是让模板串和模板串进行一个字符匹配\n    &#x2F;&#x2F;我们初始化next数组全部都是-1，表示最长相同部分的最后一个位置为-1，不存在\n    for (int i &#x3D; 1, j &#x3D; -1; i &lt; n; i++) &#123;\n        &#x2F;&#x2F;这里i指的P当做主串，j指向的P当做模板串。\n        &#x2F;&#x2F;这里其实有点状态转移的思想，当我们遍历到i的时候，如果p[i]!&#x3D;p[j+1]则让j回溯\n        &#x2F;&#x2F;再进行比较\n        while (j !&#x3D; -1 &amp;&amp; p[i] !&#x3D; p[j + 1]) &#123;\n            j &#x3D; ne[j];\n        &#125;\n        &#x2F;&#x2F;如果相等了，就让j++，j往后一个位置\n        if (p[i] &#x3D;&#x3D; p[j + 1]) &#123;\n            j++;\n        &#125;\n        ne[i] &#x3D; j; &#x2F;&#x2F;每次都记录一下当前的j的位置，\n        &#x2F;&#x2F;不难发现，如果运行到了这一步，说明第i个位置这里，j已经是相同后缀的最后一位了\n        &#x2F;&#x2F;这里是是p[j+1]在和他们比较，所以j++后直接存入ne中去，\n        &#x2F;&#x2F;如果不相等的话，仍然存之前那个值\n    &#125;\n\n下面为完整代码\n#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nconstexpr auto INF &#x3D; 2100000000;\nconstexpr long long INF64 &#x3D; 1e18;\nconst int N &#x3D; 1000010;\ntypedef pair&lt;int, int&gt; PII;\n\nint n, m;\nstring s, p;\nint ne[N] &#x3D; &#123; -1 &#125;;\n\nint main()\n&#123;\n    cin &gt;&gt; n &gt;&gt; p &gt;&gt; m &gt;&gt; s;\n    &#x2F;&#x2F;构造next数组\n    for (int i &#x3D; 1, j &#x3D; -1; i &lt; n; i++) &#123;\n        while (j !&#x3D; -1 &amp;&amp; p[i] !&#x3D; p[j + 1]) &#123;\n            j &#x3D; ne[j];\n        &#125;\n        if (p[i] &#x3D;&#x3D; p[j + 1]) &#123;\n            j++;\n        &#125;\n        ne[i] &#x3D; j;\n    &#125;\n\n\n    &#x2F;&#x2F;KMP算法\n    for (int i &#x3D; 0, j &#x3D; -1; i &lt; m; i++) &#123;\n        while (j !&#x3D; -1 &amp;&amp; s[i] !&#x3D; p[j + 1]) &#123;\n            j &#x3D; ne[j];\n        &#125;\n        if (s[i] &#x3D;&#x3D; p[j + 1]) &#123;\n            j++;\n        &#125;\n        if (j &#x3D;&#x3D; n - 1) &#123;\n            cout &lt;&lt; i - n + 1 &lt;&lt; &#39; &#39;;\n            j &#x3D; ne[j];\n        &#125;\n    &#125;\n    cout &lt;&lt; endl;\n    return 0;\n&#125;\n总的来说KMP算法感觉还是挺难理解的搞了两天的时间。害OKThat’s allBye~\n","slug":"ACM学习笔记day10","date":"2022-11-19T14:38:53.000Z","categories_index":"ACM","tags_index":"ACM,打卡,学习,算法,数据结构,KMP","author_index":"Ausert"},{"id":"958adf9461e6c3975304da3314c38d67","title":"ACM学习笔记day9(滑动窗口，双端队列)","content":"今天学习的时间比较短，哦，确实也挺短的不过当时比较困，理解起来也很慢，所以今天的内容只有一个是滑动窗口和双端队列！\n\n\n滑动窗口什么是滑动窗口！就是单调队列的一道经典例题链接这里因为要用到了单调队列。我acwing上打卡用的是数组模拟双端队列的。而目前上面的题解是使用STL里面的双端队列的都差不多，感觉用STL里面的逻辑上会比较清楚OK，下面开始解释这道题窗口在不断滑动，然后我们要求窗口里面的最大最小值。这里我们用到了单调队列，每次操作过后，使得队列的头部始终是最小值。这样他要求输出的东西，知道输出头部的数值就可以了。求最大值同理。具体思路是什么呢我们使用一个deque ans;里面存放的是数字的index而不是他的值——这样是为了方便检查front元素是否已经超出窗口外了如果存放的是值的话，会增加时间复杂度也不容易判断是否超出窗口外了我们用i指针从头部遍历存放的数组。我们每次把第i个数据的index存入ans中去当ans非空且如果front元素比i-k+1要小，就弹出front元素。为什么呢？因为我们用deque去模拟这个窗口，但因为我们是一个一个数据弹进去的当窗口移动的时候，可能前面有个最小值，一直都是接下来几个数字的最小值，再往后移动的时候，这个数出窗口了，那窗口内的最小值肯定就不是他了，所以必须把他弹出。此外，当ans非空的时候，检查back是否大于等于a[i]的值，如果大或者等于就循环弹出，直到比a[i]小为止这是为了不断维护deque的单调性，确保front元素一直都是窗口内的最小值这些操作之后，如果i&gt;&#x3D;k-1的话就输出front元素。这样采用deque的方式，用单调队列的算法解决了这个问题。求最大值的话，同理，只要把while弹出的地方，条件改成小于等于就可以了其他同理下面为代码：\n#include &lt;iostream&gt;\n#include&lt;stack&gt;\n#include&lt;queue&gt;\n#include&lt;algorithm&gt;\n#include&lt;string&gt;\n#include&lt;iomanip&gt;\n#include&lt;deque&gt;\nusing namespace std;\n#include&lt;math.h&gt;\nconst int N &#x3D; 1000010;\ntypedef pair&lt;int, int&gt; PII;\ntypedef long long ll;\n\nint n, k;\nint a[N];\n\nint main() &#123;\n    cin &gt;&gt; n &gt;&gt; k;\n    for (int i &#x3D; 0; i &lt; n; i++) &#123;\n        cin &gt;&gt; a[i];\n    &#125;\n    deque&lt;int&gt; ans;\n    &#x2F;&#x2F;求最小值\n    for (int i &#x3D; 0; i &lt; n; i++) &#123;\n        &#x2F;&#x2F;如果ans里面的front元素已经出窗口了，就直接弹出\n        if (!ans.empty()&amp;&amp;ans.front()&lt;i-k+1) &#123;\n            ans.pop_front();\n        &#125;\n        &#x2F;&#x2F;如果back元素&gt;&#x3D;a[i]，就循环弹出直到条件不满足位置\n        while (!ans.empty() &amp;&amp; a[ans.back()] &gt;&#x3D; a[i]) &#123;\n            ans.pop_back();\n        &#125;\n        &#x2F;&#x2F;最后再把i存放及你去\n        ans.push_back(i);\n        &#x2F;&#x2F;输出front元素\n        if (i &gt;&#x3D; k-1) &#123;\n            cout &lt;&lt; a[ans.front()] &lt;&lt; &#39; &#39;;\n        &#125;\n    &#125;\n    ans.clear(); &#x2F;&#x2F;记得清空一下deque\n    cout&lt;&lt;endl;\n    &#x2F;&#x2F;求最大值，同理\n    for (int i &#x3D; 0; i &lt; n; i++) &#123;\n        if (!ans.empty()&amp;&amp;ans.front()&lt;i-k+1) &#123;\n            ans.pop_front();\n        &#125;\n        while (!ans.empty() &amp;&amp; a[ans.back()] &lt;&#x3D; a[i]) &#123;\n            ans.pop_back();\n        &#125;\n        ans.push_back(i);\n        if (i &gt;&#x3D; k-1) &#123;\n            cout &lt;&lt; a[ans.front()] &lt;&lt; &#39; &#39;;\n        &#125;\n    &#125;\n    return 0;\n&#125;\nOK!That’s allbye~~~~~~\n","slug":"ACM学习笔记day9","date":"2022-11-17T13:07:42.000Z","categories_index":"ACM","tags_index":"ACM,打卡,学习,算法,数据结构","author_index":"Ausert"},{"id":"0bde88ed9132d2dd0ee34fc3f801dfcc","title":"ACM学习笔记day8(模拟栈，表达式求值，模拟队列，单调栈)","content":"wdnmd,受不了了，一拳把地球打爆。今天的内容原本应该是11月13号的因为当晚是有个讲座要听，没空写博客想着明天写，结果昨天忙的要死，今天还是忙的要死今天晚上终于稍微有点空了，赶紧把博客给补了，顺便也隔了几天复习一下东西。今天主要学的是 模拟栈，表达式求值，模拟队列和单调栈。\n\n\n模拟栈\n顾名思义用数组的方式去模拟栈这个数据结构当然你也可以直接用STL里面的stack类个人觉得还是用stack类舒服点（可能是还没到时候吧。angway，稍微说一下模拟的方式老规矩，有一个idx指针，用来标志栈顶元素。注意这里idx指向的意思和模拟链表不太一样。然后随便写几个函数，用来表示pop和push，top就可以了。这个不难。\n表达式求值\n这个东西，我写过数据结构实验直接略过。\n模拟队列\n模拟的方式和模拟栈差不多，用到了两个指针hh 和tt，hh初始化为0，tt初始化为-1每push一个数据，tt++；每pop一个数据，就hh–；front函数就直接访问第一个数据也就是hh指向的数据pop的时候别忘了，检查一下hh是不是&gt;&#x3D;tt的就可以了，不然弹出了个寂寞acwing题目连接这里我附上源码好了。这是我的写法\n#include &lt;iostream&gt;\n#include&lt;stack&gt;\n#include&lt;queue&gt;\n#include&lt;algorithm&gt;\n#include&lt;string&gt;\n#include&lt;iomanip&gt;\nusing namespace std;\n#include&lt;math.h&gt;\nconst int N &#x3D; 100010;\nint myQueue[N], hh, tt &#x3D; -1;\n\nvoid push(int x) &#123;\n\tmyQueue[++tt] &#x3D; x;\n&#125;\n\nvoid pop() &#123;\n\thh++;\n&#125;\n\nint front() &#123;\n\treturn myQueue[hh];\n&#125;\nbool empty() &#123;\n\treturn hh &gt; tt;\n&#125;\nint main() &#123;\n\tint m;\n\tcin &gt;&gt; m;\n\twhile (m--) &#123;\n\t\tstring op;\n\t\tcin &gt;&gt; op;\n\t\tif (op &#x3D;&#x3D; &quot;push&quot;) &#123;\n\t\t\tint x;\n\t\t\tcin &gt;&gt; x;\n\t\t\tpush(x);\n\t\t&#125;\n\t\telse if (op &#x3D;&#x3D; &quot;pop&quot;) &#123;\n\t\t\tpop();\n\t\t&#125;\n\t\telse if (op &#x3D;&#x3D; &quot;query&quot;) &#123;\n\t\t\tcout &lt;&lt; front() &lt;&lt; endl;\n\t\t&#125;\n\t\telse if (op &#x3D;&#x3D; &quot;empty&quot;) &#123;\n\t\t\tif (empty()) &#123;\n\t\t\t\tcout &lt;&lt; &quot;YES&quot; &lt;&lt; endl;\n\t\t\t&#125;\n\t\t\telse &#123;\n\t\t\t\tcout &lt;&lt; &quot;NO&quot; &lt;&lt; endl;\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n\treturn 0;\n&#125;\n\n单调栈\n单调栈说实话我感觉不像是一个数据结构不如说这是一种算法思想题目来源：acwing链接什么是单调栈捏就是这个栈里面的元素，从栈低到栈顶的元素是升序排列的e.g-—————————-| 1 2 3 4 5 6 7  8 9 10-—————————-这就是就是单调栈然后我们来看这道题目给你一个长度为n的整数序列输出每个数左边的第一个比他小的数让我们思考一下暴力做法i从头遍历到尾然后j从i遍历到头，找到第一个比第i个小的，就break结束毫无疑问，暴力做法的时间复杂度很高。数据量一大就会TLE了那我们来思考一下，这个算法究竟哪里时间复杂度高了我们发现对于第i个数，第i-1个数如果比第i-2个数小的话，那其实我们在找i-1个数前面比他小的数，这个第i-2个数已经比i-1来的大了，所以在后面要选到i-2也不可能，要选也要选i-1综上，我们采用一个单调栈对于第一个数据，前面都不可能有满足条件的，自然输出-1然后把他存入stack中，然后对于第二个，和栈顶元素比较，如果栈顶元素比较大或者相等的，直接弹出直到栈顶元素比它小了，才停止然后输出栈顶元素如此往复的进行这样，栈中形成的数据关系，其实是单调递增的。这也就是为什么成为单调栈的原因\n#include &lt;iostream&gt;\n#include&lt;stack&gt;\n#include&lt;queue&gt;\n#include&lt;algorithm&gt;\n#include&lt;string&gt;\n#include&lt;iomanip&gt;\nusing namespace std;\n#include&lt;math.h&gt;\nconst int N &#x3D; 100010;\ntypedef pair&lt;int, int&gt; PII;\ntypedef long long ll;\n\n\n\nint main() &#123;\n\tint n;\n\tcin &gt;&gt; n;\n\tvector&lt;int&gt; a(n);\n\tstack&lt;int&gt; work;\n\tfor (int i &#x3D; 0; i &lt; n; i++) &#123;\n\t\tcin &gt;&gt; a[i];\n\t&#125;\n\twork.push(a[0]);\n\tcout &lt;&lt; -1 &lt;&lt; &#39; &#39;;\n\tfor (int i &#x3D; 1; i &lt; n; i++) &#123;\n\t\twhile (!work.empty() &amp;&amp; work.top() &gt;&#x3D; a[i]) &#123;\n\t\t\twork.pop();\n\t\t&#125;\n\t\tif (work.empty()) &#123;\n\t\t\tcout &lt;&lt; -1 &lt;&lt; &#39; &#39;;\n\t\t\twork.push(a[i]);\n\t\t&#125;\n\t\telse &#123;\n\t\t\tcout &lt;&lt; work.top() &lt;&lt; &#39; &#39;;\n\t\t\twork.push(a[i]);\n\t\t&#125;\n\t&#125;\n\treturn 0;\n&#125;\nthat’s allbye~\n","slug":"ACM学习笔记day8","date":"2022-11-15T13:52:59.000Z","categories_index":"ACM","tags_index":"ACM,打卡,学习,算法,数据结构","author_index":"Ausert"},{"id":"6626baeb85b77ff2abeecddea4b9b43b","title":"ACM学习笔记day7(区间合并，静态单链表，静态双向链表)","content":"emm今天搞了点区间合并和静态链表。感觉静态链表的写法还是比较繁琐的。逻辑上感觉有点绕可能是我写习惯动态链表的原因吧（\n\n\n\n区间合并题目来源Acwing链接题目不难，贪心就能做。当时不讲，直接做出来了。不多赘述。\n#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nconstexpr auto INF &#x3D; 2100000000;\nconstexpr auto INF64 &#x3D; 1e18;\nconst int N &#x3D; 100010;\ntypedef pair&lt;int, int&gt; PII;\n\nbool cmp(PII a, PII b) &#123;\n    return a.second &lt; b.second;\n&#125;\n\nint main()\n&#123;\n    int n;\n    cin &gt;&gt; n;\n    vector&lt;PII&gt; a(n);\n    for (int i &#x3D; 0; i &lt; n; i++) &#123;\n        PII temp;\n        cin &gt;&gt; temp.first &gt;&gt; temp.second;\n        a[i] &#x3D; temp;\n    &#125;\n    sort(a.begin(), a.end(), cmp);\n    int l, cnt &#x3D; 1;\n    l &#x3D; a[n - 1].first;\n    for (int i &#x3D; n - 2; i &gt;&#x3D; 0; i--) &#123;\n        if (l &lt;&#x3D; a[i].second) &#123;\n            l &#x3D; min(a[i].first,l);\n        &#125;\n        else &#123;\n            cnt++;\n            l &#x3D; a[i].first;\n        &#125;\n    &#125;\n    cout &lt;&lt; cnt &lt;&lt; endl;\n    return 0;\n&#125;\n\n静态链表这里的话我就把单链表和双链表的内容合并在一起好了。在实际的算法比赛中，我们一般采用的链表都是静态链表也就是依托数组作为存储结构的链表。对于一个数组，我们使用一个idx指向一个新的空位置。就比如说，一个数组index为0 1 2 3 的地方都已经有数据了，此时idx为4,表示如果你要再插入一个链表的话，就放在idx的地方。所以，逻辑上是链表，但其实存储方式是线性的。这也就是为什么叫他静态链表，或者是用数组去模拟链表。单链表中，通常使用一个head初始化为-1，来表示头结点而双向链表中，不会使用head，而是left和right，来表示链表的两头初始化的时候，我们让left是第零个，right是第一个，然后idx自然就是2了。再进行操作。下为acwing单链表练习题\n#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nconstexpr auto INF &#x3D; 2100000000;\nconstexpr auto INF64 &#x3D; 1e18;\nconst int N &#x3D; 100010;\ntypedef pair&lt;int, int&gt; PII;\nint elem[N],ne[N]&#x3D;&#123;-1&#125;, idx &#x3D; 0;\nint head &#x3D; -1;\n\nvoid headAdd(int x) &#123;\n    elem[idx] &#x3D; x;\n    ne[idx] &#x3D; head;\n    head &#x3D; idx;\n    idx++;\n&#125;\n\nvoid Add(int k, int x) &#123;\n    elem[idx] &#x3D; x;\n    ne[idx] &#x3D; ne[k];\n    ne[k] &#x3D; idx;\n    idx++;\n&#125;\n\nvoid del(int k) &#123;\n    ne[k] &#x3D; ne[ne[k]];\n&#125;\n\n\nint main()\n&#123;\n    int m;\n    cin &gt;&gt; m;\n    head &#x3D; -1;\n    while (m--) &#123;\n        char a;\n        cin &gt;&gt; a;\n        if (a &#x3D;&#x3D; &#39;H&#39;) &#123;\n            int x;\n            cin &gt;&gt; x;\n            headAdd(x);\n        &#125;\n        else if (a &#x3D;&#x3D; &#39;D&#39;) &#123;\n            int k;\n            cin &gt;&gt; k;\n            if(k&#x3D;&#x3D;0)&#123;\n                head&#x3D;ne[head];\n            &#125;\n            else del(k-1);\n        &#125;\n        else &#123;\n            int k, x;\n            cin &gt;&gt; k &gt;&gt; x;\n            Add(k-1, x);\n        &#125;\n    &#125;\n    for (int i &#x3D; head; i !&#x3D; -1; i &#x3D; ne[i]) &#123;\n        cout &lt;&lt; elem[i] &lt;&lt; &#39; &#39;;\n    &#125;\n    cout &lt;&lt; endl;\n    return 0;\n&#125;\n这里要注意一个地方捏。对于第k个插入的节点，下标他是从1，开始的而我们存储数据是从零开始的，所以有关的地方要注意k-1.\n下为acwing双向链表练习题#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nconstexpr auto INF &#x3D; 2100000000;\nconstexpr long long INF64 &#x3D; 1e18;\nconst int N &#x3D; 100010;\ntypedef pair&lt;int, int&gt; PII;\nint elem[N],l[N],r[N], idx &#x3D; 0;\n\nvoid Add(int k, int x) &#123;\n    elem[idx] &#x3D; x;\n    r[idx] &#x3D; r[k];\n    l[idx] &#x3D; k;\n    l[r[k]] &#x3D; idx;\n    r[k] &#x3D; idx;\n    idx++;\n&#125;\n\nvoid del(int k) &#123;\n    r[l[k]] &#x3D; r[k];\n    l[r[k]] &#x3D; l[k];\n&#125;\n\n\nint main()\n&#123;\n    int m;\n    cin &gt;&gt; m;\n    r[0] &#x3D; 1;\n    l[1] &#x3D; 0;\n    idx &#x3D; 2;\n    while (m--) &#123;\n        string a;\n        int k,x;\n        cin &gt;&gt; a;\n        if (a[0] &#x3D;&#x3D; &#39;L&#39;) &#123;\n            cin &gt;&gt; x;\n            Add(0, x);\n        &#125;\n        else if (a[0] &#x3D;&#x3D; &#39;R&#39;) &#123;\n            cin &gt;&gt; x;\n            Add(l[1], x);\n        &#125;\n        else if (a[0] &#x3D;&#x3D; &#39;D&#39;) &#123;\n            cin &gt;&gt; k;\n            del(k+1);\n        &#125;\n        else if (a &#x3D;&#x3D; &quot;IL&quot;) &#123;\n            cin &gt;&gt; k &gt;&gt; x;\n            Add(l[k+1], x);\n        &#125;\n        else &#123;\n            cin &gt;&gt; k &gt;&gt; x;\n            Add(k+1, x);\n        &#125;\n    &#125;\n    for (int i &#x3D; r[0];i!&#x3D;1; i &#x3D; r[i]) &#123;\n        cout &lt;&lt; elem[i] &lt;&lt; &#39; &#39;;\n    &#125;\n    cout &lt;&lt; endl;\n    return 0;\n&#125;同样需要注意的是这里因为我们初始化的时候，index0 和1已经被用掉了idx&#x3D;2,与他的第k个插入，多了个1,所以进行有关操作的时候需要注意是k+1。这两节的话，感觉比较重要的就是这个知识点了。That’s allbye~\n","slug":"ACM学习笔记day7","date":"2022-11-12T15:20:17.000Z","categories_index":"ACM","tags_index":"ACM,打卡,学习,算法,数据结构","author_index":"Ausert"},{"id":"1e7a8acd61656fdbe512e6f88b5aff86","title":"ACM学习笔记day6(离散化)","content":"其实这一节，应该是day5里面的，因为呃呃呃我看到这一节acwing里面的视频长度比较长，所以我就分割出来作为单独的一个blog来写了。算法的思想比较重要。\n\n\n离散化\n题目acwing区间和说实话，离散化的概念不难理解但是实际运用起来，发现诶，用不来了\n首先，什么是离散化？离散化一般用于数据范围很大，但是里面有效数据却分布的十分零散的情况，我们把这些及其离散的数据存放到密集的另外一个数组里面去这个过程就被称为离散化。什么意思呢？就像上面那题，数据范围在±10^9之间，但是他加c只执行顶多10^5次，可以看出，有很多的地方其实是根本没有数据的，也就是零这题中我们就是将里面离散的数据存放到了a之中。a数据里面的有效数据是十分密集的。下面来具体理解一下这题的思路。n和m分别是进行n次加值的操作，m是m次询问，问你区间和。那么我们就设立一个alloperator数组，用来存放所有的被操作的index其次使用a数组存放他加减的值然后用add和query数组来暂时存放他的加值操作和询问操作。下面结合代码讲解：\n#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nconstexpr auto INF &#x3D; 2100000000;\nconstexpr auto INF64 &#x3D; 1e18;\nconst int N &#x3D; 300010;\ntypedef pair&lt;int, int&gt; PII;\nint n, m;\nint a[N],s[N];  &#x2F;&#x2F;a数组为存放数据的数字，s数组为a数组的前缀和数组\nvector&lt;int&gt; alloperator;  &#x2F;&#x2F;存放所有操作数的数组\nvector&lt;PII&gt; add, query;  &#x2F;&#x2F;暂时存放他add的操作，和询问的操作\n\nint find(int x) &#123;  &#x2F;&#x2F;查找函数，给你一个x，去查找离散化之后的对应的index应该是多少，return r+1，是为了让index从1开始，方便求前缀和和O（1）的输出\n    int l &#x3D; 0, r &#x3D; alloperator.size() - 1; &#x2F;&#x2F;二分法查找。也可以用lowerbound函数\n    while (l &lt; r) &#123;\n        int  mid &#x3D; (l + r) &#x2F; 2;\n        if (alloperator[mid] &gt;&#x3D; x) &#123;\n            r &#x3D; mid;\n        &#125;\n        else &#123;\n            l &#x3D; mid + 1;\n        &#125;\n    &#125;\n    return r + 1;\n&#125;\n\nint main()\n&#123;\n    cin &gt;&gt; n &gt;&gt; m;\n    for (int i &#x3D; 0; i &lt; n; i++) &#123;\n        int x, c;\n        cin &gt;&gt; x &gt;&gt; c;\n        add.push_back(&#123; x,c &#125;); &#x2F;&#x2F;暂存add操作\n        alloperator.push_back(x);  &#x2F;&#x2F;这里的alloperator是存放所有的操作数，最后去重就可以了\n     &#125;\n    for (int i &#x3D; 0; i &lt; m; i++) &#123;\n        int l, r;\n        cin &gt;&gt; l &gt;&gt; r;\n        query.push_back(&#123; l,r &#125;); &#x2F;&#x2F;暂存query操作\n        alloperator.push_back(l);\n        alloperator.push_back(r);\n    &#125;\n    sort(alloperator.begin(), alloperator.end());\n    alloperator.erase(unique(alloperator.begin(), alloperator.end()), alloperator.end());\n    &#x2F;&#x2F;关键的一步，给alloperator排序，然后去重，去重可以把不必要的数据去掉，反正都有\n    &#x2F;&#x2F;然后排序是为了方便二分查找。\n    &#x2F;&#x2F;其实这样操作过后呢，我们已经准备好了映射了，接下来就是每一个操作数对应一个a之中的映射值就可以了。\n    &#x2F;&#x2F;为什么查询操作里面的l和r也要放进来呢？因为会用到啊，没有加值就是零呗\n    for (int i &#x3D; 0; i &lt;n ; i++) &#123;\n        int x &#x3D; find(add[i].first); &#x2F;&#x2F;这里我们把add数组里面也就是我们之前存的操作，进行一遍\n        a[x] +&#x3D; add[i].second; &#x2F;&#x2F;将该加的值加上去，此时其实是已经有映射了，我们采用的映射就是一一映射过去的。\n    &#125;\n    for (int i &#x3D; 1; i &lt;&#x3D; alloperator.size(); i++) &#123;\n        s[i] &#x3D; s[i - 1] + a[i]; &#x2F;&#x2F;求a的前缀和，当然，这里要注意，i的次数得跟着alloperator的次数来\n                                &#x2F;&#x2F;因为我们d询问里面操作的位数都放在了这里面了已经\n        \n    &#125;\n    for (int i &#x3D; 0; i &lt; m; i++) &#123;\n        int l &#x3D; find(query[i].first), r &#x3D; find(query[i].second); &#x2F;&#x2F;进行询问操作，和前缀和里面一样，不过赘述\n        cout &lt;&lt; s[r] - s[l - 1] &lt;&lt; endl;\n    &#125;\n    return 0;\n&#125;\n\n总的来说，这东西感觉还是比较难理解的。emm搞了好几个小时呃呃呃那么That’s allbye~\n","slug":"ACM学习笔记day6","date":"2022-11-10T13:57:48.000Z","categories_index":"ACM","tags_index":"ACM,打卡,学习,算法,数据结构,离散化","author_index":"Ausert"},{"id":"ceed889808223c52789eb0c0c60367bf","title":"ACM学习笔记day5(双指针，位运算)","content":"今天学习了一下双指针算法，感觉还是挺难的。就是一个由单调性可以推出应该用双指针这个有点不是很能理解。QAQ还有个位运算。\n\n\n求最长无重复数字的子串问题\n采用双指针的算法的话，我们让i从头到尾遍历数组，对于每一个i，j表示当前子串的左边界。如果在j到i这块子串有相同的数字，则让j++，直到没有相同数字为止。然后去更新ans，取ans和i-j+1中大的那个而应该怎么去检查里面有没有相同数字呢。这里我们用到一个check数组，check数组的长度就是所给数据的最大值+1,然后对于里面的每一个数字，比如a[i]，让check[a[i]]++表示数字大小为a[i]的数字有一个，在i和j移动的时候，i每次加1就代表有一个数字加入，此时让check[a[i]]++而每次j移动的时候，相当于从尾部删掉一个数字，也就是check[a[j]]–这里循环移动j的时候，循环条件就是check[a[i]]&gt;1我们是默认i和j中间的序列是没有重复数字的，i前进了1，如果有重复数字了，就让j移动，直到没有。下面看看代码:#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nconstexpr auto INF &#x3D; 2100000000;\nconstexpr auto INF64 &#x3D; 1e18;\nconst int N &#x3D; 100010;\n\nint check[N]; &#x2F;&#x2F;检测数组，下面表示数字的值，数组的值表示里面有几个这个数字\n\nint main()\n&#123;\n    int n;\n    cin &gt;&gt; n;\n    vector&lt;int&gt; a(n);\n    for (int i &#x3D; 0; i &lt; n; i++) cin &gt;&gt; a[i];\n    int ans &#x3D; 0;\n    for (int i &#x3D; 0, j &#x3D; 0; i &lt; n; i++) &#123;\n        check[a[i]]++;\n        while (check[a[i]] &gt; 1) &#123; &#x2F;&#x2F;如果有相同数字，是因为新加进来的第i个数字的原因，所以我们循环j直到没有重复数字位置\n            check[a[j]]--;\n            j++;\n        &#125;\n        ans &#x3D; max(ans, i-j + 1);\n    &#125;\n    cout &lt;&lt; ans &lt;&lt; endl;\n    return 0;\n&#125;位运算\n有个常用的函数，lowbit函数，对于lowbit(x)返回，x在二进制下最后一个1。e.g: 1010 如果lowbit(10)&#x3D;（10）2.他返回的是最后一个1以及他后面的一串零，结果是十进制形式的.所以我们也可以通过这个，来给一个数字消掉最后一个1，例如\nint x;\ncin&gt;&gt;x;\nx-&#x3D;lowbit(x); &#x2F;&#x2F;这样就可以让x的最后一个1转化为零。二进制下\n同时也有一个常用操作\nint x;\ncin&gt;&gt;x;\nx&gt;&gt;k&amp;1; &#x2F;&#x2F;表示，对于数字x在二进制下，返回第k位的值是多少。 挺好理解的\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"ACM学习笔记day5","date":"2022-11-10T09:25:34.000Z","categories_index":"ACM","tags_index":"ACM,打卡,学习,算法,数据结构,双指针","author_index":"Ausert"},{"id":"4143f6a2444e4122fe8da477a7a2d540","title":"ACM学习笔记day4(前缀和和差分)","content":"今天学了前缀和和差分，及其数组。前缀和不多说了，比较好理解，主要还是差分，这个比较抽象\n\n\n\n前缀和主要注意一下，前缀和数组从1开始，0的位置就归零，这样就不用地方越界问题了。\n\n差分至于差分。emmmm差分数组不需要构建，~~~当然也可以构建~~~二位差分同理\nint a[N],B[N]; &#x2F;&#x2F;a为原来的数组，b为差分数组\n&#x2F;&#x2F;执行差分的插入操作，即在l和r中间的数字都加上c。\nvoid insert(int l,int r,int c)&#123;\n    b[l]+&#x3D;c;\n    b[r+1]-&#x3D;c;\n&#125;\n\nvoid solve()&#123;\n    for(int i&#x3D;0;i&lt;n;i++)&#123;\n        int t;\n        cin&gt;&gt;t;\n        insert(i,i,t);&#x2F;&#x2F;这里相当于不用数组去存原来那个数组，原来那个数组就相当于对i和i中间的数字加上a[i]，也就是差分的思想。\n    &#125;\n    然后就是for循环，进行m次询问，同样操作。\n&#125;\n\n然后二维差分的话，要注意一个点，就是你在差分数组的第ij个值的地方加了个c，那么在行&gt;&#x3D;i,列&gt;&#x3D;j的后面所有数据都加上了个c，这里的话要考虑一个容斥原理。下面为insert代码：\n&#x2F;&#x2F;b数组为差分数组，c为要加的值\nvoid insert(int x1, int y1, int x2, int y2, int c) &#123;\n    b[x1][y1] +&#x3D; c;\n    b[x1][y2 + 1] -&#x3D; c;\n    b[x2 + 1][y1] -&#x3D; c;\n    b[x2 + 1][y2 + 1] +&#x3D; c;\n&#125;\n\n记住，差分数组不需要自己想着构建awaThat’s allbye~\n","slug":"ACM学习笔记day4","date":"2022-11-09T14:02:19.000Z","categories_index":"ACM","tags_index":"ACM,打卡,学习,算法,数据结构","author_index":"Ausert"},{"id":"ffffeb1fbf512f768ee4d72750569670","title":"ACM学习笔记day3(高精度四则运算)","content":"学习ACM有关东西的第四天。今天用晚上时间稍微学了点高精度加减乘除的运算。感觉是在模拟人类的运算过程，除了乘法(这不废话)So,Here we go!\n\n\n\n\n总述有必要说明一下，对于高精度的四则运算，加法和减法是两个高精度的数字，而乘法和除法是一个高精度乘或者除以一个数同时因为数字的位数很大，在C嘎嘎中没有数据类型可以存放，实际上我们是用string接受，然后转存入vector数组当中去的要注意，存放的过程，应该为逆序的过程，就是倒着存放，为了方便之后我们加减法和乘法的运算这个过程不难，不多赘述***高精度加法对于高精度加法，我们采用的方式，模拟正常的加法运算，同时采用一个t来记录进位。For example：\n\n\n\n\n\n\n\n\n\n123+22123&amp;ensp;22——————\n我们对于这里，个位3和2加，等于5存入res数组，这里进位t&#x3D;0如果有进位，这里的t&#x3D;1,else t&#x3D;0就这样一次进行下去因为vector是倒序存储的，而运算是低位开始的，所以函数中我们就从零开始最后要附加一个，如果t不为零的话，要再pushback进res数组里面下面为一个模板\n#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nconstexpr auto INF &#x3D; 2100000000;\nconstexpr auto INF64 &#x3D; 1e18;\n\nvector&lt;int&gt; add(vector&lt;int&gt;&amp; a, vector&lt;int&gt;&amp; b) &#123;\n    vector&lt;int&gt; res;\n    int t &#x3D; 0;\n    for (int i &#x3D; 0;i&lt;a.size()||i&lt;b.size(); i++) &#123;\n        if (i &lt; a.size()) t +&#x3D; a[i];\n        if (i &lt; b.size()) t +&#x3D; b[i];\n        res.push_back(t % 10);\n        t &#x2F;&#x3D; 10;\n    &#125;\n    if (t) res.push_back(1); &#x2F;&#x2F;注意这里，最后的时候t可能是1的，这个时候要记得把这个进位的1加入到res数组里面\n    return res;\n&#125;\n\nint main()\n&#123;\n    string a,b;\n    cin &gt;&gt; a&gt;&gt;b;\n    vector&lt;int&gt; c,d;\n    for (int i &#x3D; a.size()-1; i &gt;&#x3D; 0; i--) &#123;\n        c.push_back(a[i] - &#39;0&#39;);\n    &#125;\n    for (int i &#x3D; b.size() - 1; i &gt;&#x3D; 0; i--) &#123;\n        d.push_back(b[i] - &#39;0&#39;);\n    &#125;\n    vector&lt;int&gt; e;\n    e &#x3D; add(c, d);\n    for (int i &#x3D; e.size() - 1; i &gt;&#x3D; 0; i--) &#123;\n        cout &lt;&lt; e[i];\n    &#125;\n    cout &lt;&lt; endl;\n    return 0;\n&#125;\n\n\n高精度减法高精度减法的思路和正常做减法其实差不多。当然，这里要注意，为了方便处理，我们采用的是大的那个数去减小的那个数，如果输入的是小的减大的，那就交换一下，然后结果加个负号就可以了减法中，我们对于其中的一个数字，同样使用一个t作为借位。那么其实，对于每一位，他的运算就是a[i]-t-b[i].当然，如果此时的i超过了b数组的边界，那么就减掉t就可以了这里我们处理一下，加个条件即可。下面为一个可用模板：\n#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nconstexpr auto INF &#x3D; 2100000000;\nconstexpr auto INF64 &#x3D; 1e18;\n\n&#x2F;&#x2F;用来比较两个数字的大小的函数，如果a大于b则返回true\nbool cmp(vector&lt;int&gt; a, vector&lt;int&gt; b) &#123;\n    if (a.size() !&#x3D; b.size()) return a.size() &gt; b.size();\n    else &#123;\n        for (int i &#x3D; a.size()-1; i &gt;&#x3D; 0; i--) &#123;\n            if (a[i] - b[i] &gt; 0) &#123;\n                return true;\n            &#125;\n            else if (a[i] - b[i] &lt; 0) &#123;\n                return false;\n            &#125;\n        &#125;\n    &#125;\n    return true;\n&#125;\n\nvector&lt;int&gt; _minus(vector&lt;int&gt;&amp; a, vector&lt;int&gt;&amp; b) &#123;\n    int t &#x3D; 0;\n    vector&lt;int&gt; c;\n    for (int i &#x3D; 0; i &lt; a.size(); i++) &#123;\n        t &#x3D; a[i] - t; &#x2F;&#x2F;先运算a[i]-t,因为a肯定是大的那个.\n        if (i &lt; b.size()) t -&#x3D; b[i];\n        c.push_back((t+10)%10); &#x2F;&#x2F;注意，这里因为从上一位可能借了一个10过来，所以要加个10再取余\n        if (t &lt; 0) &#123;\n            t &#x3D; 1;\n        &#125;\n        else &#123;\n            t &#x3D; 0;\n        &#125;\n    &#125;\n    &#x2F;&#x2F;也是很关键的一步，记得要把高位的前导零给去除。\n    while (c.size() &gt; 1 &amp;&amp; c.back() &#x3D;&#x3D; 0) &#123; \n        c.pop_back();\n    &#125;\n    return c;\n&#125;\n\nint main()\n&#123;\n    string a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n    vector&lt;int&gt; c, d;\n    for (int i &#x3D; a.size()-1; i &gt;&#x3D; 0; i--) &#123;\n        c.push_back(a[i] - &#39;0&#39;);\n    &#125;\n    for (int i &#x3D; b.size()-1; i &gt;&#x3D; 0; i--) &#123;\n        d.push_back(b[i] - &#39;0&#39;);\n    &#125;\n    vector&lt;int&gt; e;\n    if (cmp(c, d)) &#123;\n        e &#x3D; _minus(c, d);\n        for (int i &#x3D; e.size() - 1; i &gt;&#x3D; 0; i--) &#123;\n            cout &lt;&lt; e[i];\n        &#125;\n        cout &lt;&lt; endl;\n    &#125;\n    else &#123;\n        e &#x3D; _minus(d,c);\n        cout &lt;&lt; &#39;-&#39;;\n        for (int i &#x3D; e.size() - 1; i &gt;&#x3D; 0; i--) &#123;\n            cout &lt;&lt; e[i];\n        &#125;\n        cout &lt;&lt; endl;\n    &#125;\n    return 0;\n&#125;\n\n高精度乘法高精度乘法的算法其实和我们一般的计算方法不太一样我们一般计算乘法是一位一位乘的，但在这里是把那个较小的数字b看成一个整体然后把a[i]*b的值去赋给t同时让t&#x2F;10作为进位，让t%10作为push进res数组里面的数字最后不要忘了清理掉前导零下面为一个可用模板:\n#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nconstexpr auto INF &#x3D; 2100000000;\nconstexpr auto INF64 &#x3D; 1e18;\n\n\n\nvector&lt;int&gt; multiple(vector&lt;int&gt;&amp; a, int b) &#123;\n    long long  t &#x3D; 0;\n    vector&lt;int&gt; ans;\n    for (int i &#x3D; 0; i &lt; a.size(); i++) &#123;\n        t +&#x3D; a[i] * b;\n        ans.push_back(t % 10);\n        t &#x3D; t &#x2F; 10; &#x2F;&#x2F;这里t要自除一个10，因为如果有进位的话，是被用掉了\n    &#125;\n    &#x2F;&#x2F;这里要不断的将t多出来的进位push进ans里面，说实话\n    &#x2F;&#x2F;这里我也不是很懂，因为采用的算法不是一般的算法，暂时先当模板记住好了\n    while (t) &#123;\n     ans.push_back(t % 10);\n     t &#x2F;&#x3D; 10;\n    &#125;\n    &#x2F;&#x2F;清楚前导零\n    while (ans.size() &gt; 1&amp;&amp;ans.back()&#x3D;&#x3D;0) &#123;\n        ans.pop_back();\n    &#125;\n    return ans;\n&#125;\n\nint main()\n&#123;\n    string a;\n    cin &gt;&gt; a;\n    int b;\n    cin &gt;&gt; b;\n    vector&lt;int&gt; c;\n    for (int i &#x3D; a.size()-1; i &gt;&#x3D; 0; i--) &#123;\n        c.push_back(a[i] - &#39;0&#39;);\n    &#125;\n    vector&lt;int&gt; e;\n    e &#x3D; multiple(c, b);\n    for (int i &#x3D; e.size() - 1; i &gt;&#x3D; 0; i--) &#123;\n        cout &lt;&lt; e[i];\n    &#125;\n    cout &lt;&lt; endl;\n    return 0;\n&#125;\n\n高精度除法高精度除法的算法，和上面的有点不同，不同的地方在于，他是从高位开始看的。当然实际运算和我们正常算是差不多的只不过我们要用一个r来代表余数下面为一个可用的模板：\n#include&lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nconstexpr auto INF &#x3D; 2100000000;\nconstexpr auto INF64 &#x3D; 1e18;\n\nvector&lt;int&gt; divide(vector&lt;int&gt;&amp; a, int b,int&amp; r) &#123;\n    vector&lt;int&gt; res;\n    for (int i &#x3D; a.size() - 1; i &gt;&#x3D; 0; i--) &#123;\n        r &#x3D; r * 10 + a[i]; &#x2F;&#x2F;每次的余数都是上一个余数乘10，加上当前的数字这个是还没用于计算的\n        res.push_back(r &#x2F; b); &#x2F;&#x2F;相当于实际进行一个除法运算\n        r %&#x3D; b;&#x2F;&#x2F;除完了，剩下的就是余数，让r自等\n    &#125;\n    reverse(res.begin(), res.end()); &#x2F;&#x2F;反转数组，因为我们这里是从高位开始运算的，而输出的以为是倒序的数组\n    while (res.size() &gt; 1 &amp;&amp; res.back() &#x3D;&#x3D; 0) &#123;\n        res.pop_back();&#x2F;&#x2F;清除掉前导零\n    &#125;\n    return res;\n&#125;\nint main()\n&#123;\n    string a;\n    cin &gt;&gt; a;\n    int b;\n    cin &gt;&gt; b;\n    vector&lt;int&gt; c;\n    for (int i &#x3D; a.size()-1; i &gt;&#x3D; 0; i--) &#123;\n        c.push_back(a[i] - &#39;0&#39;);\n    &#125;\n    vector&lt;int&gt; e;\n    int r &#x3D; 0;\n    e &#x3D; divide(c, b, r);\n    for (int i &#x3D; e.size() - 1; i &gt;&#x3D; 0; i--) &#123;\n        cout &lt;&lt; e[i];\n    &#125;\n    cout &lt;&lt; endl &lt;&lt; r &lt;&lt; endl;\n    return 0;\n&#125;\nemmmThat’s all!Bye~\n","slug":"ACM学习笔记day3","date":"2022-11-08T14:01:59.000Z","categories_index":"ACM","tags_index":"ACM,打卡,学习,算法,数据结构,蒟蒻","author_index":"Ausert"},{"id":"a8b932df9b747ba9300a0aa8e66533aa","title":"ACM学习笔记day2","content":"hello guys！这里是Ausert！这里是我学习ACM相关知识打卡的地方，当然，不会是一些学习笔记啥的(后面被打脸了QAQ)只是一些小的注意点，或者心得啥的不要问我为什么没有day1的打卡博客。因为那个时候网站还没有搭建起来&#x3D; &#x3D;So here we go零碎的点1.使用二分模板的时候，当修改left值的时候，注意要让mid&#x3D;left+right+1&gt;&gt;1，不然会出现mid&#x3D;left然后死循环的出现2.快排和归并的本质就是分治，快排是先处理数据再分治，归并是先分治再处理数据3.浮点数二分的时候，当要求保留4位小数的时候，循环条件应该为r-l&gt;1e-6,当保留六位的时候，应该为r-l&gt;1e-8就是位数要比保留的数字多2，比如4-&gt;6,6-&gt;84.计算机一秒大约可以运算10^8次。一些话语目前学到了acwing上的浮点数二分那边，感觉进度好慢TAT但是学校的那边的破事也是真的多（恼）又不能不管学校的破事（气）学到现在，感觉快排，归并排序根本原理就在于分治而对于二分，说实话y总的课给了我对二分新的理解二分不一定只能用在有序的数组上，无序的数组有时候也可以使用二分虽然他没说具体例子orz就先这样吧，距离我写这篇博客的时候估计距离我学完这部分已经过去一段时间了Bye~\n","slug":"ACM学习笔记day2","date":"2022-11-07T02:41:28.000Z","categories_index":"ACM","tags_index":"ACM,学习,算法,数据结构,打卡（大概）","author_index":"Ausert"},{"id":"b1c29db086b8b87ca11beaf5db14c0e6","title":"网站开发日志1(网站的准备过程，搭建，部署，发布)","content":"introHello guys!&lt;br&gt;Welcome to this piece of blog &lt;br&gt;Until now, I have basically deploy my blog site on the github successfully, with files stored in the github’s repos &lt;br&gt;If you are browering my blog, and you also want to create a your own blog site, and deploy on the github.&lt;br&gt;I’d like to recommend this up’s video, it can solve most of problems about how to do this.&lt;br&gt;Here is the URL on bilibili &lt;br&gt;-&gt;我是连接awa&lt;br&gt;\n\n\n\nMy conclusionFor all the operations, I want to conclude them to three steps.&lt;br&gt;\n\n\n\n\n\n\n\n\n\nDownload!&lt;br&gt;Deploy!&lt;br&gt;Upload!&lt;br&gt;\nWhat is download?!&lt;br&gt;That is download all the needed tools or environment.&lt;br&gt;Such as:&lt;br&gt;Node++ (this is used for open md files or yml files, if you have vscode or clion, both can be ok)&lt;br&gt;Git (This is the necessary tool to deploy your site to github, really really important!!)&lt;br&gt;SSL (OK, this is not downloaded. But it is also needed, so I distribute SSL to this part.)&lt;br&gt;What is deploy?!&lt;br&gt;This is easy!&lt;br&gt;Just create you github account and create a github repo whose name is yourname.github.io &lt;br&gt;Attention! “yourname” there is must equal to your github account name, or may lead to failure.&lt;br&gt;After that, you should new a fold to create your blog site.&lt;br&gt;And right click you mousr, select the ‘git bash here’ and hexo init…..&lt;br&gt;emmmm, a series of command &lt;br&gt;What is Upload!?&lt;br&gt;emmmm just upload your all file to your github repo.&lt;br&gt;open the git bash and hexo clean ,hexo g, hexo d.&lt;br&gt;After the three commands, just waiting….&lt;br&gt;wait for the upload completed.&lt;br&gt;Then you succeed!&lt;br&gt;Some notesI’d like to say this conclusion is just a brief comclusion, if you are a fully layman, you can not understand me.&lt;br&gt;It is common, because my conclusion is really brief.&lt;br&gt;OH! About how to create superlink between navigation and one specific blog, I dont know.I am learning too.&lt;br&gt;If I have learned how do this. Maybe I will talk some in develop blog 2.&lt;br&gt;FutureIn the future,maybe I’d like to make a resume and achievements site to record my exprience in my life.&lt;br&gt;Since now, I don’t know how to create superlink to markdown files correctly.&lt;br&gt;So, maybe I will choose HTML.&lt;br&gt;Overrall, that’s the future plan.&lt;br&gt;That’s all.&lt;br&gt;Bye~\n","slug":"网站开发日志1","date":"2022-11-07T02:25:32.000Z","categories_index":"个人博客开发","tags_index":"学习,网站部署,网站开发,网站维护","author_index":"Ausert"}]