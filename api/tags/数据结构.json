{"name":"数据结构","slug":"数据结构","count":23,"postlist":[{"title":"ACM学习笔记day11(Trie树)","uid":"cf4a03b1403b8a8d56d4650e2b121d28","slug":"ACM学习笔记day11","date":"2022-11-20T13:36:27.000Z","updated":"2023-04-08T10:50:36.627Z","comments":true,"path":"api/articles/ACM学习笔记day11.json","keywords":null,"cover":"/img/codeforces.jpg","text":"Hello guys！今天学习的内容是Trie树，应该也是叫字典树题目链接acwing 直接上代码吧理解不难 #include&lt;iostream&gt; #include&lt;string&gt; using namespace std; const int N &#x3...","link":"","photos":[],"count_time":{"symbolsCount":"1.6k","symbolsTime":"1 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":39,"path":"api/tags/ACM.json"},{"name":"学习","slug":"学习","count":42,"path":"api/tags/学习.json"},{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"数据结构","slug":"数据结构","count":23,"path":"api/tags/数据结构.json"},{"name":"算法","slug":"算法","count":20,"path":"api/tags/算法.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"喜欢前沿科技，想要见证人类科学的飞跃","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}},{"title":"ACM学习笔记day10(KMP)","uid":"f3213b374a759ee017011c4487f29020","slug":"ACM学习笔记day10","date":"2022-11-19T14:38:53.000Z","updated":"2023-04-08T10:49:28.522Z","comments":true,"path":"api/articles/ACM学习笔记day10.json","keywords":null,"cover":"/img/codeforces.jpg","text":"今天的学习内容是！KMP！呃呃呃，理解了大概两天的样子，现在终于是差不多有点理解了。 KMP题目链接acwingKMP算法用于两个字符串匹配的时候提供一个线性时间复杂度的做法。其中一个关键的东西，就是next数组next数组定义：next[i]的值，表示主串匹配到第i位的时候，第...","link":"","photos":[],"count_time":{"symbolsCount":"3.7k","symbolsTime":"3 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":39,"path":"api/tags/ACM.json"},{"name":"学习","slug":"学习","count":42,"path":"api/tags/学习.json"},{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"数据结构","slug":"数据结构","count":23,"path":"api/tags/数据结构.json"},{"name":"算法","slug":"算法","count":20,"path":"api/tags/算法.json"},{"name":"KMP","slug":"KMP","count":1,"path":"api/tags/KMP.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"喜欢前沿科技，想要见证人类科学的飞跃","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}},{"title":"ACM学习笔记day13(求连通块中点的数量)","uid":"d45c53bbd2d951bda24bba0bdde79964","slug":"ACM学习笔记day13","date":"2022-11-25T11:42:49.000Z","updated":"2023-04-08T10:50:52.060Z","comments":true,"path":"api/articles/ACM学习笔记day13.json","keywords":null,"cover":"/img/codeforces.jpg","text":"今天的内容是求连通块中点的数量 求连通块中点的数量这题和并查集那道模板题差不多就是多了一个要求让你统计集合中的数量而已 这里我们用到一个cnt数组，同时我们规定，只有根节点的cnt数据是有意义的这样我们就避免了要给多个同连通块的集合重新赋值的麻烦 #include&lt;bits...","link":"","photos":[],"count_time":{"symbolsCount":"1.5k","symbolsTime":"1 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":39,"path":"api/tags/ACM.json"},{"name":"学习","slug":"学习","count":42,"path":"api/tags/学习.json"},{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"数据结构","slug":"数据结构","count":23,"path":"api/tags/数据结构.json"},{"name":"算法","slug":"算法","count":20,"path":"api/tags/算法.json"},{"name":"并查集","slug":"并查集","count":2,"path":"api/tags/并查集.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"喜欢前沿科技，想要见证人类科学的飞跃","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}},{"title":"ACM学习笔记day12(最大异或对，并查集)","uid":"5299e436ed1961fa0cb39dca432850d2","slug":"ACM学习笔记day12","date":"2022-11-24T14:50:04.000Z","updated":"2023-04-08T10:50:43.082Z","comments":true,"path":"api/articles/ACM学习笔记day12.json","keywords":null,"cover":"/img/codeforces.jpg","text":"今天的内容是Trie树的应用和并查集的学习。这个最大异或对的话，就是Trie树的应用，然后有别于之前那个Trie树存的数据不一样，之前那个存的是char，现在这个存的是0和1。然后并查集的话感觉就是构建了一个森林，然后每一颗树代表了一定的信息。 最大异或对最大异或对。题目是啥呢，...","link":"","photos":[],"count_time":{"symbolsCount":"3.9k","symbolsTime":"4 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":39,"path":"api/tags/ACM.json"},{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"数据结构","slug":"数据结构","count":23,"path":"api/tags/数据结构.json"},{"name":"算法","slug":"算法","count":20,"path":"api/tags/算法.json"},{"name":"并查集","slug":"并查集","count":2,"path":"api/tags/并查集.json"},{"name":"Trie树","slug":"Trie树","count":1,"path":"api/tags/Trie树.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"喜欢前沿科技，想要见证人类科学的飞跃","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}},{"title":"ACM学习笔记day14（带权并查集，堆排序，模拟堆）","uid":"baee1de5b96302e6e975d5e11b914928","slug":"ACM学习笔记day14","date":"2022-12-01T14:13:12.000Z","updated":"2023-04-08T10:50:59.395Z","comments":true,"path":"api/articles/ACM学习笔记day14.json","keywords":null,"cover":"/img/codeforces.jpg","text":"Hello guys!感觉好久没有写笔记了，上次写笔记好像是呃呃呃，五天前了吧。要忙学校的好多事情，呜呜呜，我有罪orz好了，不bb了，今天的学习内容是带权并查集（食物链）,堆模拟,堆排序 带权并查集带权并查集就是原来并查集的升级版，plus版本。相较于原来的普通的并查集，带权并...","link":"","photos":[],"count_time":{"symbolsCount":"8.2k","symbolsTime":"7 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":39,"path":"api/tags/ACM.json"},{"name":"学习","slug":"学习","count":42,"path":"api/tags/学习.json"},{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"数据结构","slug":"数据结构","count":23,"path":"api/tags/数据结构.json"},{"name":"算法","slug":"算法","count":20,"path":"api/tags/算法.json"},{"name":"带权并查集","slug":"带权并查集","count":1,"path":"api/tags/带权并查集.json"},{"name":"堆","slug":"堆","count":1,"path":"api/tags/堆.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"喜欢前沿科技，想要见证人类科学的飞跃","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}},{"title":"ACM学习笔记day15(哈希，字符串的哈希)","uid":"5358138299a8ff147d7f561517fe5a1d","slug":"ACM学习笔记day15","date":"2022-12-02T12:15:59.000Z","updated":"2023-04-08T10:51:06.595Z","comments":true,"path":"api/articles/ACM学习笔记day15.json","keywords":null,"cover":"/img/codeforces.jpg","text":"hello guys！今天的学习内容是哈希表，也就是散列表对应acwing上的模拟散列表和字符串哈希 那么问题来了什么是哈希表呢？一句话来总结就是，不保序的离散化离散化其实是哈希化的一种特殊情况我们将数据范围很大的，较少的数字，映射到一个比较小的数组，这就是哈希，不过中间的那个映...","link":"","photos":[],"count_time":{"symbolsCount":"4.8k","symbolsTime":"4 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":39,"path":"api/tags/ACM.json"},{"name":"学习","slug":"学习","count":42,"path":"api/tags/学习.json"},{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"数据结构","slug":"数据结构","count":23,"path":"api/tags/数据结构.json"},{"name":"算法","slug":"算法","count":20,"path":"api/tags/算法.json"},{"name":"笔记","slug":"笔记","count":3,"path":"api/tags/笔记.json"},{"name":"哈希表","slug":"哈希表","count":1,"path":"api/tags/哈希表.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"喜欢前沿科技，想要见证人类科学的飞跃","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}},{"title":"ACM学习笔记day16(朴素dijkstra求最短路径)","uid":"569c66ff03a6fea9d4ceedb2c072fa60","slug":"ACM学习笔记day16","date":"2022-12-03T13:32:15.000Z","updated":"2023-04-08T10:51:15.100Z","comments":true,"path":"api/articles/ACM学习笔记day16.json","keywords":null,"cover":"/img/codeforces.jpg","text":"Hello，guys！今天我们学习的内容是dijkstra算法求最短路径,题目emm，第一次学这个的话，感觉还是比较抽象的，不过想了一段时间，稍微整理了一下思路，感觉也还可以应该（ 朴素Dijkstra为什么叫朴素dijkstra呢？因为目前这个dijkstra算法的时间复杂度是...","link":"","photos":[],"count_time":{"symbolsCount":"2.8k","symbolsTime":"3 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":39,"path":"api/tags/ACM.json"},{"name":"学习","slug":"学习","count":42,"path":"api/tags/学习.json"},{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"数据结构","slug":"数据结构","count":23,"path":"api/tags/数据结构.json"},{"name":"算法","slug":"算法","count":20,"path":"api/tags/算法.json"},{"name":"蒟蒻","slug":"蒟蒻","count":4,"path":"api/tags/蒟蒻.json"},{"name":"dijkstra","slug":"dijkstra","count":1,"path":"api/tags/dijkstra.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"喜欢前沿科技，想要见证人类科学的飞跃","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}},{"title":"ACM学习笔记day17(floyd算法求多源最短路)","uid":"633b5f64cd1a9eff1c65ad66ca026b45","slug":"ACM学习笔记day17","date":"2022-12-09T14:20:36.000Z","updated":"2023-04-08T10:51:22.699Z","comments":true,"path":"api/articles/ACM学习笔记day17.json","keywords":null,"cover":"/img/codeforces.jpg","text":"额，距离上次写ACM笔记好像已经过了很久了其实这是有原因(借口)的，在被模电折磨捏~好了，不多bb了今天学习的内容是Floyd算法求多源最短路。这个算法写起来东西很少，同时也比较简单，从整体上去理解的话，感觉还是不难理解的运用的思想就是DP的思想 直接上代码吧，思想是dp的思想，...","link":"","photos":[],"count_time":{"symbolsCount":"1.9k","symbolsTime":"2 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":39,"path":"api/tags/ACM.json"},{"name":"学习","slug":"学习","count":42,"path":"api/tags/学习.json"},{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"数据结构","slug":"数据结构","count":23,"path":"api/tags/数据结构.json"},{"name":"算法","slug":"算法","count":20,"path":"api/tags/算法.json"},{"name":"Floyd","slug":"Floyd","count":1,"path":"api/tags/Floyd.json"},{"name":"图论","slug":"图论","count":3,"path":"api/tags/图论.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"喜欢前沿科技，想要见证人类科学的飞跃","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}},{"title":"ACM学习笔记day18(dfs)","uid":"43196df8e77fd8e5155e9b94ef5532f4","slug":"ACM学习笔记day18","date":"2022-12-10T15:15:28.000Z","updated":"2023-04-08T10:51:30.587Z","comments":true,"path":"api/articles/ACM学习笔记day18.json","keywords":null,"cover":"/img/codeforces.jpg","text":"今天的内容是dfs，对应的acwing题目 dfs深搜，不难理解，而且之前在白书上我也学过啥意思也不多赘述这里主要讲解一下这题的思路 给你个n，让你求所有可能的排列组合，也就是求permutation因为n很小，所有dfs能过我们从第0个数字开始接下来选第1个数字，有n中可能对应...","link":"","photos":[],"count_time":{"symbolsCount":"1.3k","symbolsTime":"1 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":39,"path":"api/tags/ACM.json"},{"name":"学习","slug":"学习","count":42,"path":"api/tags/学习.json"},{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"数据结构","slug":"数据结构","count":23,"path":"api/tags/数据结构.json"},{"name":"算法","slug":"算法","count":20,"path":"api/tags/算法.json"},{"name":"dfs","slug":"dfs","count":4,"path":"api/tags/dfs.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"喜欢前沿科技，想要见证人类科学的飞跃","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}},{"title":"ACM学习笔记day19(N皇后问题-2种dfs解法)","uid":"983fdf7c1cf56eb82d4bc470facb21cc","slug":"ACM学习笔记day19","date":"2022-12-11T14:48:21.000Z","updated":"2023-04-08T10:51:37.675Z","comments":true,"path":"api/articles/ACM学习笔记day19.json","keywords":null,"cover":"/img/codeforces.jpg","text":"今天的内容是N皇后问题，有两种dfs方法，但是自己在写的时候还是碰到了不少问题的。 第一种dfs方法这种dfs方法，是基于我们已经知道了，每一行每一列每一主对角线和副对角线上只能有一个皇后。思想和数字的全排列差不多。我们dfs第零行到第n-1行，然后枚举第零列到第n-1列，如果有...","link":"","photos":[],"count_time":{"symbolsCount":"3.4k","symbolsTime":"3 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":39,"path":"api/tags/ACM.json"},{"name":"学习","slug":"学习","count":42,"path":"api/tags/学习.json"},{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"数据结构","slug":"数据结构","count":23,"path":"api/tags/数据结构.json"},{"name":"算法","slug":"算法","count":20,"path":"api/tags/算法.json"},{"name":"dfs","slug":"dfs","count":4,"path":"api/tags/dfs.json"},{"name":"N皇后","slug":"N皇后","count":1,"path":"api/tags/N皇后.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"喜欢前沿科技，想要见证人类科学的飞跃","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}},{"title":"ACM学习笔记day20(走迷宫bfs)","uid":"955da31dc34cc48d9fa1d8587dc420ff","slug":"ACM学习笔记day20","date":"2022-12-16T13:50:22.000Z","updated":"2023-04-08T10:51:47.380Z","comments":true,"path":"api/articles/ACM学习笔记day20.json","keywords":null,"cover":"/img/codeforces.jpg","text":"hello guys！今天的内容是走迷宫。额，好像叕好久没有更新博客了。呃呃呃。好像确实有点摆（是非常吧。好的，我们来看问题。 走迷宫问题，这个不多说，啥意思很容易理解题源：acwing;所用的思想就是bfs算法。bfs算法其实是有一个固定的算法模板的。 while(queue非...","link":"","photos":[],"count_time":{"symbolsCount":"1.9k","symbolsTime":"2 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":39,"path":"api/tags/ACM.json"},{"name":"学习","slug":"学习","count":42,"path":"api/tags/学习.json"},{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"数据结构","slug":"数据结构","count":23,"path":"api/tags/数据结构.json"},{"name":"算法","slug":"算法","count":20,"path":"api/tags/算法.json"},{"name":"bfs","slug":"bfs","count":3,"path":"api/tags/bfs.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"喜欢前沿科技，想要见证人类科学的飞跃","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}},{"title":"ACM学习笔记day2","uid":"a8b932df9b747ba9300a0aa8e66533aa","slug":"ACM学习笔记day2","date":"2022-11-07T02:41:28.000Z","updated":"2023-04-08T10:50:24.513Z","comments":true,"path":"api/articles/ACM学习笔记day2.json","keywords":null,"cover":"/img/codeforces.jpg","text":"hello guys！这里是Ausert！这里是我学习ACM相关知识打卡的地方，当然，不会是一些学习笔记啥的(后面被打脸了QAQ)只是一些小的注意点，或者心得啥的不要问我为什么没有day1的打卡博客。因为那个时候网站还没有搭建起来&#x3D; &#x3D;So here we g...","link":"","photos":[],"count_time":{"symbolsCount":579,"symbolsTime":"1 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":39,"path":"api/tags/ACM.json"},{"name":"学习","slug":"学习","count":42,"path":"api/tags/学习.json"},{"name":"数据结构","slug":"数据结构","count":23,"path":"api/tags/数据结构.json"},{"name":"算法","slug":"算法","count":20,"path":"api/tags/算法.json"},{"name":"打卡（大概）","slug":"打卡（大概）","count":1,"path":"api/tags/打卡（大概）.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"喜欢前沿科技，想要见证人类科学的飞跃","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}},{"title":"ACM学习笔记day3(高精度四则运算)","uid":"ffffeb1fbf512f768ee4d72750569670","slug":"ACM学习笔记day3","date":"2022-11-08T14:01:59.000Z","updated":"2023-04-08T10:49:48.429Z","comments":true,"path":"api/articles/ACM学习笔记day3.json","keywords":null,"cover":"/img/codeforces.jpg","text":"学习ACM有关东西的第四天。今天用晚上时间稍微学了点高精度加减乘除的运算。感觉是在模拟人类的运算过程，除了乘法(这不废话)So,Here we go! 总述有必要说明一下，对于高精度的四则运算，加法和减法是两个高精度的数字，而乘法和除法是一个高精度乘或者除以一个数同时因为数字的位...","link":"","photos":[],"count_time":{"symbolsCount":"6.6k","symbolsTime":"6 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":39,"path":"api/tags/ACM.json"},{"name":"学习","slug":"学习","count":42,"path":"api/tags/学习.json"},{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"数据结构","slug":"数据结构","count":23,"path":"api/tags/数据结构.json"},{"name":"算法","slug":"算法","count":20,"path":"api/tags/算法.json"},{"name":"蒟蒻","slug":"蒟蒻","count":4,"path":"api/tags/蒟蒻.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"喜欢前沿科技，想要见证人类科学的飞跃","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}},{"title":"ACM学习笔记day39(树状数组)","uid":"7710f88b0aefcb65b0ee353b8ff291a3","slug":"ACM学习笔记day39","date":"2023-07-18T14:56:43.000Z","updated":"2023-08-27T09:15:47.333Z","comments":true,"path":"api/articles/ACM学习笔记day39.json","keywords":null,"cover":"/img/codeforces.jpg","text":"树状数组的板子。 有几个小结论需要记住。 每个结点t[x]保存以x为根的子树中叶结点值的和 每个结点覆盖的长度为lowbit(x) t[x]结点的父结点为t[x + lowbit(x)] 树的深度为log2n+1 理解树状数组的图为: lowbit操作： int lowbit(i...","link":"","photos":[],"count_time":{"symbolsCount":543,"symbolsTime":"1 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"数据结构","slug":"数据结构","count":23,"path":"api/tags/数据结构.json"},{"name":"binary index tree","slug":"binary-index-tree","count":1,"path":"api/tags/binary-index-tree.json"},{"name":"树状数组","slug":"树状数组","count":1,"path":"api/tags/树状数组.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"喜欢前沿科技，想要见证人类科学的飞跃","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}},{"title":"ACM学习笔记day4(前缀和和差分)","uid":"4143f6a2444e4122fe8da477a7a2d540","slug":"ACM学习笔记day4","date":"2022-11-09T14:02:19.000Z","updated":"2023-04-08T10:49:05.915Z","comments":true,"path":"api/articles/ACM学习笔记day4.json","keywords":null,"cover":"/img/codeforces.jpg","text":"今天学了前缀和和差分，及其数组。前缀和不多说了，比较好理解，主要还是差分，这个比较抽象 前缀和主要注意一下，前缀和数组从1开始，0的位置就归零，这样就不用地方越界问题了。 差分至于差分。emmmm差分数组不需要构建，~~~当然也可以构建~~~二位差分同理 int a[N],B[N...","link":"","photos":[],"count_time":{"symbolsCount":875,"symbolsTime":"1 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":39,"path":"api/tags/ACM.json"},{"name":"学习","slug":"学习","count":42,"path":"api/tags/学习.json"},{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"数据结构","slug":"数据结构","count":23,"path":"api/tags/数据结构.json"},{"name":"算法","slug":"算法","count":20,"path":"api/tags/算法.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"喜欢前沿科技，想要见证人类科学的飞跃","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}},{"title":"ACM学习笔记day5(双指针，位运算)","uid":"ceed889808223c52789eb0c0c60367bf","slug":"ACM学习笔记day5","date":"2022-11-10T09:25:34.000Z","updated":"2023-04-08T10:48:56.517Z","comments":true,"path":"api/articles/ACM学习笔记day5.json","keywords":null,"cover":"/img/codeforces.jpg","text":"今天学习了一下双指针算法，感觉还是挺难的。就是一个由单调性可以推出应该用双指针这个有点不是很能理解。QAQ还有个位运算。 求最长无重复数字的子串问题 采用双指针的算法的话，我们让i从头到尾遍历数组，对于每一个i，j表示当前子串的左边界。如果在j到i这块子串有相同的数字，则让j++...","link":"","photos":[],"count_time":{"symbolsCount":"1.5k","symbolsTime":"1 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":39,"path":"api/tags/ACM.json"},{"name":"学习","slug":"学习","count":42,"path":"api/tags/学习.json"},{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"数据结构","slug":"数据结构","count":23,"path":"api/tags/数据结构.json"},{"name":"算法","slug":"算法","count":20,"path":"api/tags/算法.json"},{"name":"双指针","slug":"双指针","count":1,"path":"api/tags/双指针.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"喜欢前沿科技，想要见证人类科学的飞跃","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}},{"title":"ACM学习笔记day6(离散化)","uid":"1e7a8acd61656fdbe512e6f88b5aff86","slug":"ACM学习笔记day6","date":"2022-11-10T13:57:48.000Z","updated":"2023-04-08T10:49:10.497Z","comments":true,"path":"api/articles/ACM学习笔记day6.json","keywords":null,"cover":"/img/codeforces.jpg","text":"其实这一节，应该是day5里面的，因为呃呃呃我看到这一节acwing里面的视频长度比较长，所以我就分割出来作为单独的一个blog来写了。算法的思想比较重要。 离散化 题目acwing区间和说实话，离散化的概念不难理解但是实际运用起来，发现诶，用不来了 首先，什么是离散化？离散化一...","link":"","photos":[],"count_time":{"symbolsCount":"3k","symbolsTime":"3 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":39,"path":"api/tags/ACM.json"},{"name":"学习","slug":"学习","count":42,"path":"api/tags/学习.json"},{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"数据结构","slug":"数据结构","count":23,"path":"api/tags/数据结构.json"},{"name":"算法","slug":"算法","count":20,"path":"api/tags/算法.json"},{"name":"离散化","slug":"离散化","count":1,"path":"api/tags/离散化.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"喜欢前沿科技，想要见证人类科学的飞跃","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}},{"title":"ACM学习笔记day7(区间合并，静态单链表，静态双向链表)","uid":"6626baeb85b77ff2abeecddea4b9b43b","slug":"ACM学习笔记day7","date":"2022-11-12T15:20:17.000Z","updated":"2023-04-08T10:49:14.216Z","comments":true,"path":"api/articles/ACM学习笔记day7.json","keywords":null,"cover":"/img/codeforces.jpg","text":"emm今天搞了点区间合并和静态链表。感觉静态链表的写法还是比较繁琐的。逻辑上感觉有点绕可能是我写习惯动态链表的原因吧（ 区间合并题目来源Acwing链接题目不难，贪心就能做。当时不讲，直接做出来了。不多赘述。 #include&lt;bits&#x2F;stdc++.h&gt; ...","link":"","photos":[],"count_time":{"symbolsCount":"4.3k","symbolsTime":"4 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":39,"path":"api/tags/ACM.json"},{"name":"学习","slug":"学习","count":42,"path":"api/tags/学习.json"},{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"数据结构","slug":"数据结构","count":23,"path":"api/tags/数据结构.json"},{"name":"算法","slug":"算法","count":20,"path":"api/tags/算法.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"喜欢前沿科技，想要见证人类科学的飞跃","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}},{"title":"ACM学习笔记day9(滑动窗口，双端队列)","uid":"958adf9461e6c3975304da3314c38d67","slug":"ACM学习笔记day9","date":"2022-11-17T13:07:42.000Z","updated":"2023-04-08T10:49:25.073Z","comments":true,"path":"api/articles/ACM学习笔记day9.json","keywords":null,"cover":"/img/codeforces.jpg","text":"今天学习的时间比较短，哦，确实也挺短的不过当时比较困，理解起来也很慢，所以今天的内容只有一个是滑动窗口和双端队列！ 滑动窗口什么是滑动窗口！就是单调队列的一道经典例题链接这里因为要用到了单调队列。我acwing上打卡用的是数组模拟双端队列的。而目前上面的题解是使用STL里面的双端...","link":"","photos":[],"count_time":{"symbolsCount":"2.4k","symbolsTime":"2 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":39,"path":"api/tags/ACM.json"},{"name":"学习","slug":"学习","count":42,"path":"api/tags/学习.json"},{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"数据结构","slug":"数据结构","count":23,"path":"api/tags/数据结构.json"},{"name":"算法","slug":"算法","count":20,"path":"api/tags/算法.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"喜欢前沿科技，想要见证人类科学的飞跃","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}},{"title":"ACM学习笔记day8(模拟栈，表达式求值，模拟队列，单调栈)","uid":"0bde88ed9132d2dd0ee34fc3f801dfcc","slug":"ACM学习笔记day8","date":"2022-11-15T13:52:59.000Z","updated":"2023-04-08T10:49:21.906Z","comments":true,"path":"api/articles/ACM学习笔记day8.json","keywords":null,"cover":"/img/codeforces.jpg","text":"wdnmd,受不了了，一拳把地球打爆。今天的内容原本应该是11月13号的因为当晚是有个讲座要听，没空写博客想着明天写，结果昨天忙的要死，今天还是忙的要死今天晚上终于稍微有点空了，赶紧把博客给补了，顺便也隔了几天复习一下东西。今天主要学的是 模拟栈，表达式求值，模拟队列和单调栈。 ...","link":"","photos":[],"count_time":{"symbolsCount":"2.9k","symbolsTime":"3 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":39,"path":"api/tags/ACM.json"},{"name":"学习","slug":"学习","count":42,"path":"api/tags/学习.json"},{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"数据结构","slug":"数据结构","count":23,"path":"api/tags/数据结构.json"},{"name":"算法","slug":"算法","count":20,"path":"api/tags/算法.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"喜欢前沿科技，想要见证人类科学的飞跃","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}},{"title":"ACM学习笔记day41(懒标记线段树)","uid":"5a6c29c310d82ce99bfc421188b80faf","slug":"ACM学习笔记day41","date":"2023-08-27T07:57:57.000Z","updated":"2024-01-02T13:30:31.813Z","comments":true,"path":"api/articles/ACM学习笔记day41.json","keywords":null,"cover":"/img/codeforces.jpg","text":"带懒标记的线段树实际上的函数就多了一个，pushdown操作。以下为板子：板子题目链接板子中线段树维护的是一段区间的数组的和。懒标记表示的是该节点的子树要加上去的值，不包括他自己。 struct node&#123; int l,r; ll sum&#x3D;0; ll add&...","link":"","photos":[],"count_time":{"symbolsCount":"5.2k","symbolsTime":"5 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":39,"path":"api/tags/ACM.json"},{"name":"数据结构","slug":"数据结构","count":23,"path":"api/tags/数据结构.json"},{"name":"线段树","slug":"线段树","count":2,"path":"api/tags/线段树.json"},{"name":"板子","slug":"板子","count":2,"path":"api/tags/板子.json"},{"name":"懒标记","slug":"懒标记","count":1,"path":"api/tags/懒标记.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"喜欢前沿科技，想要见证人类科学的飞跃","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}},{"title":"题解-Codeforces-Round-837-div-2","uid":"8939638ff3772e749e6b91f98033c73a","slug":"题解-Codeforces-Round-837-div-2","date":"2022-12-12T11:57:48.000Z","updated":"2023-08-27T09:17:27.684Z","comments":true,"path":"api/articles/题解-Codeforces-Round-837-div-2.json","keywords":null,"cover":"/img/二次元の图/1.jpg","text":"蒟蒻又日常来尝试div2了，这次独立（额，算独立吗）做出来的只有A，B还是问了别人才做出来的，接下里的这个就是B的题解。下面这个做法真的十分的优雅。代码很简洁，思路也很清楚。 B-Hossam and Friends 题目链接 题目描述：一个人有n个朋友，按照1,2,3,4…，n...","link":"","photos":[],"count_time":{"symbolsCount":"2.2k","symbolsTime":"2 mins."},"categories":[{"name":"题解","slug":"题解","count":1,"path":"api/categories/题解.json"}],"tags":[{"name":"ACM","slug":"ACM","count":39,"path":"api/tags/ACM.json"},{"name":"学习","slug":"学习","count":42,"path":"api/tags/学习.json"},{"name":"数据结构","slug":"数据结构","count":23,"path":"api/tags/数据结构.json"},{"name":"算法","slug":"算法","count":20,"path":"api/tags/算法.json"},{"name":"codeforces","slug":"codeforces","count":1,"path":"api/tags/codeforces.json"},{"name":"题解","slug":"题解","count":1,"path":"api/tags/题解.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"喜欢前沿科技，想要见证人类科学的飞跃","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}},{"title":"ACM学习笔记day40(无懒标记线段树)","uid":"f730cb1c16c6cae11f6020e8c15e8535","slug":"ACM学习笔记day40","date":"2023-08-26T14:16:45.000Z","updated":"2023-08-27T09:15:54.897Z","comments":true,"path":"api/articles/ACM学习笔记day40.json","keywords":null,"cover":"/img/codeforces.jpg","text":"不带懒标记的线段树的板子。注意代码中节点属性是区间的最大值。下面为代码： struct node&#123; int l,r; int maxnum; &#125;; node tree[N*4]; void pushup(int u)&#123; tree[u].maxnum&...","link":"","photos":[],"count_time":{"symbolsCount":"3.8k","symbolsTime":"3 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":39,"path":"api/tags/ACM.json"},{"name":"数据结构","slug":"数据结构","count":23,"path":"api/tags/数据结构.json"},{"name":"线段树","slug":"线段树","count":2,"path":"api/tags/线段树.json"},{"name":"板子","slug":"板子","count":2,"path":"api/tags/板子.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"喜欢前沿科技，想要见证人类科学的飞跃","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}}]}