{"name":"学习","slug":"学习","count":43,"postlist":[{"title":"ACM学习笔记day11(Trie树)","uid":"cf4a03b1403b8a8d56d4650e2b121d28","slug":"ACM学习笔记day11","date":"2022-11-20T13:36:27.000Z","updated":"2023-04-08T10:50:36.627Z","comments":true,"path":"api/articles/ACM学习笔记day11.json","keywords":null,"cover":"/img/codeforces.jpg","text":"Hello guys！今天学习的内容是Trie树，应该也是叫字典树题目链接acwing 直接上代码吧理解不难 #include&lt;iostream&gt; #include&lt;string&gt; using namespace std; const int N &#x3...","link":"","photos":[],"count_time":{"symbolsCount":"1.6k","symbolsTime":"1 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":39,"path":"api/tags/ACM.json"},{"name":"学习","slug":"学习","count":43,"path":"api/tags/学习.json"},{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"数据结构","slug":"数据结构","count":23,"path":"api/tags/数据结构.json"},{"name":"算法","slug":"算法","count":20,"path":"api/tags/算法.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"tech otakus save the world","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}},{"title":"ACM学习笔记day10(KMP)","uid":"f3213b374a759ee017011c4487f29020","slug":"ACM学习笔记day10","date":"2022-11-19T14:38:53.000Z","updated":"2023-04-08T10:49:28.522Z","comments":true,"path":"api/articles/ACM学习笔记day10.json","keywords":null,"cover":"/img/codeforces.jpg","text":"今天的学习内容是！KMP！呃呃呃，理解了大概两天的样子，现在终于是差不多有点理解了。 KMP题目链接acwingKMP算法用于两个字符串匹配的时候提供一个线性时间复杂度的做法。其中一个关键的东西，就是next数组next数组定义：next[i]的值，表示主串匹配到第i位的时候，第...","link":"","photos":[],"count_time":{"symbolsCount":"3.7k","symbolsTime":"3 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":39,"path":"api/tags/ACM.json"},{"name":"学习","slug":"学习","count":43,"path":"api/tags/学习.json"},{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"数据结构","slug":"数据结构","count":23,"path":"api/tags/数据结构.json"},{"name":"算法","slug":"算法","count":20,"path":"api/tags/算法.json"},{"name":"KMP","slug":"KMP","count":1,"path":"api/tags/KMP.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"tech otakus save the world","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}},{"title":"ACM学习笔记day14（带权并查集，堆排序，模拟堆）","uid":"baee1de5b96302e6e975d5e11b914928","slug":"ACM学习笔记day14","date":"2022-12-01T14:13:12.000Z","updated":"2023-04-08T10:50:59.395Z","comments":true,"path":"api/articles/ACM学习笔记day14.json","keywords":null,"cover":"/img/codeforces.jpg","text":"Hello guys!感觉好久没有写笔记了，上次写笔记好像是呃呃呃，五天前了吧。要忙学校的好多事情，呜呜呜，我有罪orz好了，不bb了，今天的学习内容是带权并查集（食物链）,堆模拟,堆排序 带权并查集带权并查集就是原来并查集的升级版，plus版本。相较于原来的普通的并查集，带权并...","link":"","photos":[],"count_time":{"symbolsCount":"8.2k","symbolsTime":"7 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":39,"path":"api/tags/ACM.json"},{"name":"学习","slug":"学习","count":43,"path":"api/tags/学习.json"},{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"数据结构","slug":"数据结构","count":23,"path":"api/tags/数据结构.json"},{"name":"算法","slug":"算法","count":20,"path":"api/tags/算法.json"},{"name":"带权并查集","slug":"带权并查集","count":1,"path":"api/tags/带权并查集.json"},{"name":"堆","slug":"堆","count":1,"path":"api/tags/堆.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"tech otakus save the world","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}},{"title":"ACM学习笔记day15(哈希，字符串的哈希)","uid":"5358138299a8ff147d7f561517fe5a1d","slug":"ACM学习笔记day15","date":"2022-12-02T12:15:59.000Z","updated":"2023-04-08T10:51:06.595Z","comments":true,"path":"api/articles/ACM学习笔记day15.json","keywords":null,"cover":"/img/codeforces.jpg","text":"hello guys！今天的学习内容是哈希表，也就是散列表对应acwing上的模拟散列表和字符串哈希 那么问题来了什么是哈希表呢？一句话来总结就是，不保序的离散化离散化其实是哈希化的一种特殊情况我们将数据范围很大的，较少的数字，映射到一个比较小的数组，这就是哈希，不过中间的那个映...","link":"","photos":[],"count_time":{"symbolsCount":"4.8k","symbolsTime":"4 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":39,"path":"api/tags/ACM.json"},{"name":"学习","slug":"学习","count":43,"path":"api/tags/学习.json"},{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"数据结构","slug":"数据结构","count":23,"path":"api/tags/数据结构.json"},{"name":"算法","slug":"算法","count":20,"path":"api/tags/算法.json"},{"name":"笔记","slug":"笔记","count":3,"path":"api/tags/笔记.json"},{"name":"哈希表","slug":"哈希表","count":1,"path":"api/tags/哈希表.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"tech otakus save the world","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}},{"title":"ACM学习笔记day13(求连通块中点的数量)","uid":"d45c53bbd2d951bda24bba0bdde79964","slug":"ACM学习笔记day13","date":"2022-11-25T11:42:49.000Z","updated":"2023-04-08T10:50:52.060Z","comments":true,"path":"api/articles/ACM学习笔记day13.json","keywords":null,"cover":"/img/codeforces.jpg","text":"今天的内容是求连通块中点的数量 求连通块中点的数量这题和并查集那道模板题差不多就是多了一个要求让你统计集合中的数量而已 这里我们用到一个cnt数组，同时我们规定，只有根节点的cnt数据是有意义的这样我们就避免了要给多个同连通块的集合重新赋值的麻烦 #include&lt;bits...","link":"","photos":[],"count_time":{"symbolsCount":"1.5k","symbolsTime":"1 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":39,"path":"api/tags/ACM.json"},{"name":"学习","slug":"学习","count":43,"path":"api/tags/学习.json"},{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"数据结构","slug":"数据结构","count":23,"path":"api/tags/数据结构.json"},{"name":"算法","slug":"算法","count":20,"path":"api/tags/算法.json"},{"name":"并查集","slug":"并查集","count":2,"path":"api/tags/并查集.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"tech otakus save the world","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}},{"title":"ACM学习笔记day16(朴素dijkstra求最短路径)","uid":"569c66ff03a6fea9d4ceedb2c072fa60","slug":"ACM学习笔记day16","date":"2022-12-03T13:32:15.000Z","updated":"2023-04-08T10:51:15.100Z","comments":true,"path":"api/articles/ACM学习笔记day16.json","keywords":null,"cover":"/img/codeforces.jpg","text":"Hello，guys！今天我们学习的内容是dijkstra算法求最短路径,题目emm，第一次学这个的话，感觉还是比较抽象的，不过想了一段时间，稍微整理了一下思路，感觉也还可以应该（ 朴素Dijkstra为什么叫朴素dijkstra呢？因为目前这个dijkstra算法的时间复杂度是...","link":"","photos":[],"count_time":{"symbolsCount":"2.8k","symbolsTime":"3 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":39,"path":"api/tags/ACM.json"},{"name":"学习","slug":"学习","count":43,"path":"api/tags/学习.json"},{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"数据结构","slug":"数据结构","count":23,"path":"api/tags/数据结构.json"},{"name":"算法","slug":"算法","count":20,"path":"api/tags/算法.json"},{"name":"蒟蒻","slug":"蒟蒻","count":4,"path":"api/tags/蒟蒻.json"},{"name":"dijkstra","slug":"dijkstra","count":1,"path":"api/tags/dijkstra.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"tech otakus save the world","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}},{"title":"ACM学习笔记day17(floyd算法求多源最短路)","uid":"633b5f64cd1a9eff1c65ad66ca026b45","slug":"ACM学习笔记day17","date":"2022-12-09T14:20:36.000Z","updated":"2023-04-08T10:51:22.699Z","comments":true,"path":"api/articles/ACM学习笔记day17.json","keywords":null,"cover":"/img/codeforces.jpg","text":"额，距离上次写ACM笔记好像已经过了很久了其实这是有原因(借口)的，在被模电折磨捏~好了，不多bb了今天学习的内容是Floyd算法求多源最短路。这个算法写起来东西很少，同时也比较简单，从整体上去理解的话，感觉还是不难理解的运用的思想就是DP的思想 直接上代码吧，思想是dp的思想，...","link":"","photos":[],"count_time":{"symbolsCount":"1.9k","symbolsTime":"2 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":39,"path":"api/tags/ACM.json"},{"name":"学习","slug":"学习","count":43,"path":"api/tags/学习.json"},{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"数据结构","slug":"数据结构","count":23,"path":"api/tags/数据结构.json"},{"name":"算法","slug":"算法","count":20,"path":"api/tags/算法.json"},{"name":"Floyd","slug":"Floyd","count":1,"path":"api/tags/Floyd.json"},{"name":"图论","slug":"图论","count":3,"path":"api/tags/图论.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"tech otakus save the world","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}},{"title":"ACM学习笔记day18(dfs)","uid":"43196df8e77fd8e5155e9b94ef5532f4","slug":"ACM学习笔记day18","date":"2022-12-10T15:15:28.000Z","updated":"2023-04-08T10:51:30.587Z","comments":true,"path":"api/articles/ACM学习笔记day18.json","keywords":null,"cover":"/img/codeforces.jpg","text":"今天的内容是dfs，对应的acwing题目 dfs深搜，不难理解，而且之前在白书上我也学过啥意思也不多赘述这里主要讲解一下这题的思路 给你个n，让你求所有可能的排列组合，也就是求permutation因为n很小，所有dfs能过我们从第0个数字开始接下来选第1个数字，有n中可能对应...","link":"","photos":[],"count_time":{"symbolsCount":"1.3k","symbolsTime":"1 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":39,"path":"api/tags/ACM.json"},{"name":"学习","slug":"学习","count":43,"path":"api/tags/学习.json"},{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"数据结构","slug":"数据结构","count":23,"path":"api/tags/数据结构.json"},{"name":"算法","slug":"算法","count":20,"path":"api/tags/算法.json"},{"name":"dfs","slug":"dfs","count":4,"path":"api/tags/dfs.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"tech otakus save the world","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}},{"title":"ACM学习笔记day2","uid":"a8b932df9b747ba9300a0aa8e66533aa","slug":"ACM学习笔记day2","date":"2022-11-07T02:41:28.000Z","updated":"2023-04-08T10:50:24.513Z","comments":true,"path":"api/articles/ACM学习笔记day2.json","keywords":null,"cover":"/img/codeforces.jpg","text":"hello guys！这里是Ausert！这里是我学习ACM相关知识打卡的地方，当然，不会是一些学习笔记啥的(后面被打脸了QAQ)只是一些小的注意点，或者心得啥的不要问我为什么没有day1的打卡博客。因为那个时候网站还没有搭建起来&#x3D; &#x3D;So here we g...","link":"","photos":[],"count_time":{"symbolsCount":579,"symbolsTime":"1 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":39,"path":"api/tags/ACM.json"},{"name":"学习","slug":"学习","count":43,"path":"api/tags/学习.json"},{"name":"数据结构","slug":"数据结构","count":23,"path":"api/tags/数据结构.json"},{"name":"算法","slug":"算法","count":20,"path":"api/tags/算法.json"},{"name":"打卡（大概）","slug":"打卡（大概）","count":1,"path":"api/tags/打卡（大概）.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"tech otakus save the world","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}},{"title":"ACM学习笔记day20(走迷宫bfs)","uid":"955da31dc34cc48d9fa1d8587dc420ff","slug":"ACM学习笔记day20","date":"2022-12-16T13:50:22.000Z","updated":"2023-04-08T10:51:47.380Z","comments":true,"path":"api/articles/ACM学习笔记day20.json","keywords":null,"cover":"/img/codeforces.jpg","text":"hello guys！今天的内容是走迷宫。额，好像叕好久没有更新博客了。呃呃呃。好像确实有点摆（是非常吧。好的，我们来看问题。 走迷宫问题，这个不多说，啥意思很容易理解题源：acwing;所用的思想就是bfs算法。bfs算法其实是有一个固定的算法模板的。 while(queue非...","link":"","photos":[],"count_time":{"symbolsCount":"1.9k","symbolsTime":"2 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":39,"path":"api/tags/ACM.json"},{"name":"学习","slug":"学习","count":43,"path":"api/tags/学习.json"},{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"数据结构","slug":"数据结构","count":23,"path":"api/tags/数据结构.json"},{"name":"算法","slug":"算法","count":20,"path":"api/tags/算法.json"},{"name":"bfs","slug":"bfs","count":3,"path":"api/tags/bfs.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"tech otakus save the world","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}},{"title":"ACM学习笔记day19(N皇后问题-2种dfs解法)","uid":"983fdf7c1cf56eb82d4bc470facb21cc","slug":"ACM学习笔记day19","date":"2022-12-11T14:48:21.000Z","updated":"2023-04-08T10:51:37.675Z","comments":true,"path":"api/articles/ACM学习笔记day19.json","keywords":null,"cover":"/img/codeforces.jpg","text":"今天的内容是N皇后问题，有两种dfs方法，但是自己在写的时候还是碰到了不少问题的。 第一种dfs方法这种dfs方法，是基于我们已经知道了，每一行每一列每一主对角线和副对角线上只能有一个皇后。思想和数字的全排列差不多。我们dfs第零行到第n-1行，然后枚举第零列到第n-1列，如果有...","link":"","photos":[],"count_time":{"symbolsCount":"3.4k","symbolsTime":"3 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":39,"path":"api/tags/ACM.json"},{"name":"学习","slug":"学习","count":43,"path":"api/tags/学习.json"},{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"数据结构","slug":"数据结构","count":23,"path":"api/tags/数据结构.json"},{"name":"算法","slug":"算法","count":20,"path":"api/tags/算法.json"},{"name":"dfs","slug":"dfs","count":4,"path":"api/tags/dfs.json"},{"name":"N皇后","slug":"N皇后","count":1,"path":"api/tags/N皇后.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"tech otakus save the world","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}},{"title":"ACM学习笔记day23(欧拉函数，筛法求欧拉函数，快速幂，快速幂求逆元)","uid":"ead55ceebbb5da582503c01cc4b636b6","slug":"ACM学习笔记day23","date":"2023-01-24T13:07:47.000Z","updated":"2023-04-08T10:52:11.128Z","comments":true,"path":"api/articles/ACM学习笔记day23.json","keywords":null,"cover":"/img/codeforces.jpg","text":"今天的内容是欧拉函数和快速幂，主要是这两个。其中最后那个逆元，emm感觉好难理解QAQ 欧拉函数欧拉函数的定义： 由定义我们容易得出，对于求一个数字N的欧拉函数的值，我们按照定义来就可以了。时间复杂度是O(sqrt(N))。因为分解质因数要根号n，然后乘法乘上去也是根号n。所以时...","link":"","photos":[],"count_time":{"symbolsCount":"5.8k","symbolsTime":"5 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":39,"path":"api/tags/ACM.json"},{"name":"学习","slug":"学习","count":43,"path":"api/tags/学习.json"},{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"数论","slug":"数论","count":5,"path":"api/tags/数论.json"},{"name":"数学","slug":"数学","count":7,"path":"api/tags/数学.json"},{"name":"快速幂","slug":"快速幂","count":1,"path":"api/tags/快速幂.json"},{"name":"欧拉函数","slug":"欧拉函数","count":1,"path":"api/tags/欧拉函数.json"},{"name":"逆元","slug":"逆元","count":1,"path":"api/tags/逆元.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"tech otakus save the world","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}},{"title":"ACM学习笔记day22 (约数个数，约数之和，最大公约数)","uid":"3438dc43ca9a9de9df433abe2e751c9e","slug":"ACM学习笔记day22","date":"2023-01-23T13:17:12.000Z","updated":"2023-04-08T10:52:01.459Z","comments":true,"path":"api/articles/ACM学习笔记day22.json","keywords":null,"cover":"/img/codeforces.jpg","text":"浅过了个年，差不多了，应该回来念书了XD今天的内容是约数个数，约数之和，最大公约数。 约数个数,约数之和对于这个问题，其实就是两个公式。具体的证明，可以自寻资料查看。这里仅给出结果，和我自己的理解。严格的数学证明我们不多赘述。以下为公式(图中pi为N的质因数)： 好，公式我们给出...","link":"","photos":[],"count_time":{"symbolsCount":"3.2k","symbolsTime":"3 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":39,"path":"api/tags/ACM.json"},{"name":"学习","slug":"学习","count":43,"path":"api/tags/学习.json"},{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"数论","slug":"数论","count":5,"path":"api/tags/数论.json"},{"name":"约数","slug":"约数","count":2,"path":"api/tags/约数.json"},{"name":"公式","slug":"公式","count":1,"path":"api/tags/公式.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"tech otakus save the world","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}},{"title":"ACM学习笔记day27(求组合数的四种办法)","uid":"ee586e84b57b3261ae39e785bb3a8c62","slug":"ACM学习笔记day27","date":"2023-02-05T09:20:05.000Z","updated":"2023-04-08T10:52:38.582Z","comments":true,"path":"api/articles/ACM学习笔记day27.json","keywords":null,"cover":"/img/codeforces.jpg","text":"今天的内容是求组合数の四种办法。前三种是逐渐应对给的数据量变大的情况的。第四种是应对得到的结果太大会把longlong都爆掉的情况的。 注意：本篇中，涉及C[a][b]的均是以下组合数表达式。 因为这个blog主题不支持latex语言，所以也没办法现敲公式。 求组合数I这种求组合...","link":"","photos":[],"count_time":{"symbolsCount":"6.2k","symbolsTime":"6 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":39,"path":"api/tags/ACM.json"},{"name":"学习","slug":"学习","count":43,"path":"api/tags/学习.json"},{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"数学","slug":"数学","count":7,"path":"api/tags/数学.json"},{"name":"组合数","slug":"组合数","count":2,"path":"api/tags/组合数.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"tech otakus save the world","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}},{"title":"ACM学习笔记day26 (高斯消元解线性方程组和异或方程组)","uid":"1a520a07ea86cfe9d127f0b6811d1363","slug":"ACM学习笔记day26","date":"2023-02-04T13:00:01.000Z","updated":"2023-04-08T10:52:31.322Z","comments":true,"path":"api/articles/ACM学习笔记day26.json","keywords":null,"cover":"/img/codeforces.jpg","text":"今天的内容是使用高斯消元解线性方程组和异或方程组。什么是高斯消元，不多说，线代的基本内容。 高斯消元解线性方程组用高斯消元解线性方程组的时候，编程解决其实就是一个模拟的事情。我们写程序去模拟我们的实际进行的步骤。该模板的时间复杂度为O(n^3)。可以看到时间复杂度还是很高的。如果...","link":"","photos":[],"count_time":{"symbolsCount":"4.7k","symbolsTime":"4 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":39,"path":"api/tags/ACM.json"},{"name":"学习","slug":"学习","count":43,"path":"api/tags/学习.json"},{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"数学","slug":"数学","count":7,"path":"api/tags/数学.json"},{"name":"高斯消元","slug":"高斯消元","count":1,"path":"api/tags/高斯消元.json"},{"name":"解方程组","slug":"解方程组","count":1,"path":"api/tags/解方程组.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"tech otakus save the world","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}},{"title":"ACM学习笔记day24(扩展欧几里得算法，线性同余方程，中国剩余定理)","uid":"e8f352fc1ae41c272b21fc150a45992f","slug":"ACM学习笔记day24","date":"2023-02-02T14:25:04.000Z","updated":"2023-04-08T10:52:17.703Z","comments":true,"path":"api/articles/ACM学习笔记day24.json","keywords":null,"cover":"/img/codeforces.jpg","text":"emm，好像距离上次写博客好像是很久以前了呢(懒狗，摆烂王是吧)话不多说，直接进入正题，今天的内容是扩展欧几里得算法和CRT，也就是中国剩余定理，或者也叫孙子定理。 扩展欧几里得算法这个算法其实和欧几里得算法很像，都是用到了辗转相除法。只不过在辗转相除的同时，一边算了一个GCD，...","link":"","photos":[],"count_time":{"symbolsCount":"4.1k","symbolsTime":"4 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"学习","slug":"学习","count":43,"path":"api/tags/学习.json"},{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"蒟蒻","slug":"蒟蒻","count":4,"path":"api/tags/蒟蒻.json"},{"name":"数论","slug":"数论","count":5,"path":"api/tags/数论.json"},{"name":"扩展欧几里得","slug":"扩展欧几里得","count":1,"path":"api/tags/扩展欧几里得.json"},{"name":"CRT","slug":"CRT","count":1,"path":"api/tags/CRT.json"},{"name":"中国剩余定理","slug":"中国剩余定理","count":1,"path":"api/tags/中国剩余定理.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"tech otakus save the world","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}},{"title":"ACM学习笔记day28 (组合数的应用——满足条件的01序列，容斥原理)","uid":"cd92aa8f26118d15f6c9920aff860d6f","slug":"ACM学习笔记day28","date":"2023-02-07T09:31:39.000Z","updated":"2023-04-08T10:52:45.948Z","comments":true,"path":"api/articles/ACM学习笔记day28.json","keywords":null,"cover":"/img/codeforces.jpg","text":"今天的内容是组合数的应用——满足条件的01序列和容斥原理。关于这个满足条件的01序列，其实涉及到了一个特殊的数字卡特兰数。这个我们等会会讲这个。 满足条件的01序列题目意思就是给你n个0，n个1，让你排出来一个序列，使得对于任意的前缀，0的数量是大于等于1的数量的。问你这样的序列...","link":"","photos":[],"count_time":{"symbolsCount":"3.2k","symbolsTime":"3 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":39,"path":"api/tags/ACM.json"},{"name":"学习","slug":"学习","count":43,"path":"api/tags/学习.json"},{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"数学","slug":"数学","count":7,"path":"api/tags/数学.json"},{"name":"组合数","slug":"组合数","count":2,"path":"api/tags/组合数.json"},{"name":"容斥原理","slug":"容斥原理","count":1,"path":"api/tags/容斥原理.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"tech otakus save the world","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}},{"title":"ACM学习笔记day29 (Nim游戏，台阶-Nim游戏)","uid":"8af78f8e46bb9ac28caa93ffafd43362","slug":"ACM学习笔记day29","date":"2023-02-08T08:10:48.000Z","updated":"2023-04-08T10:52:54.992Z","comments":true,"path":"api/articles/ACM学习笔记day29.json","keywords":null,"cover":"/img/codeforces.jpg","text":"今天的内容是博弈论的一部分（后面有涉及到SG函数和MEX函数的额，还没听懂（所以只有这两个了。两个一个是Nim游戏是最基础的模型，台阶-Nim游戏是Nim游戏的进阶版本。 Nim游戏就是两个人轮流拿，随便拿几个，随便拿哪一堆的，拿到最后谁不能操作了，谁就输了。这里我们要讲两个概念...","link":"","photos":[],"count_time":{"symbolsCount":"2.6k","symbolsTime":"2 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":39,"path":"api/tags/ACM.json"},{"name":"学习","slug":"学习","count":43,"path":"api/tags/学习.json"},{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"数学","slug":"数学","count":7,"path":"api/tags/数学.json"},{"name":"博弈论","slug":"博弈论","count":1,"path":"api/tags/博弈论.json"},{"name":"Nim游戏","slug":"Nim游戏","count":1,"path":"api/tags/Nim游戏.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"tech otakus save the world","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}},{"title":"ACM学习笔记day3(高精度四则运算)","uid":"ffffeb1fbf512f768ee4d72750569670","slug":"ACM学习笔记day3","date":"2022-11-08T14:01:59.000Z","updated":"2023-04-08T10:49:48.429Z","comments":true,"path":"api/articles/ACM学习笔记day3.json","keywords":null,"cover":"/img/codeforces.jpg","text":"学习ACM有关东西的第四天。今天用晚上时间稍微学了点高精度加减乘除的运算。感觉是在模拟人类的运算过程，除了乘法(这不废话)So,Here we go! 总述有必要说明一下，对于高精度的四则运算，加法和减法是两个高精度的数字，而乘法和除法是一个高精度乘或者除以一个数同时因为数字的位...","link":"","photos":[],"count_time":{"symbolsCount":"6.6k","symbolsTime":"6 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":39,"path":"api/tags/ACM.json"},{"name":"学习","slug":"学习","count":43,"path":"api/tags/学习.json"},{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"数据结构","slug":"数据结构","count":23,"path":"api/tags/数据结构.json"},{"name":"算法","slug":"算法","count":20,"path":"api/tags/算法.json"},{"name":"蒟蒻","slug":"蒟蒻","count":4,"path":"api/tags/蒟蒻.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"tech otakus save the world","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}},{"title":"ACM学习笔记day25(扩展中国剩余定理)","uid":"3f5d2f03fa2075448efe1519bfee1297","slug":"ACM学习笔记day25","date":"2023-02-03T10:09:28.000Z","updated":"2023-04-08T10:52:24.226Z","comments":true,"path":"api/articles/ACM学习笔记day25.json","keywords":null,"cover":"/img/codeforces.jpg","text":"大标题就是题目链接。这节的内容是扩展CRT。其实就是在原来的基础上去掉了模数两两互质的条件。这样的话CRT就不能用了，得用扩展中国剩余定理。虽然说是扩展CRT，但是其实和CRT没什么关系，是一种解决这类问题的方法罢了 CRT解决的是什么问题，可以看我的上一篇博客，就在上面一篇。这...","link":"","photos":[],"count_time":{"symbolsCount":"1.6k","symbolsTime":"1 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"学习","slug":"学习","count":43,"path":"api/tags/学习.json"},{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"数论","slug":"数论","count":5,"path":"api/tags/数论.json"},{"name":"数学","slug":"数学","count":7,"path":"api/tags/数学.json"},{"name":"扩展中国剩余定理","slug":"扩展中国剩余定理","count":1,"path":"api/tags/扩展中国剩余定理.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"tech otakus save the world","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}},{"title":"ACM学习笔记day30 (01背包，完全背包,多重背包(朴素解法))","uid":"26c83eef7dc2b42905d68bf63d792926","slug":"ACM学习笔记day30","date":"2023-02-11T11:53:11.000Z","updated":"2023-04-08T10:53:02.760Z","comments":true,"path":"api/articles/ACM学习笔记day30.json","keywords":null,"cover":"/img/codeforces.jpg","text":"今天的内容是01背包多重背包完全背包。算是开启DP专题了。01背包是作为最关键的一个题目。其他完全背包和多重背包其实就是他的扩展。理解了01背包，理解其他的背包其实不难。 01背包01背包问题的解法，先从朴素开始。我们定义一个二维数组作为我们dp的数组。f[i][j]的意义为从前...","link":"","photos":[],"count_time":{"symbolsCount":"4.8k","symbolsTime":"4 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":39,"path":"api/tags/ACM.json"},{"name":"学习","slug":"学习","count":43,"path":"api/tags/学习.json"},{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"蒟蒻","slug":"蒟蒻","count":4,"path":"api/tags/蒟蒻.json"},{"name":"DP","slug":"DP","count":5,"path":"api/tags/DP.json"},{"name":"动态规划","slug":"动态规划","count":5,"path":"api/tags/动态规划.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"tech otakus save the world","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}},{"title":"ACM学习笔记day31 (多重背包(二进制优化)，分组背包)","uid":"c4215acd2eabdb6df78cd852601c9d9a","slug":"ACM学习笔记day31","date":"2023-02-18T08:34:37.000Z","updated":"2023-04-08T10:53:14.362Z","comments":true,"path":"api/articles/ACM学习笔记day31.json","keywords":null,"cover":"/img/codeforces.jpg","text":"今天的内容是多重背包的二进制优化解法和分组背包。 一开始听多重背包的二进制优化的时候还是蛮难的， 后来知道一个关键点之后就容易了。至于分组背包，其实和多重背包差不多的，只不过选择上稍微变了点。 多重背包（二进制优化）关于多重背包的一个二进制优化。我们原来的朴素做法就是，枚举第i个...","link":"","photos":[],"count_time":{"symbolsCount":"2.6k","symbolsTime":"2 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"学习","slug":"学习","count":43,"path":"api/tags/学习.json"},{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"DP","slug":"DP","count":5,"path":"api/tags/DP.json"},{"name":"动态规划","slug":"动态规划","count":5,"path":"api/tags/动态规划.json"},{"name":"背包问题","slug":"背包问题","count":1,"path":"api/tags/背包问题.json"},{"name":"背包","slug":"背包","count":1,"path":"api/tags/背包.json"},{"name":"多重背包","slug":"多重背包","count":1,"path":"api/tags/多重背包.json"},{"name":"分组背包","slug":"分组背包","count":1,"path":"api/tags/分组背包.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"tech otakus save the world","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}},{"title":"ACM学习笔记day32 (数字三角形，最长上升子序列)","uid":"0c3e2aa6872231e13fd503f7a08ea40b","slug":"ACM学习笔记day32","date":"2023-02-20T14:18:20.000Z","updated":"2023-04-08T10:53:21.330Z","comments":true,"path":"api/articles/ACM学习笔记day32.json","keywords":null,"cover":"/img/codeforces.jpg","text":"今天的内容是数字三角形，和最长上升子序列。其中最长上升子序列可以说是dp问题里面非常经典的问题了。 数字三角形对于这个题，我们的dp思路其实很简单。当然在此之前，我们需要定义一下这个三角形的行和列。给的三角形是这样的: 7 3 8 8 1 0 2 7 4 4 4 5 2 6 5 ...","link":"","photos":[],"count_time":{"symbolsCount":"3.8k","symbolsTime":"3 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":39,"path":"api/tags/ACM.json"},{"name":"学习","slug":"学习","count":43,"path":"api/tags/学习.json"},{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"DP","slug":"DP","count":5,"path":"api/tags/DP.json"},{"name":"动态规划","slug":"动态规划","count":5,"path":"api/tags/动态规划.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"tech otakus save the world","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}},{"title":"ACM学习笔记day35(拓扑序列)","uid":"f4b8c236f24c3289ca5c3e33420c6ba4","slug":"ACM学习笔记day35","date":"2023-03-21T14:49:38.000Z","updated":"2023-04-08T10:54:07.183Z","comments":true,"path":"api/articles/ACM学习笔记day35.json","keywords":null,"cover":"/img/codeforces.jpg","text":"今天的内容是拓扑排序。 若一个由图中所有点构成的序列A满足：对于图中的每条边 (x,y) x 在 A 中都出现在 y 之前，则称 A 是该图的一个拓扑序列。注意：图的拓扑序并不一定唯一所以题目的答案并不唯一。 那么我们应该怎么去求拓扑序列呢？很显然，我们从定义出发，我们需要保证序...","link":"","photos":[],"count_time":{"symbolsCount":"1.8k","symbolsTime":"2 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":39,"path":"api/tags/ACM.json"},{"name":"学习","slug":"学习","count":43,"path":"api/tags/学习.json"},{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"图论","slug":"图论","count":3,"path":"api/tags/图论.json"},{"name":"dfs","slug":"dfs","count":4,"path":"api/tags/dfs.json"},{"name":"bfs","slug":"bfs","count":3,"path":"api/tags/bfs.json"},{"name":"拓扑排序","slug":"拓扑排序","count":1,"path":"api/tags/拓扑排序.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"tech otakus save the world","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}},{"title":"ACM学习笔记day36(树和图的DFS和BFS)","uid":"1429a762104f1c731f39acc20f00d741","slug":"ACM学习笔记day36","date":"2023-03-25T12:50:55.000Z","updated":"2023-04-08T10:54:15.019Z","comments":true,"path":"api/articles/ACM学习笔记day36.json","keywords":null,"cover":"/img/codeforces.jpg","text":"水一篇blog（树和图的bfs和dfs。 树和图的存储方式采用领接表或者是领接矩阵都可以。dfs和bfs的思路是一样的。bfs套用bfs的模板就可以了，定义一个工作队列。将没有访问过的领接点放入队列中，然后处理即可dfs就遍历他的所有领接点，然后如果没访问过的话就dfs下去。然后...","link":"","photos":[],"count_time":{"symbolsCount":"1.9k","symbolsTime":"2 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":39,"path":"api/tags/ACM.json"},{"name":"学习","slug":"学习","count":43,"path":"api/tags/学习.json"},{"name":"图论","slug":"图论","count":3,"path":"api/tags/图论.json"},{"name":"dfs","slug":"dfs","count":4,"path":"api/tags/dfs.json"},{"name":"bfs","slug":"bfs","count":3,"path":"api/tags/bfs.json"},{"name":"树","slug":"树","count":1,"path":"api/tags/树.json"},{"name":"图","slug":"图","count":1,"path":"api/tags/图.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"tech otakus save the world","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}},{"title":"ACM学习笔记day33 (状态压缩DP)","uid":"2c6fdca36eef66c662c85d61e609fdfd","slug":"ACM学习笔记day33","date":"2023-02-28T14:11:30.000Z","updated":"2023-04-08T10:53:42.797Z","comments":true,"path":"api/articles/ACM学习笔记day33.json","keywords":null,"cover":"/img/codeforces.jpg","text":"状态压缩DP，其实就是线性DP的基础上加上了状态压缩。 那么什么是状态压缩呢？其实就是将状态的集合，通过一种特定的方式来便利的表示出来，同时也降低了时间复杂度。一般的，我们会将很多种取或者不取的状态集合，用一个01串来表示。这样也就是通过状态压缩来实现这种功能了。 例如在蒙德里安...","link":"","photos":[],"count_time":{"symbolsCount":394,"symbolsTime":"1 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":39,"path":"api/tags/ACM.json"},{"name":"学习","slug":"学习","count":43,"path":"api/tags/学习.json"},{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"DP","slug":"DP","count":5,"path":"api/tags/DP.json"},{"name":"动态规划","slug":"动态规划","count":5,"path":"api/tags/动态规划.json"},{"name":"状态压缩DP","slug":"状态压缩DP","count":1,"path":"api/tags/状态压缩DP.json"},{"name":"状态压缩","slug":"状态压缩","count":1,"path":"api/tags/状态压缩.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"tech otakus save the world","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}},{"title":"ACM学习笔记day37 (最短路算法总结)","uid":"d62cd488fd25981616571e6226f3871a","slug":"ACM学习笔记day37","date":"2023-03-25T12:51:16.000Z","updated":"2024-12-29T14:18:21.976Z","comments":true,"path":"api/articles/ACM学习笔记day37.json","keywords":null,"cover":"/img/codeforces.jpg","text":"好，我们这一节对最短路算法作一个总结。总的来说基础的最短路算法有四种。分别为 Dijksta,bellman-ford，spfa，floyd算法。不同的算法应对的是不同的情况。 什么算法解决什么问题，可以看下面这张图。 我们最短路问题，可以分为两大类问题，一类是单源最短路，也就是...","link":"","photos":[],"count_time":{"symbolsCount":"8.9k","symbolsTime":"8 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":39,"path":"api/tags/ACM.json"},{"name":"学习","slug":"学习","count":43,"path":"api/tags/学习.json"},{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"最短路问题","slug":"最短路问题","count":1,"path":"api/tags/最短路问题.json"},{"name":"Dijkstra","slug":"Dijkstra","count":1,"path":"api/tags/Dijkstra.json"},{"name":"Bellman-ford","slug":"Bellman-ford","count":1,"path":"api/tags/Bellman-ford.json"},{"name":"spfa","slug":"spfa","count":1,"path":"api/tags/spfa.json"},{"name":"floyd","slug":"floyd","count":1,"path":"api/tags/floyd.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"tech otakus save the world","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}},"feature":false},{"title":"ACM学习笔记day4(前缀和和差分)","uid":"4143f6a2444e4122fe8da477a7a2d540","slug":"ACM学习笔记day4","date":"2022-11-09T14:02:19.000Z","updated":"2023-04-08T10:49:05.915Z","comments":true,"path":"api/articles/ACM学习笔记day4.json","keywords":null,"cover":"/img/codeforces.jpg","text":"今天学了前缀和和差分，及其数组。前缀和不多说了，比较好理解，主要还是差分，这个比较抽象 前缀和主要注意一下，前缀和数组从1开始，0的位置就归零，这样就不用地方越界问题了。 差分至于差分。emmmm差分数组不需要构建，~~~当然也可以构建~~~二位差分同理 int a[N],B[N...","link":"","photos":[],"count_time":{"symbolsCount":875,"symbolsTime":"1 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":39,"path":"api/tags/ACM.json"},{"name":"学习","slug":"学习","count":43,"path":"api/tags/学习.json"},{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"数据结构","slug":"数据结构","count":23,"path":"api/tags/数据结构.json"},{"name":"算法","slug":"算法","count":20,"path":"api/tags/算法.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"tech otakus save the world","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}},{"title":"ACM学习笔记day5(双指针，位运算)","uid":"ceed889808223c52789eb0c0c60367bf","slug":"ACM学习笔记day5","date":"2022-11-10T09:25:34.000Z","updated":"2023-04-08T10:48:56.517Z","comments":true,"path":"api/articles/ACM学习笔记day5.json","keywords":null,"cover":"/img/codeforces.jpg","text":"今天学习了一下双指针算法，感觉还是挺难的。就是一个由单调性可以推出应该用双指针这个有点不是很能理解。QAQ还有个位运算。 求最长无重复数字的子串问题 采用双指针的算法的话，我们让i从头到尾遍历数组，对于每一个i，j表示当前子串的左边界。如果在j到i这块子串有相同的数字，则让j++...","link":"","photos":[],"count_time":{"symbolsCount":"1.5k","symbolsTime":"1 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":39,"path":"api/tags/ACM.json"},{"name":"学习","slug":"学习","count":43,"path":"api/tags/学习.json"},{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"数据结构","slug":"数据结构","count":23,"path":"api/tags/数据结构.json"},{"name":"算法","slug":"算法","count":20,"path":"api/tags/算法.json"},{"name":"双指针","slug":"双指针","count":1,"path":"api/tags/双指针.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"tech otakus save the world","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}},{"title":"ACM学习笔记day6(离散化)","uid":"1e7a8acd61656fdbe512e6f88b5aff86","slug":"ACM学习笔记day6","date":"2022-11-10T13:57:48.000Z","updated":"2023-04-08T10:49:10.497Z","comments":true,"path":"api/articles/ACM学习笔记day6.json","keywords":null,"cover":"/img/codeforces.jpg","text":"其实这一节，应该是day5里面的，因为呃呃呃我看到这一节acwing里面的视频长度比较长，所以我就分割出来作为单独的一个blog来写了。算法的思想比较重要。 离散化 题目acwing区间和说实话，离散化的概念不难理解但是实际运用起来，发现诶，用不来了 首先，什么是离散化？离散化一...","link":"","photos":[],"count_time":{"symbolsCount":"3k","symbolsTime":"3 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":39,"path":"api/tags/ACM.json"},{"name":"学习","slug":"学习","count":43,"path":"api/tags/学习.json"},{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"数据结构","slug":"数据结构","count":23,"path":"api/tags/数据结构.json"},{"name":"算法","slug":"算法","count":20,"path":"api/tags/算法.json"},{"name":"离散化","slug":"离散化","count":1,"path":"api/tags/离散化.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"tech otakus save the world","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}},{"title":"ACM学习笔记day7(区间合并，静态单链表，静态双向链表)","uid":"6626baeb85b77ff2abeecddea4b9b43b","slug":"ACM学习笔记day7","date":"2022-11-12T15:20:17.000Z","updated":"2023-04-08T10:49:14.216Z","comments":true,"path":"api/articles/ACM学习笔记day7.json","keywords":null,"cover":"/img/codeforces.jpg","text":"emm今天搞了点区间合并和静态链表。感觉静态链表的写法还是比较繁琐的。逻辑上感觉有点绕可能是我写习惯动态链表的原因吧（ 区间合并题目来源Acwing链接题目不难，贪心就能做。当时不讲，直接做出来了。不多赘述。 #include&lt;bits&#x2F;stdc++.h&gt; ...","link":"","photos":[],"count_time":{"symbolsCount":"4.3k","symbolsTime":"4 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":39,"path":"api/tags/ACM.json"},{"name":"学习","slug":"学习","count":43,"path":"api/tags/学习.json"},{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"数据结构","slug":"数据结构","count":23,"path":"api/tags/数据结构.json"},{"name":"算法","slug":"算法","count":20,"path":"api/tags/算法.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"tech otakus save the world","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}},{"title":"ACM学习笔记day8(模拟栈，表达式求值，模拟队列，单调栈)","uid":"0bde88ed9132d2dd0ee34fc3f801dfcc","slug":"ACM学习笔记day8","date":"2022-11-15T13:52:59.000Z","updated":"2023-04-08T10:49:21.906Z","comments":true,"path":"api/articles/ACM学习笔记day8.json","keywords":null,"cover":"/img/codeforces.jpg","text":"wdnmd,受不了了，一拳把地球打爆。今天的内容原本应该是11月13号的因为当晚是有个讲座要听，没空写博客想着明天写，结果昨天忙的要死，今天还是忙的要死今天晚上终于稍微有点空了，赶紧把博客给补了，顺便也隔了几天复习一下东西。今天主要学的是 模拟栈，表达式求值，模拟队列和单调栈。 ...","link":"","photos":[],"count_time":{"symbolsCount":"2.9k","symbolsTime":"3 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":39,"path":"api/tags/ACM.json"},{"name":"学习","slug":"学习","count":43,"path":"api/tags/学习.json"},{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"数据结构","slug":"数据结构","count":23,"path":"api/tags/数据结构.json"},{"name":"算法","slug":"算法","count":20,"path":"api/tags/算法.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"tech otakus save the world","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}},{"title":"ACM学习笔记day9(滑动窗口，双端队列)","uid":"958adf9461e6c3975304da3314c38d67","slug":"ACM学习笔记day9","date":"2022-11-17T13:07:42.000Z","updated":"2023-04-08T10:49:25.073Z","comments":true,"path":"api/articles/ACM学习笔记day9.json","keywords":null,"cover":"/img/codeforces.jpg","text":"今天学习的时间比较短，哦，确实也挺短的不过当时比较困，理解起来也很慢，所以今天的内容只有一个是滑动窗口和双端队列！ 滑动窗口什么是滑动窗口！就是单调队列的一道经典例题链接这里因为要用到了单调队列。我acwing上打卡用的是数组模拟双端队列的。而目前上面的题解是使用STL里面的双端...","link":"","photos":[],"count_time":{"symbolsCount":"2.4k","symbolsTime":"2 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":39,"path":"api/tags/ACM.json"},{"name":"学习","slug":"学习","count":43,"path":"api/tags/学习.json"},{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"数据结构","slug":"数据结构","count":23,"path":"api/tags/数据结构.json"},{"name":"算法","slug":"算法","count":20,"path":"api/tags/算法.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"tech otakus save the world","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}},{"title":"ACM小本本","uid":"4a9ea142753f2671aa4c5ecbc1f2c491","slug":"ACM小本本","date":"2022-11-09T12:43:41.000Z","updated":"2023-08-25T14:20:11.540Z","comments":true,"path":"api/articles/ACM小本本.json","keywords":null,"cover":"/img/codeforces.jpg","text":"这里是记录ACM知识点中一些零碎的东西，或者一些小的注意点啥的 1.使用二分模板的时候，当修改left值的时候，注意要让mid&#x3D;left+right+1&gt;&gt;1，不然会出现mid&#x3D;left然后死循环的出现2.快排和归并的本质就是分治，快排是先处理数据...","link":"","photos":[],"count_time":{"symbolsCount":"2k","symbolsTime":"2 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":39,"path":"api/tags/ACM.json"},{"name":"学习","slug":"学习","count":43,"path":"api/tags/学习.json"},{"name":"笔记本","slug":"笔记本","count":2,"path":"api/tags/笔记本.json"},{"name":"零碎的","slug":"零碎的","count":2,"path":"api/tags/零碎的.json"},{"name":"知识点","slug":"知识点","count":2,"path":"api/tags/知识点.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"tech otakus save the world","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}},"feature":true},{"title":"Python学习日志day1","uid":"9440b99fb66535a63cc60a8f05ed5e66","slug":"Python学习日志day1","date":"2023-02-23T05:38:44.000Z","updated":"2024-12-29T15:41:00.233Z","comments":true,"path":"api/articles/Python学习日志day1.json","keywords":null,"cover":"/img/Python.jpg","text":"emm，因为导师要求，所以需要学习一下py，同时可能要为数据库的课设作语言准备，所以就另外开了这样的一个日志。 不过虽说是学习日志，这里我也基本上只会放一些容易忘记的函数啥的。 不会有其他的东西了。qwq 关于字符串 字符串.title()这个函数可以使得字符串里面每一个单词的首...","link":"","photos":[],"count_time":{"symbolsCount":986,"symbolsTime":"1 mins."},"categories":[{"name":"Python","slug":"Python","count":4,"path":"api/categories/Python.json"}],"tags":[{"name":"学习","slug":"学习","count":43,"path":"api/tags/学习.json"},{"name":"python","slug":"python","count":3,"path":"api/tags/python.json"},{"name":"语言","slug":"语言","count":3,"path":"api/tags/语言.json"},{"name":"基础","slug":"基础","count":3,"path":"api/tags/基础.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"tech otakus save the world","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}},{"title":"Python学习日志day3","uid":"864fc2c6f57dbf62e38e8d5dfd7c13f6","slug":"Python学习日志day3","date":"2023-03-01T14:49:10.000Z","updated":"2023-08-27T09:17:05.089Z","comments":true,"path":"api/articles/Python学习日志day3.json","keywords":null,"cover":"/img/Python.jpg","text":"关于range()用法range()参数说明调用range()如果有两个参数，就表示从第一个参数到第二个参数的中间的所有的数字，左闭右开。如果只有一个参数则就是从0到这个参数的所有数字，左闭右开。如果有三个参数，那么前两个参数和上面这个第一条一样，第三条参数则是他的步长，比如ra...","link":"","photos":[],"count_time":{"symbolsCount":719,"symbolsTime":"1 mins."},"categories":[{"name":"Python","slug":"Python","count":4,"path":"api/categories/Python.json"}],"tags":[{"name":"学习","slug":"学习","count":43,"path":"api/tags/学习.json"},{"name":"python","slug":"python","count":3,"path":"api/tags/python.json"},{"name":"语言","slug":"语言","count":3,"path":"api/tags/语言.json"},{"name":"基础","slug":"基础","count":3,"path":"api/tags/基础.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"tech otakus save the world","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}},{"title":"Python学习日志day2","uid":"a7b5056260bafa19bfefd98278cc6498","slug":"Python学习日志day2","date":"2023-02-26T14:02:34.000Z","updated":"2023-08-27T09:16:58.218Z","comments":true,"path":"api/articles/Python学习日志day2.json","keywords":null,"cover":"/img/Python.jpg","text":"emm，是学习py的第二天力。 下周就要开始搞数据库课设力！ 要G力 anyway,之后py还是要学的，毕竟想自己搞个bot玩玩XD 关于sort方法sort()方法py中的sort使用方法和cpp中的有略微的不同。 cpp中是直接使用sort函数，然后里面放入形参就是了， 但是...","link":"","photos":[],"count_time":{"symbolsCount":921,"symbolsTime":"1 mins."},"categories":[{"name":"Python","slug":"Python","count":4,"path":"api/categories/Python.json"}],"tags":[{"name":"学习","slug":"学习","count":43,"path":"api/tags/学习.json"},{"name":"python","slug":"python","count":3,"path":"api/tags/python.json"},{"name":"语言","slug":"语言","count":3,"path":"api/tags/语言.json"},{"name":"基础","slug":"基础","count":3,"path":"api/tags/基础.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"tech otakus save the world","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}},{"title":"Python学习日志day4","uid":"f0263da8eb494789f12ee807a4dcd631","slug":"Python学习日志day4","date":"2023-03-05T14:00:31.000Z","updated":"2023-08-27T09:17:10.660Z","comments":true,"path":"api/articles/Python学习日志day4.json","keywords":null,"cover":"/img/Python.jpg","text":"有关一些if条件判断的东西 检查一个元素是否在列表里面可以直接使用 value in array_name 返回的是True or False 如果查询是否不在，那就是not in 列表名可以直接作为if条件句的判断，如果为空则为false，反之为true。 关于字典","link":"","photos":[],"count_time":{"symbolsCount":139,"symbolsTime":"1 mins."},"categories":[{"name":"Python","slug":"Python","count":4,"path":"api/categories/Python.json"}],"tags":[{"name":"学习","slug":"学习","count":43,"path":"api/tags/学习.json"},{"name":"Python","slug":"Python","count":2,"path":"api/tags/Python.json"},{"name":"编程","slug":"编程","count":1,"path":"api/tags/编程.json"},{"name":"萌新","slug":"萌新","count":1,"path":"api/tags/萌新.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"tech otakus save the world","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}},{"title":"selfNotes","uid":"e51c6b0cc288c9b94c0f6d165fb0d5e1","slug":"selfNotes","date":"2025-03-01T11:44:17.562Z","updated":"2025-03-01T11:44:21.691Z","comments":true,"path":"api/articles/selfNotes.json","keywords":null,"cover":"https://zh.d2l.ai/_images/front.png","text":"以此note介绍LLM有关的trick或者一些信息差的东西。 计算loss的时候记得把padding token屏蔽掉，不然模型学的全是padding token，根本不会输出其他token LLM的学习率往往很低，不要以为0.0005就已经很小了，如果发现模型收敛到一定的值就不...","link":"","photos":[],"count_time":{"symbolsCount":"2k","symbolsTime":"2 mins."},"categories":[{"name":"LLM","slug":"LLM","count":1,"path":"api/categories/LLM.json"}],"tags":[{"name":"学习","slug":"学习","count":43,"path":"api/tags/学习.json"},{"name":"笔记本","slug":"笔记本","count":2,"path":"api/tags/笔记本.json"},{"name":"零碎的","slug":"零碎的","count":2,"path":"api/tags/零碎的.json"},{"name":"知识点","slug":"知识点","count":2,"path":"api/tags/知识点.json"},{"name":"深度学习","slug":"深度学习","count":1,"path":"api/tags/深度学习.json"},{"name":"大模型","slug":"大模型","count":1,"path":"api/tags/大模型.json"},{"name":"训练","slug":"训练","count":1,"path":"api/tags/训练.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"tech otakus save the world","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}},"feature":false},{"title":"网站开发日志1(网站的准备过程，搭建，部署，发布)","uid":"b1c29db086b8b87ca11beaf5db14c0e6","slug":"网站开发日志1","date":"2022-11-07T02:25:32.000Z","updated":"2023-08-27T09:17:57.823Z","comments":true,"path":"api/articles/网站开发日志1.json","keywords":null,"cover":null,"text":"introHello guys!&lt;br&gt;Welcome to this piece of blog &lt;br&gt;Until now, I have basically deploy my blog site on the github successfully...","link":"","photos":[],"count_time":{"symbolsCount":"2.4k","symbolsTime":"2 mins."},"categories":[{"name":"个人博客开发","slug":"个人博客开发","count":2,"path":"api/categories/个人博客开发.json"}],"tags":[{"name":"学习","slug":"学习","count":43,"path":"api/tags/学习.json"},{"name":"网站部署","slug":"网站部署","count":2,"path":"api/tags/网站部署.json"},{"name":"网站开发","slug":"网站开发","count":2,"path":"api/tags/网站开发.json"},{"name":"网站维护","slug":"网站维护","count":2,"path":"api/tags/网站维护.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"tech otakus save the world","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}},{"title":"网安notes","uid":"8a327c3785082cab489d4df782f60065","slug":"网安notes","date":"2024-01-02T13:27:36.000Z","updated":"2024-01-03T01:43:54.905Z","comments":true,"path":"api/articles/网安notes.json","keywords":null,"cover":[],"text":"网络安全和密码学的笔记绪论 网络空间安全的CIA三元组：保密性(Confidecial)，完整性(Integrity)，可用性(Available) 后续又有人提出来还需要两个要求（两个A）：真实性(Authenticity)，可审计性(Accountability) 被动攻击：...","link":"","photos":[],"count_time":{"symbolsCount":"2.1k","symbolsTime":"2 mins."},"categories":[{"name":"网络安全和密码学","slug":"网络安全和密码学","count":1,"path":"api/categories/网络安全和密码学.json"}],"tags":[{"name":"学习","slug":"学习","count":43,"path":"api/tags/学习.json"},{"name":"网络安全","slug":"网络安全","count":1,"path":"api/tags/网络安全.json"},{"name":"密码学","slug":"密码学","count":1,"path":"api/tags/密码学.json"},{"name":"期末复习","slug":"期末复习","count":1,"path":"api/tags/期末复习.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"tech otakus save the world","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}},{"title":"网站开发日志2(新增了图床)","uid":"d247f335debb5355e7105da57059aeeb","slug":"网站开发日志2","date":"2022-12-11T08:51:32.000Z","updated":"2023-08-27T09:18:15.701Z","comments":true,"path":"api/articles/网站开发日志2.json","keywords":null,"cover":[],"text":"emmm，日志是之后写的，实际的实现功能在之前就完成了这里只是补个开发日志而已 更新内容： 新增了图床，博客中可以上传图片了 简单学习了一下图床，现在所有的图片我都放图床上了那么接下来，我们博客里面也就能看到图片力！好耶！ ","link":"","photos":[],"count_time":{"symbolsCount":124,"symbolsTime":"1 mins."},"categories":[{"name":"个人博客开发","slug":"个人博客开发","count":2,"path":"api/categories/个人博客开发.json"}],"tags":[{"name":"学习","slug":"学习","count":43,"path":"api/tags/学习.json"},{"name":"网站部署","slug":"网站部署","count":2,"path":"api/tags/网站部署.json"},{"name":"网站开发","slug":"网站开发","count":2,"path":"api/tags/网站开发.json"},{"name":"网站维护","slug":"网站维护","count":2,"path":"api/tags/网站维护.json"},{"name":"图床","slug":"图床","count":1,"path":"api/tags/图床.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"tech otakus save the world","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}},{"title":"题解-Codeforces-Round-837-div-2","uid":"8939638ff3772e749e6b91f98033c73a","slug":"题解-Codeforces-Round-837-div-2","date":"2022-12-12T11:57:48.000Z","updated":"2023-08-27T09:17:27.684Z","comments":true,"path":"api/articles/题解-Codeforces-Round-837-div-2.json","keywords":null,"cover":"/img/二次元の图/1.jpg","text":"蒟蒻又日常来尝试div2了，这次独立（额，算独立吗）做出来的只有A，B还是问了别人才做出来的，接下里的这个就是B的题解。下面这个做法真的十分的优雅。代码很简洁，思路也很清楚。 B-Hossam and Friends 题目链接 题目描述：一个人有n个朋友，按照1,2,3,4…，n...","link":"","photos":[],"count_time":{"symbolsCount":"2.2k","symbolsTime":"2 mins."},"categories":[{"name":"题解","slug":"题解","count":1,"path":"api/categories/题解.json"}],"tags":[{"name":"ACM","slug":"ACM","count":39,"path":"api/tags/ACM.json"},{"name":"学习","slug":"学习","count":43,"path":"api/tags/学习.json"},{"name":"数据结构","slug":"数据结构","count":23,"path":"api/tags/数据结构.json"},{"name":"算法","slug":"算法","count":20,"path":"api/tags/算法.json"},{"name":"codeforces","slug":"codeforces","count":1,"path":"api/tags/codeforces.json"},{"name":"题解","slug":"题解","count":1,"path":"api/tags/题解.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"tech otakus save the world","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}}]}