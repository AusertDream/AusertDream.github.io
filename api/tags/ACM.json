{"name":"ACM","slug":"ACM","count":39,"postlist":[{"title":"ACM学习笔记day10(KMP)","uid":"f3213b374a759ee017011c4487f29020","slug":"ACM学习笔记day10","date":"2022-11-19T14:38:53.000Z","updated":"2023-04-08T10:49:28.522Z","comments":true,"path":"api/articles/ACM学习笔记day10.json","keywords":null,"cover":"/img/codeforces.jpg","text":"今天的学习内容是！KMP！呃呃呃，理解了大概两天的样子，现在终于是差不多有点理解了。 KMP题目链接acwingKMP算法用于两个字符串匹配的时候提供一个线性时间复杂度的做法。其中一个关键的东西，就是next数组next数组定义：next[i]的值，表示主串匹配到第i位的时候，第...","link":"","photos":[],"count_time":{"symbolsCount":"3.7k","symbolsTime":"3 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":39,"path":"api/tags/ACM.json"},{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"学习","slug":"学习","count":43,"path":"api/tags/学习.json"},{"name":"算法","slug":"算法","count":20,"path":"api/tags/算法.json"},{"name":"数据结构","slug":"数据结构","count":23,"path":"api/tags/数据结构.json"},{"name":"KMP","slug":"KMP","count":1,"path":"api/tags/KMP.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"tech otakus save the world","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}},{"title":"ACM学习笔记day11(Trie树)","uid":"cf4a03b1403b8a8d56d4650e2b121d28","slug":"ACM学习笔记day11","date":"2022-11-20T13:36:27.000Z","updated":"2023-04-08T10:50:36.627Z","comments":true,"path":"api/articles/ACM学习笔记day11.json","keywords":null,"cover":"/img/codeforces.jpg","text":"Hello guys！今天学习的内容是Trie树，应该也是叫字典树题目链接acwing 直接上代码吧理解不难 #include&lt;iostream&gt; #include&lt;string&gt; using namespace std; const int N &#x3...","link":"","photos":[],"count_time":{"symbolsCount":"1.6k","symbolsTime":"1 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":39,"path":"api/tags/ACM.json"},{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"学习","slug":"学习","count":43,"path":"api/tags/学习.json"},{"name":"算法","slug":"算法","count":20,"path":"api/tags/算法.json"},{"name":"数据结构","slug":"数据结构","count":23,"path":"api/tags/数据结构.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"tech otakus save the world","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}},{"title":"ACM学习笔记day13(求连通块中点的数量)","uid":"d45c53bbd2d951bda24bba0bdde79964","slug":"ACM学习笔记day13","date":"2022-11-25T11:42:49.000Z","updated":"2023-04-08T10:50:52.060Z","comments":true,"path":"api/articles/ACM学习笔记day13.json","keywords":null,"cover":"/img/codeforces.jpg","text":"今天的内容是求连通块中点的数量 求连通块中点的数量这题和并查集那道模板题差不多就是多了一个要求让你统计集合中的数量而已 这里我们用到一个cnt数组，同时我们规定，只有根节点的cnt数据是有意义的这样我们就避免了要给多个同连通块的集合重新赋值的麻烦 #include&lt;bits...","link":"","photos":[],"count_time":{"symbolsCount":"1.5k","symbolsTime":"1 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":39,"path":"api/tags/ACM.json"},{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"学习","slug":"学习","count":43,"path":"api/tags/学习.json"},{"name":"算法","slug":"算法","count":20,"path":"api/tags/算法.json"},{"name":"数据结构","slug":"数据结构","count":23,"path":"api/tags/数据结构.json"},{"name":"并查集","slug":"并查集","count":2,"path":"api/tags/并查集.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"tech otakus save the world","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}},{"title":"ACM学习笔记day14（带权并查集，堆排序，模拟堆）","uid":"baee1de5b96302e6e975d5e11b914928","slug":"ACM学习笔记day14","date":"2022-12-01T14:13:12.000Z","updated":"2023-04-08T10:50:59.395Z","comments":true,"path":"api/articles/ACM学习笔记day14.json","keywords":null,"cover":"/img/codeforces.jpg","text":"Hello guys!感觉好久没有写笔记了，上次写笔记好像是呃呃呃，五天前了吧。要忙学校的好多事情，呜呜呜，我有罪orz好了，不bb了，今天的学习内容是带权并查集（食物链）,堆模拟,堆排序 带权并查集带权并查集就是原来并查集的升级版，plus版本。相较于原来的普通的并查集，带权并...","link":"","photos":[],"count_time":{"symbolsCount":"8.2k","symbolsTime":"7 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":39,"path":"api/tags/ACM.json"},{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"学习","slug":"学习","count":43,"path":"api/tags/学习.json"},{"name":"算法","slug":"算法","count":20,"path":"api/tags/算法.json"},{"name":"数据结构","slug":"数据结构","count":23,"path":"api/tags/数据结构.json"},{"name":"带权并查集","slug":"带权并查集","count":1,"path":"api/tags/带权并查集.json"},{"name":"堆","slug":"堆","count":1,"path":"api/tags/堆.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"tech otakus save the world","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}},{"title":"ACM学习笔记day12(最大异或对，并查集)","uid":"5299e436ed1961fa0cb39dca432850d2","slug":"ACM学习笔记day12","date":"2022-11-24T14:50:04.000Z","updated":"2023-04-08T10:50:43.082Z","comments":true,"path":"api/articles/ACM学习笔记day12.json","keywords":null,"cover":"/img/codeforces.jpg","text":"今天的内容是Trie树的应用和并查集的学习。这个最大异或对的话，就是Trie树的应用，然后有别于之前那个Trie树存的数据不一样，之前那个存的是char，现在这个存的是0和1。然后并查集的话感觉就是构建了一个森林，然后每一颗树代表了一定的信息。 最大异或对最大异或对。题目是啥呢，...","link":"","photos":[],"count_time":{"symbolsCount":"3.9k","symbolsTime":"4 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":39,"path":"api/tags/ACM.json"},{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"算法","slug":"算法","count":20,"path":"api/tags/算法.json"},{"name":"数据结构","slug":"数据结构","count":23,"path":"api/tags/数据结构.json"},{"name":"并查集","slug":"并查集","count":2,"path":"api/tags/并查集.json"},{"name":"Trie树","slug":"Trie树","count":1,"path":"api/tags/Trie树.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"tech otakus save the world","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}},{"title":"ACM学习笔记day15(哈希，字符串的哈希)","uid":"5358138299a8ff147d7f561517fe5a1d","slug":"ACM学习笔记day15","date":"2022-12-02T12:15:59.000Z","updated":"2023-04-08T10:51:06.595Z","comments":true,"path":"api/articles/ACM学习笔记day15.json","keywords":null,"cover":"/img/codeforces.jpg","text":"hello guys！今天的学习内容是哈希表，也就是散列表对应acwing上的模拟散列表和字符串哈希 那么问题来了什么是哈希表呢？一句话来总结就是，不保序的离散化离散化其实是哈希化的一种特殊情况我们将数据范围很大的，较少的数字，映射到一个比较小的数组，这就是哈希，不过中间的那个映...","link":"","photos":[],"count_time":{"symbolsCount":"4.8k","symbolsTime":"4 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":39,"path":"api/tags/ACM.json"},{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"学习","slug":"学习","count":43,"path":"api/tags/学习.json"},{"name":"算法","slug":"算法","count":20,"path":"api/tags/算法.json"},{"name":"数据结构","slug":"数据结构","count":23,"path":"api/tags/数据结构.json"},{"name":"笔记","slug":"笔记","count":3,"path":"api/tags/笔记.json"},{"name":"哈希表","slug":"哈希表","count":1,"path":"api/tags/哈希表.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"tech otakus save the world","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}},{"title":"ACM学习笔记day16(朴素dijkstra求最短路径)","uid":"569c66ff03a6fea9d4ceedb2c072fa60","slug":"ACM学习笔记day16","date":"2022-12-03T13:32:15.000Z","updated":"2023-04-08T10:51:15.100Z","comments":true,"path":"api/articles/ACM学习笔记day16.json","keywords":null,"cover":"/img/codeforces.jpg","text":"Hello，guys！今天我们学习的内容是dijkstra算法求最短路径,题目emm，第一次学这个的话，感觉还是比较抽象的，不过想了一段时间，稍微整理了一下思路，感觉也还可以应该（ 朴素Dijkstra为什么叫朴素dijkstra呢？因为目前这个dijkstra算法的时间复杂度是...","link":"","photos":[],"count_time":{"symbolsCount":"2.8k","symbolsTime":"3 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":39,"path":"api/tags/ACM.json"},{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"学习","slug":"学习","count":43,"path":"api/tags/学习.json"},{"name":"算法","slug":"算法","count":20,"path":"api/tags/算法.json"},{"name":"数据结构","slug":"数据结构","count":23,"path":"api/tags/数据结构.json"},{"name":"蒟蒻","slug":"蒟蒻","count":4,"path":"api/tags/蒟蒻.json"},{"name":"dijkstra","slug":"dijkstra","count":1,"path":"api/tags/dijkstra.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"tech otakus save the world","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}},{"title":"ACM学习笔记day17(floyd算法求多源最短路)","uid":"633b5f64cd1a9eff1c65ad66ca026b45","slug":"ACM学习笔记day17","date":"2022-12-09T14:20:36.000Z","updated":"2023-04-08T10:51:22.699Z","comments":true,"path":"api/articles/ACM学习笔记day17.json","keywords":null,"cover":"/img/codeforces.jpg","text":"额，距离上次写ACM笔记好像已经过了很久了其实这是有原因(借口)的，在被模电折磨捏~好了，不多bb了今天学习的内容是Floyd算法求多源最短路。这个算法写起来东西很少，同时也比较简单，从整体上去理解的话，感觉还是不难理解的运用的思想就是DP的思想 直接上代码吧，思想是dp的思想，...","link":"","photos":[],"count_time":{"symbolsCount":"1.9k","symbolsTime":"2 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":39,"path":"api/tags/ACM.json"},{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"学习","slug":"学习","count":43,"path":"api/tags/学习.json"},{"name":"算法","slug":"算法","count":20,"path":"api/tags/算法.json"},{"name":"数据结构","slug":"数据结构","count":23,"path":"api/tags/数据结构.json"},{"name":"Floyd","slug":"Floyd","count":1,"path":"api/tags/Floyd.json"},{"name":"图论","slug":"图论","count":3,"path":"api/tags/图论.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"tech otakus save the world","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}},{"title":"ACM学习笔记day18(dfs)","uid":"43196df8e77fd8e5155e9b94ef5532f4","slug":"ACM学习笔记day18","date":"2022-12-10T15:15:28.000Z","updated":"2023-04-08T10:51:30.587Z","comments":true,"path":"api/articles/ACM学习笔记day18.json","keywords":null,"cover":"/img/codeforces.jpg","text":"今天的内容是dfs，对应的acwing题目 dfs深搜，不难理解，而且之前在白书上我也学过啥意思也不多赘述这里主要讲解一下这题的思路 给你个n，让你求所有可能的排列组合，也就是求permutation因为n很小，所有dfs能过我们从第0个数字开始接下来选第1个数字，有n中可能对应...","link":"","photos":[],"count_time":{"symbolsCount":"1.3k","symbolsTime":"1 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":39,"path":"api/tags/ACM.json"},{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"学习","slug":"学习","count":43,"path":"api/tags/学习.json"},{"name":"算法","slug":"算法","count":20,"path":"api/tags/算法.json"},{"name":"数据结构","slug":"数据结构","count":23,"path":"api/tags/数据结构.json"},{"name":"dfs","slug":"dfs","count":4,"path":"api/tags/dfs.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"tech otakus save the world","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}},{"title":"ACM学习笔记day19(N皇后问题-2种dfs解法)","uid":"983fdf7c1cf56eb82d4bc470facb21cc","slug":"ACM学习笔记day19","date":"2022-12-11T14:48:21.000Z","updated":"2023-04-08T10:51:37.675Z","comments":true,"path":"api/articles/ACM学习笔记day19.json","keywords":null,"cover":"/img/codeforces.jpg","text":"今天的内容是N皇后问题，有两种dfs方法，但是自己在写的时候还是碰到了不少问题的。 第一种dfs方法这种dfs方法，是基于我们已经知道了，每一行每一列每一主对角线和副对角线上只能有一个皇后。思想和数字的全排列差不多。我们dfs第零行到第n-1行，然后枚举第零列到第n-1列，如果有...","link":"","photos":[],"count_time":{"symbolsCount":"3.4k","symbolsTime":"3 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":39,"path":"api/tags/ACM.json"},{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"学习","slug":"学习","count":43,"path":"api/tags/学习.json"},{"name":"算法","slug":"算法","count":20,"path":"api/tags/算法.json"},{"name":"数据结构","slug":"数据结构","count":23,"path":"api/tags/数据结构.json"},{"name":"dfs","slug":"dfs","count":4,"path":"api/tags/dfs.json"},{"name":"N皇后","slug":"N皇后","count":1,"path":"api/tags/N皇后.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"tech otakus save the world","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}},{"title":"ACM学习笔记day2","uid":"a8b932df9b747ba9300a0aa8e66533aa","slug":"ACM学习笔记day2","date":"2022-11-07T02:41:28.000Z","updated":"2023-04-08T10:50:24.513Z","comments":true,"path":"api/articles/ACM学习笔记day2.json","keywords":null,"cover":"/img/codeforces.jpg","text":"hello guys！这里是Ausert！这里是我学习ACM相关知识打卡的地方，当然，不会是一些学习笔记啥的(后面被打脸了QAQ)只是一些小的注意点，或者心得啥的不要问我为什么没有day1的打卡博客。因为那个时候网站还没有搭建起来&#x3D; &#x3D;So here we g...","link":"","photos":[],"count_time":{"symbolsCount":579,"symbolsTime":"1 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":39,"path":"api/tags/ACM.json"},{"name":"学习","slug":"学习","count":43,"path":"api/tags/学习.json"},{"name":"算法","slug":"算法","count":20,"path":"api/tags/算法.json"},{"name":"数据结构","slug":"数据结构","count":23,"path":"api/tags/数据结构.json"},{"name":"打卡（大概）","slug":"打卡（大概）","count":1,"path":"api/tags/打卡（大概）.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"tech otakus save the world","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}},{"title":"ACM学习笔记day20(走迷宫bfs)","uid":"955da31dc34cc48d9fa1d8587dc420ff","slug":"ACM学习笔记day20","date":"2022-12-16T13:50:22.000Z","updated":"2023-04-08T10:51:47.380Z","comments":true,"path":"api/articles/ACM学习笔记day20.json","keywords":null,"cover":"/img/codeforces.jpg","text":"hello guys！今天的内容是走迷宫。额，好像叕好久没有更新博客了。呃呃呃。好像确实有点摆（是非常吧。好的，我们来看问题。 走迷宫问题，这个不多说，啥意思很容易理解题源：acwing;所用的思想就是bfs算法。bfs算法其实是有一个固定的算法模板的。 while(queue非...","link":"","photos":[],"count_time":{"symbolsCount":"1.9k","symbolsTime":"2 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":39,"path":"api/tags/ACM.json"},{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"学习","slug":"学习","count":43,"path":"api/tags/学习.json"},{"name":"算法","slug":"算法","count":20,"path":"api/tags/算法.json"},{"name":"数据结构","slug":"数据结构","count":23,"path":"api/tags/数据结构.json"},{"name":"bfs","slug":"bfs","count":3,"path":"api/tags/bfs.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"tech otakus save the world","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}},{"title":"ACM学习笔记day21(试除法判定质数，分解质因数，质数筛（朴素筛，埃氏筛，线性筛）,试除法求约数)","uid":"a894f3fb49a6e9d5b26247e277bba209","slug":"ACM学习笔记day21","date":"2023-01-17T15:01:09.000Z","updated":"2023-04-08T10:51:54.252Z","comments":true,"path":"api/articles/ACM学习笔记day21.json","keywords":null,"cover":"/img/codeforces.jpg","text":"emmmm，距离上次写blog好像已经是很久以前的事情了XD(其实就是自己摆)那么今天的内容是试除法判定质数，分解质因数，还有三个质数筛。 试除法判定质数 题目这个很好理解，就是一个一个数去取余所给的数，如果存在一个数正好取余的话，那就说明这个数不是质数。同时有一个结论，那就是如...","link":"","photos":[],"count_time":{"symbolsCount":"6.1k","symbolsTime":"6 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":39,"path":"api/tags/ACM.json"},{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"笔记","slug":"笔记","count":3,"path":"api/tags/笔记.json"},{"name":"数论","slug":"数论","count":5,"path":"api/tags/数论.json"},{"name":"质数","slug":"质数","count":1,"path":"api/tags/质数.json"},{"name":"约数","slug":"约数","count":2,"path":"api/tags/约数.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"tech otakus save the world","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}},{"title":"ACM学习笔记day22 (约数个数，约数之和，最大公约数)","uid":"3438dc43ca9a9de9df433abe2e751c9e","slug":"ACM学习笔记day22","date":"2023-01-23T13:17:12.000Z","updated":"2023-04-08T10:52:01.459Z","comments":true,"path":"api/articles/ACM学习笔记day22.json","keywords":null,"cover":"/img/codeforces.jpg","text":"浅过了个年，差不多了，应该回来念书了XD今天的内容是约数个数，约数之和，最大公约数。 约数个数,约数之和对于这个问题，其实就是两个公式。具体的证明，可以自寻资料查看。这里仅给出结果，和我自己的理解。严格的数学证明我们不多赘述。以下为公式(图中pi为N的质因数)： 好，公式我们给出...","link":"","photos":[],"count_time":{"symbolsCount":"3.2k","symbolsTime":"3 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":39,"path":"api/tags/ACM.json"},{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"学习","slug":"学习","count":43,"path":"api/tags/学习.json"},{"name":"数论","slug":"数论","count":5,"path":"api/tags/数论.json"},{"name":"约数","slug":"约数","count":2,"path":"api/tags/约数.json"},{"name":"公式","slug":"公式","count":1,"path":"api/tags/公式.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"tech otakus save the world","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}},{"title":"ACM学习笔记day23(欧拉函数，筛法求欧拉函数，快速幂，快速幂求逆元)","uid":"ead55ceebbb5da582503c01cc4b636b6","slug":"ACM学习笔记day23","date":"2023-01-24T13:07:47.000Z","updated":"2023-04-08T10:52:11.128Z","comments":true,"path":"api/articles/ACM学习笔记day23.json","keywords":null,"cover":"/img/codeforces.jpg","text":"今天的内容是欧拉函数和快速幂，主要是这两个。其中最后那个逆元，emm感觉好难理解QAQ 欧拉函数欧拉函数的定义： 由定义我们容易得出，对于求一个数字N的欧拉函数的值，我们按照定义来就可以了。时间复杂度是O(sqrt(N))。因为分解质因数要根号n，然后乘法乘上去也是根号n。所以时...","link":"","photos":[],"count_time":{"symbolsCount":"5.8k","symbolsTime":"5 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":39,"path":"api/tags/ACM.json"},{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"学习","slug":"学习","count":43,"path":"api/tags/学习.json"},{"name":"数论","slug":"数论","count":5,"path":"api/tags/数论.json"},{"name":"数学","slug":"数学","count":7,"path":"api/tags/数学.json"},{"name":"快速幂","slug":"快速幂","count":1,"path":"api/tags/快速幂.json"},{"name":"欧拉函数","slug":"欧拉函数","count":1,"path":"api/tags/欧拉函数.json"},{"name":"逆元","slug":"逆元","count":1,"path":"api/tags/逆元.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"tech otakus save the world","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}},{"title":"ACM学习笔记day26 (高斯消元解线性方程组和异或方程组)","uid":"1a520a07ea86cfe9d127f0b6811d1363","slug":"ACM学习笔记day26","date":"2023-02-04T13:00:01.000Z","updated":"2023-04-08T10:52:31.322Z","comments":true,"path":"api/articles/ACM学习笔记day26.json","keywords":null,"cover":"/img/codeforces.jpg","text":"今天的内容是使用高斯消元解线性方程组和异或方程组。什么是高斯消元，不多说，线代的基本内容。 高斯消元解线性方程组用高斯消元解线性方程组的时候，编程解决其实就是一个模拟的事情。我们写程序去模拟我们的实际进行的步骤。该模板的时间复杂度为O(n^3)。可以看到时间复杂度还是很高的。如果...","link":"","photos":[],"count_time":{"symbolsCount":"4.7k","symbolsTime":"4 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":39,"path":"api/tags/ACM.json"},{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"学习","slug":"学习","count":43,"path":"api/tags/学习.json"},{"name":"数学","slug":"数学","count":7,"path":"api/tags/数学.json"},{"name":"高斯消元","slug":"高斯消元","count":1,"path":"api/tags/高斯消元.json"},{"name":"解方程组","slug":"解方程组","count":1,"path":"api/tags/解方程组.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"tech otakus save the world","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}},{"title":"ACM学习笔记day28 (组合数的应用——满足条件的01序列，容斥原理)","uid":"cd92aa8f26118d15f6c9920aff860d6f","slug":"ACM学习笔记day28","date":"2023-02-07T09:31:39.000Z","updated":"2023-04-08T10:52:45.948Z","comments":true,"path":"api/articles/ACM学习笔记day28.json","keywords":null,"cover":"/img/codeforces.jpg","text":"今天的内容是组合数的应用——满足条件的01序列和容斥原理。关于这个满足条件的01序列，其实涉及到了一个特殊的数字卡特兰数。这个我们等会会讲这个。 满足条件的01序列题目意思就是给你n个0，n个1，让你排出来一个序列，使得对于任意的前缀，0的数量是大于等于1的数量的。问你这样的序列...","link":"","photos":[],"count_time":{"symbolsCount":"3.2k","symbolsTime":"3 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":39,"path":"api/tags/ACM.json"},{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"学习","slug":"学习","count":43,"path":"api/tags/学习.json"},{"name":"数学","slug":"数学","count":7,"path":"api/tags/数学.json"},{"name":"组合数","slug":"组合数","count":2,"path":"api/tags/组合数.json"},{"name":"容斥原理","slug":"容斥原理","count":1,"path":"api/tags/容斥原理.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"tech otakus save the world","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}},{"title":"ACM学习笔记day29 (Nim游戏，台阶-Nim游戏)","uid":"8af78f8e46bb9ac28caa93ffafd43362","slug":"ACM学习笔记day29","date":"2023-02-08T08:10:48.000Z","updated":"2023-04-08T10:52:54.992Z","comments":true,"path":"api/articles/ACM学习笔记day29.json","keywords":null,"cover":"/img/codeforces.jpg","text":"今天的内容是博弈论的一部分（后面有涉及到SG函数和MEX函数的额，还没听懂（所以只有这两个了。两个一个是Nim游戏是最基础的模型，台阶-Nim游戏是Nim游戏的进阶版本。 Nim游戏就是两个人轮流拿，随便拿几个，随便拿哪一堆的，拿到最后谁不能操作了，谁就输了。这里我们要讲两个概念...","link":"","photos":[],"count_time":{"symbolsCount":"2.6k","symbolsTime":"2 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":39,"path":"api/tags/ACM.json"},{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"学习","slug":"学习","count":43,"path":"api/tags/学习.json"},{"name":"数学","slug":"数学","count":7,"path":"api/tags/数学.json"},{"name":"博弈论","slug":"博弈论","count":1,"path":"api/tags/博弈论.json"},{"name":"Nim游戏","slug":"Nim游戏","count":1,"path":"api/tags/Nim游戏.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"tech otakus save the world","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}},{"title":"ACM学习笔记day27(求组合数的四种办法)","uid":"ee586e84b57b3261ae39e785bb3a8c62","slug":"ACM学习笔记day27","date":"2023-02-05T09:20:05.000Z","updated":"2023-04-08T10:52:38.582Z","comments":true,"path":"api/articles/ACM学习笔记day27.json","keywords":null,"cover":"/img/codeforces.jpg","text":"今天的内容是求组合数の四种办法。前三种是逐渐应对给的数据量变大的情况的。第四种是应对得到的结果太大会把longlong都爆掉的情况的。 注意：本篇中，涉及C[a][b]的均是以下组合数表达式。 因为这个blog主题不支持latex语言，所以也没办法现敲公式。 求组合数I这种求组合...","link":"","photos":[],"count_time":{"symbolsCount":"6.2k","symbolsTime":"6 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":39,"path":"api/tags/ACM.json"},{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"学习","slug":"学习","count":43,"path":"api/tags/学习.json"},{"name":"数学","slug":"数学","count":7,"path":"api/tags/数学.json"},{"name":"组合数","slug":"组合数","count":2,"path":"api/tags/组合数.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"tech otakus save the world","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}},{"title":"ACM学习笔记day3(高精度四则运算)","uid":"ffffeb1fbf512f768ee4d72750569670","slug":"ACM学习笔记day3","date":"2022-11-08T14:01:59.000Z","updated":"2023-04-08T10:49:48.429Z","comments":true,"path":"api/articles/ACM学习笔记day3.json","keywords":null,"cover":"/img/codeforces.jpg","text":"学习ACM有关东西的第四天。今天用晚上时间稍微学了点高精度加减乘除的运算。感觉是在模拟人类的运算过程，除了乘法(这不废话)So,Here we go! 总述有必要说明一下，对于高精度的四则运算，加法和减法是两个高精度的数字，而乘法和除法是一个高精度乘或者除以一个数同时因为数字的位...","link":"","photos":[],"count_time":{"symbolsCount":"6.6k","symbolsTime":"6 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":39,"path":"api/tags/ACM.json"},{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"学习","slug":"学习","count":43,"path":"api/tags/学习.json"},{"name":"算法","slug":"算法","count":20,"path":"api/tags/算法.json"},{"name":"数据结构","slug":"数据结构","count":23,"path":"api/tags/数据结构.json"},{"name":"蒟蒻","slug":"蒟蒻","count":4,"path":"api/tags/蒟蒻.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"tech otakus save the world","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}},{"title":"ACM学习笔记day30 (01背包，完全背包,多重背包(朴素解法))","uid":"26c83eef7dc2b42905d68bf63d792926","slug":"ACM学习笔记day30","date":"2023-02-11T11:53:11.000Z","updated":"2023-04-08T10:53:02.760Z","comments":true,"path":"api/articles/ACM学习笔记day30.json","keywords":null,"cover":"/img/codeforces.jpg","text":"今天的内容是01背包多重背包完全背包。算是开启DP专题了。01背包是作为最关键的一个题目。其他完全背包和多重背包其实就是他的扩展。理解了01背包，理解其他的背包其实不难。 01背包01背包问题的解法，先从朴素开始。我们定义一个二维数组作为我们dp的数组。f[i][j]的意义为从前...","link":"","photos":[],"count_time":{"symbolsCount":"4.8k","symbolsTime":"4 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":39,"path":"api/tags/ACM.json"},{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"学习","slug":"学习","count":43,"path":"api/tags/学习.json"},{"name":"蒟蒻","slug":"蒟蒻","count":4,"path":"api/tags/蒟蒻.json"},{"name":"DP","slug":"DP","count":5,"path":"api/tags/DP.json"},{"name":"动态规划","slug":"动态规划","count":5,"path":"api/tags/动态规划.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"tech otakus save the world","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}},{"title":"ACM学习笔记day32 (数字三角形，最长上升子序列)","uid":"0c3e2aa6872231e13fd503f7a08ea40b","slug":"ACM学习笔记day32","date":"2023-02-20T14:18:20.000Z","updated":"2023-04-08T10:53:21.330Z","comments":true,"path":"api/articles/ACM学习笔记day32.json","keywords":null,"cover":"/img/codeforces.jpg","text":"今天的内容是数字三角形，和最长上升子序列。其中最长上升子序列可以说是dp问题里面非常经典的问题了。 数字三角形对于这个题，我们的dp思路其实很简单。当然在此之前，我们需要定义一下这个三角形的行和列。给的三角形是这样的: 7 3 8 8 1 0 2 7 4 4 4 5 2 6 5 ...","link":"","photos":[],"count_time":{"symbolsCount":"3.8k","symbolsTime":"3 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":39,"path":"api/tags/ACM.json"},{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"学习","slug":"学习","count":43,"path":"api/tags/学习.json"},{"name":"DP","slug":"DP","count":5,"path":"api/tags/DP.json"},{"name":"动态规划","slug":"动态规划","count":5,"path":"api/tags/动态规划.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"tech otakus save the world","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}},{"title":"ACM学习笔记day33 (状态压缩DP)","uid":"2c6fdca36eef66c662c85d61e609fdfd","slug":"ACM学习笔记day33","date":"2023-02-28T14:11:30.000Z","updated":"2023-04-08T10:53:42.797Z","comments":true,"path":"api/articles/ACM学习笔记day33.json","keywords":null,"cover":"/img/codeforces.jpg","text":"状态压缩DP，其实就是线性DP的基础上加上了状态压缩。 那么什么是状态压缩呢？其实就是将状态的集合，通过一种特定的方式来便利的表示出来，同时也降低了时间复杂度。一般的，我们会将很多种取或者不取的状态集合，用一个01串来表示。这样也就是通过状态压缩来实现这种功能了。 例如在蒙德里安...","link":"","photos":[],"count_time":{"symbolsCount":394,"symbolsTime":"1 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":39,"path":"api/tags/ACM.json"},{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"学习","slug":"学习","count":43,"path":"api/tags/学习.json"},{"name":"DP","slug":"DP","count":5,"path":"api/tags/DP.json"},{"name":"动态规划","slug":"动态规划","count":5,"path":"api/tags/动态规划.json"},{"name":"状态压缩DP","slug":"状态压缩DP","count":1,"path":"api/tags/状态压缩DP.json"},{"name":"状态压缩","slug":"状态压缩","count":1,"path":"api/tags/状态压缩.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"tech otakus save the world","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}},{"title":"ACM学习笔记day34 (DP专题的总结)","uid":"2c328a2145590af1c8c2b559a8951062","slug":"ACM学习笔记day34","date":"2023-03-19T10:29:55.000Z","updated":"2023-04-08T10:53:59.571Z","comments":true,"path":"api/articles/ACM学习笔记day34.json","keywords":null,"cover":"/img/codeforces.jpg","text":"已经很久没有写笔记了。主要是我一方面我摆（bushi,另外一个就是，后面的各种DP其实写笔记也没啥好写的，主要是理解这个DP是啥，然后也没有对应的板子好写的。自然也就不更新笔记了。那么最近是把基础的DP都学完了，作一个总结，大致的讲一下DP到底是个啥。DP的分类有啥怎么分类的。 ...","link":"","photos":[],"count_time":{"symbolsCount":"2.3k","symbolsTime":"2 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":39,"path":"api/tags/ACM.json"},{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"笔记","slug":"笔记","count":3,"path":"api/tags/笔记.json"},{"name":"DP","slug":"DP","count":5,"path":"api/tags/DP.json"},{"name":"动态规划","slug":"动态规划","count":5,"path":"api/tags/动态规划.json"},{"name":"专题总结","slug":"专题总结","count":1,"path":"api/tags/专题总结.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"tech otakus save the world","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}},"feature":true},{"title":"ACM学习笔记day35(拓扑序列)","uid":"f4b8c236f24c3289ca5c3e33420c6ba4","slug":"ACM学习笔记day35","date":"2023-03-21T14:49:38.000Z","updated":"2023-04-08T10:54:07.183Z","comments":true,"path":"api/articles/ACM学习笔记day35.json","keywords":null,"cover":"/img/codeforces.jpg","text":"今天的内容是拓扑排序。 若一个由图中所有点构成的序列A满足：对于图中的每条边 (x,y) x 在 A 中都出现在 y 之前，则称 A 是该图的一个拓扑序列。注意：图的拓扑序并不一定唯一所以题目的答案并不唯一。 那么我们应该怎么去求拓扑序列呢？很显然，我们从定义出发，我们需要保证序...","link":"","photos":[],"count_time":{"symbolsCount":"1.8k","symbolsTime":"2 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":39,"path":"api/tags/ACM.json"},{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"学习","slug":"学习","count":43,"path":"api/tags/学习.json"},{"name":"图论","slug":"图论","count":3,"path":"api/tags/图论.json"},{"name":"dfs","slug":"dfs","count":4,"path":"api/tags/dfs.json"},{"name":"bfs","slug":"bfs","count":3,"path":"api/tags/bfs.json"},{"name":"拓扑排序","slug":"拓扑排序","count":1,"path":"api/tags/拓扑排序.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"tech otakus save the world","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}},{"title":"ACM学习笔记day36(树和图的DFS和BFS)","uid":"1429a762104f1c731f39acc20f00d741","slug":"ACM学习笔记day36","date":"2023-03-25T12:50:55.000Z","updated":"2023-04-08T10:54:15.019Z","comments":true,"path":"api/articles/ACM学习笔记day36.json","keywords":null,"cover":"/img/codeforces.jpg","text":"水一篇blog（树和图的bfs和dfs。 树和图的存储方式采用领接表或者是领接矩阵都可以。dfs和bfs的思路是一样的。bfs套用bfs的模板就可以了，定义一个工作队列。将没有访问过的领接点放入队列中，然后处理即可dfs就遍历他的所有领接点，然后如果没访问过的话就dfs下去。然后...","link":"","photos":[],"count_time":{"symbolsCount":"1.9k","symbolsTime":"2 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":39,"path":"api/tags/ACM.json"},{"name":"学习","slug":"学习","count":43,"path":"api/tags/学习.json"},{"name":"图论","slug":"图论","count":3,"path":"api/tags/图论.json"},{"name":"dfs","slug":"dfs","count":4,"path":"api/tags/dfs.json"},{"name":"bfs","slug":"bfs","count":3,"path":"api/tags/bfs.json"},{"name":"树","slug":"树","count":1,"path":"api/tags/树.json"},{"name":"图","slug":"图","count":1,"path":"api/tags/图.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"tech otakus save the world","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}},{"title":"ACM学习笔记day37 (最短路算法总结)","uid":"d62cd488fd25981616571e6226f3871a","slug":"ACM学习笔记day37","date":"2023-03-25T12:51:16.000Z","updated":"2024-12-29T14:18:21.976Z","comments":true,"path":"api/articles/ACM学习笔记day37.json","keywords":null,"cover":"/img/codeforces.jpg","text":"好，我们这一节对最短路算法作一个总结。总的来说基础的最短路算法有四种。分别为 Dijksta,bellman-ford，spfa，floyd算法。不同的算法应对的是不同的情况。 什么算法解决什么问题，可以看下面这张图。 我们最短路问题，可以分为两大类问题，一类是单源最短路，也就是...","link":"","photos":[],"count_time":{"symbolsCount":"8.9k","symbolsTime":"8 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":39,"path":"api/tags/ACM.json"},{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"学习","slug":"学习","count":43,"path":"api/tags/学习.json"},{"name":"最短路问题","slug":"最短路问题","count":1,"path":"api/tags/最短路问题.json"},{"name":"Dijkstra","slug":"Dijkstra","count":1,"path":"api/tags/Dijkstra.json"},{"name":"Bellman-ford","slug":"Bellman-ford","count":1,"path":"api/tags/Bellman-ford.json"},{"name":"spfa","slug":"spfa","count":1,"path":"api/tags/spfa.json"},{"name":"floyd","slug":"floyd","count":1,"path":"api/tags/floyd.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"tech otakus save the world","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}},"feature":false},{"title":"ACM学习笔记day38(最小生成树,染色法判定二分图，匈牙利算法)","uid":"aade77e076015616546b7ec40503f52f","slug":"ACM学习笔记day38","date":"2023-03-25T12:51:23.000Z","updated":"2023-08-27T09:15:36.952Z","comments":true,"path":"api/articles/ACM学习笔记day38.json","keywords":null,"cover":"/img/codeforces.jpg","text":"在总结了各种的最短路算法之后，我们终于也是迎来了，图论基础算法的最后一部分内容。一个是最小生成树的求法。一个是有关二分图的问题。 关于这部分的内容，可以看下面这个大致的思维导图。 最小生成树对于基础的图论。最小生成树一共有两种算法。一种是prim算法，一种就是kruskal算法。...","link":"","photos":[],"count_time":{"symbolsCount":"9.4k","symbolsTime":"9 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":39,"path":"api/tags/ACM.json"},{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"Prim","slug":"Prim","count":1,"path":"api/tags/Prim.json"},{"name":"Kruskal","slug":"Kruskal","count":1,"path":"api/tags/Kruskal.json"},{"name":"染色法","slug":"染色法","count":1,"path":"api/tags/染色法.json"},{"name":"二分图","slug":"二分图","count":1,"path":"api/tags/二分图.json"},{"name":"匈牙利算法","slug":"匈牙利算法","count":1,"path":"api/tags/匈牙利算法.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"tech otakus save the world","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}},{"title":"ACM学习笔记day4(前缀和和差分)","uid":"4143f6a2444e4122fe8da477a7a2d540","slug":"ACM学习笔记day4","date":"2022-11-09T14:02:19.000Z","updated":"2023-04-08T10:49:05.915Z","comments":true,"path":"api/articles/ACM学习笔记day4.json","keywords":null,"cover":"/img/codeforces.jpg","text":"今天学了前缀和和差分，及其数组。前缀和不多说了，比较好理解，主要还是差分，这个比较抽象 前缀和主要注意一下，前缀和数组从1开始，0的位置就归零，这样就不用地方越界问题了。 差分至于差分。emmmm差分数组不需要构建，~~~当然也可以构建~~~二位差分同理 int a[N],B[N...","link":"","photos":[],"count_time":{"symbolsCount":875,"symbolsTime":"1 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":39,"path":"api/tags/ACM.json"},{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"学习","slug":"学习","count":43,"path":"api/tags/学习.json"},{"name":"算法","slug":"算法","count":20,"path":"api/tags/算法.json"},{"name":"数据结构","slug":"数据结构","count":23,"path":"api/tags/数据结构.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"tech otakus save the world","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}},{"title":"ACM学习笔记day40(无懒标记线段树)","uid":"f730cb1c16c6cae11f6020e8c15e8535","slug":"ACM学习笔记day40","date":"2023-08-26T14:16:45.000Z","updated":"2023-08-27T09:15:54.897Z","comments":true,"path":"api/articles/ACM学习笔记day40.json","keywords":null,"cover":"/img/codeforces.jpg","text":"不带懒标记的线段树的板子。注意代码中节点属性是区间的最大值。下面为代码： struct node&#123; int l,r; int maxnum; &#125;; node tree[N*4]; void pushup(int u)&#123; tree[u].maxnum&...","link":"","photos":[],"count_time":{"symbolsCount":"3.8k","symbolsTime":"3 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":39,"path":"api/tags/ACM.json"},{"name":"数据结构","slug":"数据结构","count":23,"path":"api/tags/数据结构.json"},{"name":"线段树","slug":"线段树","count":2,"path":"api/tags/线段树.json"},{"name":"板子","slug":"板子","count":2,"path":"api/tags/板子.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"tech otakus save the world","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}},{"title":"ACM学习笔记day41(懒标记线段树)","uid":"5a6c29c310d82ce99bfc421188b80faf","slug":"ACM学习笔记day41","date":"2023-08-27T07:57:57.000Z","updated":"2024-01-02T13:30:31.813Z","comments":true,"path":"api/articles/ACM学习笔记day41.json","keywords":null,"cover":"/img/codeforces.jpg","text":"带懒标记的线段树实际上的函数就多了一个，pushdown操作。以下为板子：板子题目链接板子中线段树维护的是一段区间的数组的和。懒标记表示的是该节点的子树要加上去的值，不包括他自己。 struct node&#123; int l,r; ll sum&#x3D;0; ll add&...","link":"","photos":[],"count_time":{"symbolsCount":"5.2k","symbolsTime":"5 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":39,"path":"api/tags/ACM.json"},{"name":"数据结构","slug":"数据结构","count":23,"path":"api/tags/数据结构.json"},{"name":"线段树","slug":"线段树","count":2,"path":"api/tags/线段树.json"},{"name":"板子","slug":"板子","count":2,"path":"api/tags/板子.json"},{"name":"懒标记","slug":"懒标记","count":1,"path":"api/tags/懒标记.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"tech otakus save the world","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}},{"title":"ACM学习笔记day5(双指针，位运算)","uid":"ceed889808223c52789eb0c0c60367bf","slug":"ACM学习笔记day5","date":"2022-11-10T09:25:34.000Z","updated":"2023-04-08T10:48:56.517Z","comments":true,"path":"api/articles/ACM学习笔记day5.json","keywords":null,"cover":"/img/codeforces.jpg","text":"今天学习了一下双指针算法，感觉还是挺难的。就是一个由单调性可以推出应该用双指针这个有点不是很能理解。QAQ还有个位运算。 求最长无重复数字的子串问题 采用双指针的算法的话，我们让i从头到尾遍历数组，对于每一个i，j表示当前子串的左边界。如果在j到i这块子串有相同的数字，则让j++...","link":"","photos":[],"count_time":{"symbolsCount":"1.5k","symbolsTime":"1 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":39,"path":"api/tags/ACM.json"},{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"学习","slug":"学习","count":43,"path":"api/tags/学习.json"},{"name":"算法","slug":"算法","count":20,"path":"api/tags/算法.json"},{"name":"数据结构","slug":"数据结构","count":23,"path":"api/tags/数据结构.json"},{"name":"双指针","slug":"双指针","count":1,"path":"api/tags/双指针.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"tech otakus save the world","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}},{"title":"ACM学习笔记day7(区间合并，静态单链表，静态双向链表)","uid":"6626baeb85b77ff2abeecddea4b9b43b","slug":"ACM学习笔记day7","date":"2022-11-12T15:20:17.000Z","updated":"2023-04-08T10:49:14.216Z","comments":true,"path":"api/articles/ACM学习笔记day7.json","keywords":null,"cover":"/img/codeforces.jpg","text":"emm今天搞了点区间合并和静态链表。感觉静态链表的写法还是比较繁琐的。逻辑上感觉有点绕可能是我写习惯动态链表的原因吧（ 区间合并题目来源Acwing链接题目不难，贪心就能做。当时不讲，直接做出来了。不多赘述。 #include&lt;bits&#x2F;stdc++.h&gt; ...","link":"","photos":[],"count_time":{"symbolsCount":"4.3k","symbolsTime":"4 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":39,"path":"api/tags/ACM.json"},{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"学习","slug":"学习","count":43,"path":"api/tags/学习.json"},{"name":"算法","slug":"算法","count":20,"path":"api/tags/算法.json"},{"name":"数据结构","slug":"数据结构","count":23,"path":"api/tags/数据结构.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"tech otakus save the world","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}},{"title":"ACM学习笔记day8(模拟栈，表达式求值，模拟队列，单调栈)","uid":"0bde88ed9132d2dd0ee34fc3f801dfcc","slug":"ACM学习笔记day8","date":"2022-11-15T13:52:59.000Z","updated":"2023-04-08T10:49:21.906Z","comments":true,"path":"api/articles/ACM学习笔记day8.json","keywords":null,"cover":"/img/codeforces.jpg","text":"wdnmd,受不了了，一拳把地球打爆。今天的内容原本应该是11月13号的因为当晚是有个讲座要听，没空写博客想着明天写，结果昨天忙的要死，今天还是忙的要死今天晚上终于稍微有点空了，赶紧把博客给补了，顺便也隔了几天复习一下东西。今天主要学的是 模拟栈，表达式求值，模拟队列和单调栈。 ...","link":"","photos":[],"count_time":{"symbolsCount":"2.9k","symbolsTime":"3 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":39,"path":"api/tags/ACM.json"},{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"学习","slug":"学习","count":43,"path":"api/tags/学习.json"},{"name":"算法","slug":"算法","count":20,"path":"api/tags/算法.json"},{"name":"数据结构","slug":"数据结构","count":23,"path":"api/tags/数据结构.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"tech otakus save the world","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}},{"title":"ACM小本本","uid":"4a9ea142753f2671aa4c5ecbc1f2c491","slug":"ACM小本本","date":"2022-11-09T12:43:41.000Z","updated":"2023-08-25T14:20:11.540Z","comments":true,"path":"api/articles/ACM小本本.json","keywords":null,"cover":"/img/codeforces.jpg","text":"这里是记录ACM知识点中一些零碎的东西，或者一些小的注意点啥的 1.使用二分模板的时候，当修改left值的时候，注意要让mid&#x3D;left+right+1&gt;&gt;1，不然会出现mid&#x3D;left然后死循环的出现2.快排和归并的本质就是分治，快排是先处理数据...","link":"","photos":[],"count_time":{"symbolsCount":"2k","symbolsTime":"2 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":39,"path":"api/tags/ACM.json"},{"name":"学习","slug":"学习","count":43,"path":"api/tags/学习.json"},{"name":"笔记本","slug":"笔记本","count":2,"path":"api/tags/笔记本.json"},{"name":"零碎的","slug":"零碎的","count":2,"path":"api/tags/零碎的.json"},{"name":"知识点","slug":"知识点","count":2,"path":"api/tags/知识点.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"tech otakus save the world","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}},"feature":true},{"title":"ACM学习笔记day9(滑动窗口，双端队列)","uid":"958adf9461e6c3975304da3314c38d67","slug":"ACM学习笔记day9","date":"2022-11-17T13:07:42.000Z","updated":"2023-04-08T10:49:25.073Z","comments":true,"path":"api/articles/ACM学习笔记day9.json","keywords":null,"cover":"/img/codeforces.jpg","text":"今天学习的时间比较短，哦，确实也挺短的不过当时比较困，理解起来也很慢，所以今天的内容只有一个是滑动窗口和双端队列！ 滑动窗口什么是滑动窗口！就是单调队列的一道经典例题链接这里因为要用到了单调队列。我acwing上打卡用的是数组模拟双端队列的。而目前上面的题解是使用STL里面的双端...","link":"","photos":[],"count_time":{"symbolsCount":"2.4k","symbolsTime":"2 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":39,"path":"api/tags/ACM.json"},{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"学习","slug":"学习","count":43,"path":"api/tags/学习.json"},{"name":"算法","slug":"算法","count":20,"path":"api/tags/算法.json"},{"name":"数据结构","slug":"数据结构","count":23,"path":"api/tags/数据结构.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"tech otakus save the world","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}},{"title":"ACM学习笔记day6(离散化)","uid":"1e7a8acd61656fdbe512e6f88b5aff86","slug":"ACM学习笔记day6","date":"2022-11-10T13:57:48.000Z","updated":"2023-04-08T10:49:10.497Z","comments":true,"path":"api/articles/ACM学习笔记day6.json","keywords":null,"cover":"/img/codeforces.jpg","text":"其实这一节，应该是day5里面的，因为呃呃呃我看到这一节acwing里面的视频长度比较长，所以我就分割出来作为单独的一个blog来写了。算法的思想比较重要。 离散化 题目acwing区间和说实话，离散化的概念不难理解但是实际运用起来，发现诶，用不来了 首先，什么是离散化？离散化一...","link":"","photos":[],"count_time":{"symbolsCount":"3k","symbolsTime":"3 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":39,"path":"api/tags/ACM.json"},{"name":"打卡","slug":"打卡","count":35,"path":"api/tags/打卡.json"},{"name":"学习","slug":"学习","count":43,"path":"api/tags/学习.json"},{"name":"算法","slug":"算法","count":20,"path":"api/tags/算法.json"},{"name":"数据结构","slug":"数据结构","count":23,"path":"api/tags/数据结构.json"},{"name":"离散化","slug":"离散化","count":1,"path":"api/tags/离散化.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"tech otakus save the world","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}},{"title":"扩展欧几里得2（exgcd的最小正整数解，通解）","uid":"f37560f9bc1b5fea2432f5534d910cca","slug":"扩展欧几里得2","date":"2023-07-19T13:53:28.000Z","updated":"2024-12-29T15:41:16.831Z","comments":true,"path":"api/articles/扩展欧几里得2.json","keywords":null,"cover":"/img/codeforces.jpg","text":"由exgcd我们可以得到如下式子的一对解，前提是有解。ax+by&#x3D;c; (c%gcd(a,b)&#x3D;&#x3D;0)设一组解为x1,y1;即ax1+by1&#x3D;c; 记 u &#x3D; a*b&#x2F;gcd(a,b); 通解为:x&#x3D;x1+u&...","link":"","photos":[],"count_time":{"symbolsCount":398,"symbolsTime":"1 mins."},"categories":[{"name":"ACM","slug":"ACM","count":42,"path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","count":39,"path":"api/tags/ACM.json"},{"name":"exgcd","slug":"exgcd","count":1,"path":"api/tags/exgcd.json"},{"name":"最小正整数解","slug":"最小正整数解","count":1,"path":"api/tags/最小正整数解.json"},{"name":"通解","slug":"通解","count":1,"path":"api/tags/通解.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"tech otakus save the world","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}},{"title":"题解-Codeforces-Round-837-div-2","uid":"8939638ff3772e749e6b91f98033c73a","slug":"题解-Codeforces-Round-837-div-2","date":"2022-12-12T11:57:48.000Z","updated":"2023-08-27T09:17:27.684Z","comments":true,"path":"api/articles/题解-Codeforces-Round-837-div-2.json","keywords":null,"cover":"/img/二次元の图/1.jpg","text":"蒟蒻又日常来尝试div2了，这次独立（额，算独立吗）做出来的只有A，B还是问了别人才做出来的，接下里的这个就是B的题解。下面这个做法真的十分的优雅。代码很简洁，思路也很清楚。 B-Hossam and Friends 题目链接 题目描述：一个人有n个朋友，按照1,2,3,4…，n...","link":"","photos":[],"count_time":{"symbolsCount":"2.2k","symbolsTime":"2 mins."},"categories":[{"name":"题解","slug":"题解","count":1,"path":"api/categories/题解.json"}],"tags":[{"name":"ACM","slug":"ACM","count":39,"path":"api/tags/ACM.json"},{"name":"学习","slug":"学习","count":43,"path":"api/tags/学习.json"},{"name":"算法","slug":"算法","count":20,"path":"api/tags/算法.json"},{"name":"数据结构","slug":"数据结构","count":23,"path":"api/tags/数据结构.json"},{"name":"codeforces","slug":"codeforces","count":1,"path":"api/tags/codeforces.json"},{"name":"题解","slug":"题解","count":1,"path":"api/tags/题解.json"}],"author":{"name":"Ausert","slug":"blog-author","avatar":"/img/Ausert.jpg","link":"/","description":"tech otakus save the world","socials":{"github":"https://github.com/AusertDream","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/102368527?spm_id_from=333.1007.0.0"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Ausert"}}}}}]}